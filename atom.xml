<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>百度一下jms的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-05T03:10:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>最爱冰红茶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Mac上搭建HLS视频直播</title>
    <link href="http://yoursite.com/2016/05/05/%E5%9C%A8Mac%E4%B8%8A%E6%90%AD%E5%BB%BAHLS%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    <id>http://yoursite.com/2016/05/05/在Mac上搭建HLS视频直播/</id>
    <published>2016-05-05T01:59:16.000Z</published>
    <updated>2016-05-05T03:10:38.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;HTTP Live Streaming(HLS)， 是苹果公司推出的视频直播协议，具体的内容可以到苹果开发者后台查看相关文档。简单地讲，就是将实时直播的视频，切割成大小基本相等的&lt;code&gt;.ts&lt;/code&gt; 文件和一个索引文件&lt;code&gt;prog_index.m3u8&lt;/code&gt;,然后通过索引文件来在web或者app中实现直播效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标-思路&quot;&gt;&lt;a href=&quot;#目标-思路&quot; class=&quot;headerlink&quot; title=&quot;目标/思路&quot;&gt;&lt;/a&gt;目标/思路&lt;/h3&gt;&lt;p&gt;本文目标：利用HLS技术，模拟一个视频直播平台。具体包括以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;VLC&lt;/code&gt;模拟一个直播视频的输入源；&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;mediastreamsegmenter&lt;/code&gt;将捕捉到的输入源视频切割成 .m3u8 格式文件；&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;Apache&lt;/code&gt;搭建本地服务器，在Safari中打开localhost，实现直播效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;具体实现&quot;&gt;&lt;a href=&quot;#具体实现&quot; class=&quot;headerlink&quot; title=&quot;具体实现&quot;&gt;&lt;/a&gt;具体实现&lt;/h3&gt;&lt;h5 id=&quot;VLC-多媒体播放器&quot;&gt;&lt;a href=&quot;#VLC-多媒体播放器&quot; class=&quot;headerlink&quot; title=&quot;VLC: 多媒体播放器&quot;&gt;&lt;/a&gt;VLC: 多媒体播放器&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接在百度上输入VLC，搜索下载安装Mac版的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置VLC: 打开VLC —&amp;gt; Open media —&amp;gt; Browse选择视频输入源，即将要用来以直播的形式展现出来的视频；然后勾选 Streaming/Saving,点击Setting,进行设置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/zzVLC01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/zzVLC02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，Address是当前Mac的ip地址，Port自定义。这个地址是输入源视频的地址，在切割视频的时候会用到这个地址。配置完成之后，点击ok, 然后如果你的视频很短，就不要着急点击open。&lt;/p&gt;
&lt;h5 id=&quot;启动Apache本地服务器&quot;&gt;&lt;a href=&quot;#启动Apache本地服务器&quot; class=&quot;headerlink&quot; title=&quot;启动Apache本地服务器&quot;&gt;&lt;/a&gt;启动Apache本地服务器&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开Mac终端，执行指令 &lt;code&gt;sudo apachectl start&lt;/code&gt;, 在浏览器中打开 localhost，如果出现 &lt;code&gt;It works&lt;/code&gt;，则说明Apache打开成功；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在路径 &lt;code&gt;/Library/WebServer/Documents/&lt;/code&gt;下建立文件新文件，我建的是 Games；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在路径 &lt;code&gt;/Library/WebServer/Documents/&lt;/code&gt;下新建一个文件名为index.html文件，html里的内容为：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;　　　　　　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meda&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;width=320;initial-scale=1.0;maximum-scale=1.0;user-scalable=0;&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;center&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;video&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Games/prog_index.m3u8&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;controls&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;autoplay&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;video&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;center&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;mediastreamsegmenter切割视频&quot;&gt;&lt;a href=&quot;#mediastreamsegmenter切割视频&quot; class=&quot;headerlink&quot; title=&quot;mediastreamsegmenter切割视频&quot;&gt;&lt;/a&gt;mediastreamsegmenter切割视频&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;这个是苹果公司提供的视频切割工具，可以在&lt;a href=&quot;https://developer.apple.com/streaming/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/streaming/&lt;/a&gt;进行下载，需要开发者账号登陆；&lt;/li&gt;
&lt;li&gt;在终端运行&lt;code&gt;mediastreamsegmenter -s 20 -D -f /Library/WebServer/Documents/Games 192.168.1.113:1234&lt;/code&gt;, 同时将运行VLC,即点击VLC中的Open。&lt;/li&gt;
&lt;li&gt;在Safari中打开localhost, 刚开始出现的是一个含有错误字样的播放控制条，稍等一会，直播就开始了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：VLC，mediastreamsegmenter，和Apache，在同一时间段，都要处于开启状态才可以在浏览器中看到直播效果。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;参考文档：&quot;&gt;&lt;a href=&quot;#参考文档：&quot; class=&quot;headerlink&quot; title=&quot;参考文档：&quot;&gt;&lt;/a&gt;参考文档：&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/technotes/tn2224/_index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/ios/technotes/tn2224/_index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HTTP Live Streaming(HLS)， 是苹果公司推出的视频直播协议，具体的内容可以到苹果开发者后台查看相关文档。简单地讲，就是将实时直播的视频，切割成大小基本相等的&lt;code&gt;.ts&lt;/code&gt; 文件和一个索引文件&lt;code&gt;pro
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac上使用Apache搭建服务器</title>
    <link href="http://yoursite.com/2016/05/04/Mac%E4%B8%8A%E4%BD%BF%E7%94%A8Apache%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/04/Mac上使用Apache搭建服务器/</id>
    <published>2016-05-04T08:08:24.000Z</published>
    <updated>2016-05-04T08:55:20.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本来是要搞HLS(苹果的视频直播处理技术)的，而且已经将mp4文件分割成m3u8类型直播文件，最后要验证m3u8文件的时候，却发现是要利用服务器来处理的，所以只好查了些服务器的知识。因为Mac自带Apache，所以为了省事就直接学习了下就拿来用了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;启用Apache&quot;&gt;&lt;a href=&quot;#启用Apache&quot; class=&quot;headerlink&quot; title=&quot;启用Apache&quot;&gt;&lt;/a&gt;启用Apache&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;开启apache命令：sudo apachectl start&lt;/li&gt;
&lt;li&gt;关闭apache命令：sudo apachectl stop&lt;/li&gt;
&lt;li&gt;重启apache命令：sudo apachectl restart&lt;/li&gt;
&lt;li&gt;开启apache后，可以直接在浏览器中访问 localhost, 如果出现“It works”，表示运行正常。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;具体使用：&quot;&gt;&lt;a href=&quot;#具体使用：&quot; class=&quot;headerlink&quot; title=&quot;具体使用：&quot;&gt;&lt;/a&gt;具体使用：&lt;/h4&gt;&lt;p&gt;目标：在浏览器中打开localhost，显示自定义的web页面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Mac的Finder中，利用前往文件夹，进入路径&lt;code&gt;/Library/WebServer/Documents&lt;/code&gt;，这是默认的根路径，里面有三个文件：index.html.en, PoweredByMacOSX.gif, PoweredByMacOSXLarge.gif。这三个文件不用管，放在那里就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用Coda，或者eclipse创建一个html文件，内容自己定义就行。然后将这个html文件名字改为index.html, 只能是这个名字，除非你利用vim更改Apache的httpd.conf文件，重新配置首页文件名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将创建的index.html文件保存到 &lt;code&gt;/Library/WebServer/Documents&lt;/code&gt;下。因为这是个私有文件夹，是需要root权限的，所有每次更改这个文件夹都是需要输入Mac密码的，除非Mac没有设定密码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，浏览器中打开localhost,就可以看到自定义的html。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当然，也可以利用Xcode创建一个工程，利用UIWebView进行验证。只需要将 localhost 换成 Mac当前连接的网络的IP就行, URL最好是：&lt;a href=&quot;http://192.168.1.103，&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.1.103，&lt;/a&gt; 也可以是：&lt;a href=&quot;http://localhost。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost。&lt;/a&gt;  具体可看以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIWebView *web = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [web setScalesPageToFit:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:web];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&amp;quot;http://192.168.1.103&amp;quot;]]];	// 192.168.1.103 换成你的ip地址就行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来是要搞HLS(苹果的视频直播处理技术)的，而且已经将mp4文件分割成m3u8类型直播文件，最后要验证m3u8文件的时候，却发现是要利用服务器来处理的，所以只好查了些服务器的知识。因为Mac自带Apache，所以为了省事就直接学习了下就拿来用了。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="http://yoursite.com/2016/05/03/Cookie/"/>
    <id>http://yoursite.com/2016/05/03/Cookie/</id>
    <published>2016-05-03T08:15:58.000Z</published>
    <updated>2016-05-03T08:27:05.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;许多网站登录了一次之后，下次就不需要再次登录。这种操作很常见，然而网页与程序的逻辑是完全的不同，也就是说网页并不像程序那样拥有自己的存储路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web端基本都是使用HTTP/HTTPS协议传输数据的。这种协议是无状态的协议。也就是说一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪上次的状态。&lt;br&gt;所以为了解决以上问题，W3C组织提出了Cookie(甜饼)。&lt;/p&gt;
&lt;p&gt;由于HTTP是一种无状态的协议，服务器单从网络连接上是无法知道客户身份。那如何解决呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理&lt;/p&gt;
&lt;p&gt;Cookie本质上是&lt;code&gt;一小段的文本信息&lt;/code&gt;，当客户端请求服务器的时候，如果服务器需要记录客户端状态，就会向客户端颁发一个Cookie。客户端会把Cookie保存起来，当客户端再次请求的时候，把网址以及保存下来的Cookie一同提交服务器，这样服务器就可以辨认用户的状态。&lt;/p&gt;
&lt;h4 id=&quot;iOS中网络请求中的Cookie&quot;&gt;&lt;a href=&quot;#iOS中网络请求中的Cookie&quot; class=&quot;headerlink&quot; title=&quot;iOS中网络请求中的Cookie&quot;&gt;&lt;/a&gt;iOS中网络请求中的Cookie&lt;/h4&gt;&lt;p&gt;iOS中的网络请求对于Cookie的支持是非常强大的，当你访问一个网站的时候，NSURLRequest都会帮你记录访问站点的Cookie，而且当你下次访问这个网站的时候，NSURLRequest会带着上次保存下来的Cookie继续请求。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 请求一个网址，即可分配到cookie&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; request: &lt;span class=&quot;type&quot;&gt;NSMutableURLRequest&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;NSMutableURLRequest&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;URL&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;NSURL&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(string: &lt;span class=&quot;string&quot;&gt;&quot;http://www.tongxingpay.com&quot;&lt;/span&gt;)!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sessionConfig: &lt;span class=&quot;type&quot;&gt;NSURLSessionConfiguration&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;NSURLSessionConfiguration&lt;/span&gt;.defaultSessionConfiguration()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; session: &lt;span class=&quot;type&quot;&gt;NSURLSession&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;NSURLSession&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(configuration: sessionConfig)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; task: &lt;span class=&quot;type&quot;&gt;NSURLSessionDataTask&lt;/span&gt; = session.dataTaskWithRequest(request) &amp;#123; (data, response, error) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 打印 cookie&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;NSHTTPCookieStorage&lt;/span&gt;.sharedHTTPCookieStorage().cookies)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      task.resume()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;许多网站登录了一次之后，下次就不需要再次登录。这种操作很常见，然而网页与程序的逻辑是完全的不同，也就是说网页并不像程序那样拥有自己的存储路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web端基本都是使用HTTP/HTTPS协议传输数据的。这种协
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typora</title>
    <link href="http://yoursite.com/2016/04/29/Typora/"/>
    <id>http://yoursite.com/2016/04/29/Typora/</id>
    <published>2016-04-29T05:17:56.000Z</published>
    <updated>2016-04-29T05:42:54.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.typora.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Typora&lt;/a&gt;是一款非常方便的Markdown文档编辑器，相对于Mou来说，它的强大之处在于它的及时渲染, 将【写字】与【预览】这两件事情合并了。What You See Is What You Get.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h4&gt;&lt;p&gt;添加表格，只需Command+T即可。表格里面的文本对齐方式类似于office一样方便设置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标题一&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;标题二&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;标题三&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;左对齐&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;居中&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;右对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h4&gt;&lt;p&gt;Typora 里代码和数学公式的输入，也做得一样出色。当插入代码区域时，你可以先选择代码的种类，Typora 基本支持了所有主流的代码高亮（C#、PHP、Java 等等），连 Swift 也不在例外。而数学公式更加，Typora 甚至连 Latex 都支持了。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; custom: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;友谊的小船说翻就翻&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;照片&quot;&gt;&lt;a href=&quot;#照片&quot; class=&quot;headerlink&quot; title=&quot;照片&quot;&gt;&lt;/a&gt;照片&lt;/h4&gt;&lt;p&gt;对于图片可以直接进行拖拽，方便快捷。下面这个就是一张图片。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/zzTyporazhaopian.png&quot; alt=&quot;Typorazhaopian&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.typora.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Typora&lt;/a&gt;是一款非常方便的Markdown文档编辑器，相对于Mou来说，它的强大之处在于它的及时渲染, 将【写字】
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift代码片段：颜色值</title>
    <link href="http://yoursite.com/2016/04/28/Swift%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%80%BC/"/>
    <id>http://yoursite.com/2016/04/28/Swift代码片段：颜色值/</id>
    <published>2016-04-28T03:36:40.000Z</published>
    <updated>2016-04-28T03:48:30.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;利用延展，为UIColor添加颜色值的初始化方法，遍历构造器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;extension UIColor {
        // 三色值
      convenience init(red: Int, green: Int, blue: Int) {
        assert(red &amp;gt;= 0 &amp;amp;&amp;amp; red &amp;lt;= 255, &amp;quot;Invalid red component&amp;quot;)
        assert(green &amp;gt;= 0 &amp;amp;&amp;amp; green &amp;lt;= 255, &amp;quot;Invalid green component&amp;quot;)
        assert(blue &amp;gt;= 0 &amp;amp;&amp;amp; blue &amp;lt;= 255, &amp;quot;Invalid blue component&amp;quot;)
        self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: 1.0)
      }

      // 颜色值  0x6fd66b
      convenience init(netHex:Int) {
        self.init(red:(netHex &amp;gt;&amp;gt; 16) &amp;amp; 0xff, green:(netHex &amp;gt;&amp;gt; 8) &amp;amp; 0xff, blue:netHex &amp;amp; 0xff)
      }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用延展，为UIColor添加颜色值的初始化方法，遍历构造器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;extension UIColor {
        // 三色值
      convenience init(red: 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift代码片段：GCD创建单例</title>
    <link href="http://yoursite.com/2016/04/28/Swift%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%EF%BC%9A%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2016/04/28/Swift代码片段：单例/</id>
    <published>2016-04-28T03:14:32.000Z</published>
    <updated>2016-04-28T03:19:27.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Swift中利用GCD创建单例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;class var sharedInstance: QRMakeVC {
    struct Static {
        static var onceToken: dispatch_once_t = 0
        static var instance: QRMakeVC? = nil
    }
    dispatch_once(&amp;amp;Static.onceToken) {
        Static.instance = QRMakeVC()
    }
    return Static.instance!
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swift中利用GCD创建单例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;class var sharedInstance: QRMakeVC {
    struct Static {
        static var onc
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MQTT应用内消息推送</title>
    <link href="http://yoursite.com/2016/04/11/MQTT%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2016/04/11/MQTT消息推送/</id>
    <published>2016-04-11T06:35:30.000Z</published>
    <updated>2016-04-28T03:49:38.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;因为需求，需要从服务器获取支付结果的通知，而后台已经在POS和安卓端使用MTQQ,没办法iOS端消息推送也只能用MTQQ，查询了一些资料发现MTQQ好像要比信鸽、极光的应用内消息更加简单点，至少iOS端少去了推送证书的配置等一些繁琐的流程。MQTT本质上就是一个TCP长连接而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jmesnil/MQTTKit.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTTKit&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/cerastes/article/details/36904893?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO_1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/MTQQ-.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO_2&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化MQTT&quot;&gt;&lt;a href=&quot;#初始化MQTT&quot; class=&quot;headerlink&quot; title=&quot;初始化MQTT&quot;&gt;&lt;/a&gt;初始化MQTT&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 获取设备uuid
if Keychain.load(&amp;quot;kUUID&amp;quot;) == nil {
        let uuidRef: CFUUIDRef = CFUUIDCreate(kCFAllocatorDefault)
        Keychain.save(&amp;quot;kUUID&amp;quot;, data: CFUUIDCreateString(kCFAllocatorDefault, uuidRef))
}
let uuid: String = Keychain.load(&amp;quot;kUUID&amp;quot;) as! String

// clientId:用来区分接受消息的设备，此处我用的是设备的UUID,并保存在了钥匙串里，确保唯一性。
mqtt = MQTTSession.init(clientId: uuid, userName: &amp;quot;name&amp;quot;, password: &amp;quot;psw&amp;quot;)
mqtt?.connectToHost(&amp;quot;111.111.111.111&amp;quot;, port: 1111)
mqtt?.setDelegate(self)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;消息回调&quot;&gt;&lt;a href=&quot;#消息回调&quot; class=&quot;headerlink&quot; title=&quot;消息回调&quot;&gt;&lt;/a&gt;消息回调&lt;/h3&gt;&lt;h4 id=&quot;链接状态回调&quot;&gt;&lt;a href=&quot;#链接状态回调&quot; class=&quot;headerlink&quot; title=&quot;链接状态回调&quot;&gt;&lt;/a&gt;链接状态回调&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;   // 链接状态回调
   override func session(session: MQTTSession!, handleEvent eventCode: MQTTSessionEvent) {

    switch eventCode {
    case MQTTSessionEventConnected:
        print(&amp;quot;消息推送: connected&amp;quot;)
        // 链接成功后，订阅主题
        self.mqtt?.subscribeTopic(&amp;quot;TX_APP_PAY&amp;quot;)
    case MQTTSessionEventConnectionRefused:
        print(&amp;quot;消息推送: connection refused&amp;quot;)
    case MQTTSessionEventConnectionClosed:
        print(&amp;quot;消息推送: connection closed&amp;quot;)
    case MQTTSessionEventConnectionError:
        print(&amp;quot;消息推送: connection error&amp;quot;)
        print(&amp;quot;         reconnecting...&amp;quot;)

        // 链接错误的话，尝试重新链接
        self.mqtt?.connectToHost(&amp;quot;111.111.111.111&amp;quot;, port: 1111)
    case MQTTSessionEventProtocolError:
        print(&amp;quot;消息推送: protocol error&amp;quot;)
    default:
        break
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;接收到消息回调&quot;&gt;&lt;a href=&quot;#接收到消息回调&quot; class=&quot;headerlink&quot; title=&quot;接收到消息回调&quot;&gt;&lt;/a&gt;接收到消息回调&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;    // 接收到消息回调
    override func session(session: MQTTSession!, newMessage data: NSData!, onTopic topic: String!) {

    var dic = NSDictionary()
    do {
        dic =
            try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers) as! NSDictionary
    } catch {

    }
    print(&amp;quot;推送内容：&amp;quot;, dic)
    print(&amp;quot;推送主题：&amp;quot;, topic)
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为需求，需要从服务器获取支付结果的通知，而后台已经在POS和安卓端使用MTQQ,没办法iOS端消息推送也只能用MTQQ，查询了一些资料发现MTQQ好像要比信鸽、极光的应用内消息更加简单点，至少iOS端少去了推送证书的配置等一些繁琐的流程。MQTT
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCD_API_Main/Global_Dispatch_Queue</title>
    <link href="http://yoursite.com/2016/04/04/GCD-API-Main-Global-Dispatch-Queue/"/>
    <id>http://yoursite.com/2016/04/04/GCD-API-Main-Global-Dispatch-Queue/</id>
    <published>2016-04-04T03:21:17.000Z</published>
    <updated>2016-04-04T04:17:01.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;获取系统标准提供的Dispatch Queue: Main Dispatch Queue 和 Global Dispatch Queue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Main-Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Main-Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Main Dispatch Queue&quot;&gt;&lt;/a&gt;Main Dispatch Queue&lt;/h3&gt;&lt;p&gt;Main Dispatch Queue 正如其名称中含有的‘main’一样，是在主线程中执行Dispatch Queue。因为主线程只有一个，所以Main Dispatch Queue 自然就是 &lt;code&gt;Serial Dispatch Queue&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;追加到 Main Dispatch Queue 的处理在主线程的&lt;code&gt;RunLoop&lt;/code&gt;中执行。由于在主线程中执行，因此要将用户界面的界面更新等一些必须在主线程中执行的处理追加到 Main Dispatch Queue 使用。&lt;/p&gt;
&lt;h3 id=&quot;Global-Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Global-Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Global Dispatch Queue&quot;&gt;&lt;/a&gt;Global Dispatch Queue&lt;/h3&gt;&lt;p&gt;Global Dispatch Queue 是所有的应用程序都能够使用的 &lt;code&gt;Concurrent Dispatch Queue&lt;/code&gt;。 没有必要通过 dispatch_queue_create 函数逐个生成 Concurrent Dispatch Queue。 只要获取 Global Dispatch Queue 使用就行。&lt;/p&gt;
&lt;h3 id=&quot;获取方法&quot;&gt;&lt;a href=&quot;#获取方法&quot; class=&quot;headerlink&quot; title=&quot;获取方法&quot;&gt;&lt;/a&gt;获取方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 获取 Main Dispatch Queue
let mainDispatchQueue: dispatch_queue_t = dispatch_get_main_queue()

// 获取 Global Dispatch Queue(高优先级)
let globalDispatchQueueHigh: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)

// 获取 Global Dispatch Queue(默认优先级)
let globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

// 获取 Global Dispatch Queue(低优先级)
let globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)

// 获取 Global Dispatch Queue(后台优先级)
let globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;常用例子&quot;&gt;&lt;a href=&quot;#常用例子&quot; class=&quot;headerlink&quot; title=&quot;常用例子&quot;&gt;&lt;/a&gt;常用例子&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 在默认优先级 Global Dispatch Queue 中执行 Block
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { 

    // 可以并行执行的处理（如： 图片下载）

    // 在 Main Dispatch Queue 中执行的 Block
    dispatch_async(dispatch_get_main_queue(), { 

        // 只能在主线程中执行的处理（如：将缓存在本地的图片呈现在界面中）

    })
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;获取系统标准提供的Dispatch Queue: Main Dispatch Queue 和 Global Dispatch Queue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Main-Dispatch-Queue&quot;&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCD_API_DispatchQueue</title>
    <link href="http://yoursite.com/2016/03/31/CGD-API-DispatchQueue/"/>
    <id>http://yoursite.com/2016/03/31/CGD-API-DispatchQueue/</id>
    <published>2016-03-31T10:35:06.000Z</published>
    <updated>2016-04-04T03:58:05.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Dispatch Queue 和 Dispatch_queue_create 的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Queue&quot;&gt;&lt;/a&gt;Dispatch Queue&lt;/h3&gt;&lt;p&gt;Dispatch Queue,字面意思就是执行处理的等待队列。将想要执行的任务，通过dispatch_async函数“追加”赋值在变量queue的“Dispatch Queue”中。放在dispatch_async函数的block里面的任务就可以在另个一线程中执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dispatch_async(queue) { 
        // 想要执行的任务
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dispatch Queue 按照追加的顺序（先进先出FIFO）执行处理。&lt;/p&gt;
&lt;p&gt;Dispatch Queue 分为两种：Serial Dispatch Queue 和 Concurrent Dispatch Queue。&lt;/p&gt;
&lt;h4 id=&quot;Serial-Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Serial-Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Serial Dispatch Queue&quot;&gt;&lt;/a&gt;Serial Dispatch Queue&lt;/h4&gt;&lt;p&gt;Serial Dispatch Queue 等待处理结束。简单的理解，比方说，Dispatch Queue中有多个任务，那么这几个任务只能使用同一个线程，按照这几个任务添加的顺序，逐个处理。&lt;/p&gt;
&lt;p&gt;优点：可以有效的避免数据多线程产生的数据竞争问题。因为一个Serial Dispatch Queue只能有一个线程。当然，如果你创建3000个这样的queue,就又会绕到多线程消耗大量内存的问题上来，会大幅度降低系统的响应性能。过犹不及。因此，Serial Dispatch Queue的生成个数应当仅限所必须的数量。&lt;/p&gt;
&lt;h4 id=&quot;Concurrent-Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Concurrent-Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;Concurrent Dispatch Queue&quot;&gt;&lt;/a&gt;Concurrent Dispatch Queue&lt;/h4&gt;&lt;p&gt;Concurrent Dispatch Queue 不等待处理。当在这种Dispatch Queue中有多个任务时，会有多个线程来处理这些任务。比方说，有3个线程A、B、C, 5个先后添加的任务a.b.c.d.e, 那么线程A就会处理任务a, 同时B处理b, C处理c; 如果线程B优先其他线程把任务处理完了，那么线程B就会去处理任务d; 下一个空余出来的线程就会去处理任务e, 直至任务都处理完成。&lt;/p&gt;
&lt;h3 id=&quot;Dispatch-queue-create&quot;&gt;&lt;a href=&quot;#Dispatch-queue-create&quot; class=&quot;headerlink&quot; title=&quot;Dispatch_queue_create&quot;&gt;&lt;/a&gt;Dispatch_queue_create&lt;/h3&gt;&lt;p&gt;创建一个Dispatch_queue时会使用用到函数Dispatch_queue_create。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个Serial Dispatch Queue
    let mySerialQueue: dispatch_queue_t = dispatch_queue_create(&amp;quot;com.SerialDispatchQueue&amp;quot;, nil)

// 创建一个Concurrent Dispatch Queue
    let myConcurrentQueue: dispatch_queue_t = dispatch_queue_create(&amp;quot;com.SerialDispatchQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是创建这两种dispatch_queue的方法，区别在于第二个参数的设定，第一个参数是dispatch_queue的署名。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于 Dispatch Queue 和 Dispatch_queue_create 的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Dispatch-Queue&quot;&gt;&lt;a href=&quot;#Dispatch-Queue&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCD</title>
    <link href="http://yoursite.com/2016/03/30/GCD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/30/GCD学习笔记/</id>
    <published>2016-03-30T13:06:18.000Z</published>
    <updated>2016-03-31T11:23:18.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;时间总是匆匆而过，上篇学习笔记还在月初，这篇就已经到月末了，感觉对自己太溺爱了。还是看看书，写点笔记，督促自己不断学习吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是GCD&quot;&gt;&lt;a href=&quot;#什么是GCD&quot; class=&quot;headerlink&quot; title=&quot;什么是GCD&quot;&gt;&lt;/a&gt;什么是GCD&lt;/h3&gt;&lt;p&gt;Grand Central Dispath(GCD),就是异步执行任务的一种技术。简单地说就是GCD提供了极为简单的方法，实现了极为复杂繁琐的多线程编程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 自定义一个线程
let queue: dispatch_queue_t = dispatch_queue_create(&amp;quot;myqueue&amp;quot;, nil)

// 耗时的任务放到后台处理
dispatch_async(queue) {
    var num = Int()
    for i in 1...900 {
        num += i
    }

    // 在主线程中打印求和结果
    dispatch_async(dispatch_get_main_queue(), { 
        print(num)
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上就是一个很简单地GCD应用，开辟新的线程用来处理耗时的任务，在主线程中处理必要操作，比如UI的展示，网络请求结果的处理等。&lt;/p&gt;
&lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h3&gt;&lt;p&gt;多线程说白了，就像工厂里面的流水线，每条流水线都有各自的任务，流水线之间原则上没有太大的相关性。&lt;/p&gt;
&lt;p&gt;使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，看上去就像一个CPU核能够并列的执行多个线程一样。当然，多个CPU核的情况下，是真的提供了多个CPU核并列执行多个线程的技术。&lt;/p&gt;
&lt;h4 id=&quot;多线程的优点：&quot;&gt;&lt;a href=&quot;#多线程的优点：&quot; class=&quot;headerlink&quot; title=&quot;多线程的优点：&quot;&gt;&lt;/a&gt;多线程的优点：&lt;/h4&gt;&lt;p&gt;1、数据竞争（多个线程更新相同的资源会导致数据的不一致）；&lt;br&gt;2、死锁(停止等待事件的线程会导致多个线程相互持续等待)；&lt;br&gt;3、使用太多线程会消耗大量内存等。 &lt;/p&gt;
&lt;h4 id=&quot;多线程的优点：-1&quot;&gt;&lt;a href=&quot;#多线程的优点：-1&quot; class=&quot;headerlink&quot; title=&quot;多线程的优点：&quot;&gt;&lt;/a&gt;多线程的优点：&lt;/h4&gt;&lt;p&gt;使用多线程编程，在执行长时间的处理是仍可保证用户界面的响应性能。比如：程序启动的时候，最先执行的是主线程，用来描绘用户界面、处理触摸屏幕的事件等；而其他耗时操作，如数据请求、图片下载等则是开辟新的线程进行处理。这样可以避免妨碍主线程中NSRunLoop的执行，从而保证用户界面的响应性能。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间总是匆匆而过，上篇学习笔记还在月初，这篇就已经到月末了，感觉对自己太溺爱了。还是看看书，写点笔记，督促自己不断学习吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是GCD&quot;&gt;&lt;a href=&quot;#什么是GCD&quot; class=&quot;hea
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>URL中特殊字符的转义</title>
    <link href="http://yoursite.com/2016/03/30/URL%E4%B8%AD%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/03/30/URL中特殊字符的处理/</id>
    <published>2016-03-30T03:40:38.000Z</published>
    <updated>2016-03-30T03:20:57.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在做RSA签名和加密的过程中，由于RSA生成的字段中含有 + ,需要进行转义，思路很简单，但总有坑要跳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title=&quot;解决思路&quot;&gt;&lt;/a&gt;解决思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 对URL进行转义
- (NSString *)formatURLwithText:(NSString *)text {
    return (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)text, NULL, (CFStringRef)@&amp;quot;!*’();:@&amp;amp;=+$,/?%#[]&amp;quot;, kCFStringEncodingUTF8));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码是就是最近本的处理方法，关键在用的时机。&lt;/p&gt;
&lt;p&gt;生成sign值：通常的做法是对所有参数按key排序，然后拼接成a=x&amp;amp;b=y…这样的字符串，然后RSA一下。但是如果encode一下，iOS端和安卓端出现不同的结果，那么服务端拿到以后是可以得到原串的，但是服务端encode一下所得到的结果会不一样，那么校验sign就会失败。&lt;/p&gt;
&lt;p&gt;但是，如果不对每个value进行转码，在服务端就无法通过&amp;amp;来分割了，因为value中有&amp;amp;时，若不转码就会出问题，因此encode是必须的。&lt;/p&gt;
&lt;p&gt;解决方法：生成sign时，是遍历所有的key-value，然后拼接，最后RSA。那么，生成sign时，我们只要不对value进行encode，而其他上传的参数值都encode，这样就可以解决我们的问题了。&lt;/p&gt;
&lt;p&gt;注意点：转义之后的URL不可再用encode；例如，value里面含有中文字段，正常情况下是要进行中文编码的，如果调用转义的方法后，就不需要在进行中文编码的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在做RSA签名和加密的过程中，由于RSA生成的字段中含有 + ,需要进行转义，思路很简单，但总有坑要跳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高阶函数：map、flatMap、forEach、filter、reduce</title>
    <link href="http://yoursite.com/2016/03/15/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9Amap%E3%80%81flatMap%E3%80%81forEach%E3%80%81filter%E3%80%81reduce/"/>
    <id>http://yoursite.com/2016/03/15/高阶函数：map、flatMap、forEach、filter、reduce/</id>
    <published>2016-03-15T03:40:38.000Z</published>
    <updated>2016-03-15T07:08:33.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;高阶函数：函数作为参数或者函数作为返回值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的写法：&quot;&gt;&lt;a href=&quot;#函数的写法：&quot; class=&quot;headerlink&quot; title=&quot;函数的写法：&quot;&gt;&lt;/a&gt;函数的写法：&lt;/h3&gt;&lt;h4 id=&quot;1-正常写法&quot;&gt;&lt;a href=&quot;#1-正常写法&quot; class=&quot;headerlink&quot; title=&quot;1.正常写法&quot;&gt;&lt;/a&gt;1.正常写法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;let res = numbers.sort({$0 &amp;lt; $1})
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-Trailing-Closure&quot;&gt;&lt;a href=&quot;#2-Trailing-Closure&quot; class=&quot;headerlink&quot; title=&quot;2.Trailing Closure&quot;&gt;&lt;/a&gt;2.Trailing Closure&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;let ree = numbers.sort{$0 &amp;lt; $1}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;常用实例&quot;&gt;&lt;a href=&quot;#常用实例&quot; class=&quot;headerlink&quot; title=&quot;常用实例&quot;&gt;&lt;/a&gt;常用实例&lt;/h3&gt;&lt;h4 id=&quot;map函数：&quot;&gt;&lt;a href=&quot;#map函数：&quot; class=&quot;headerlink&quot; title=&quot;map函数：&quot;&gt;&lt;/a&gt;map函数：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;map函数：当数组调用map函数时，闭包作为它的参数，闭包实现对数组单个元素进行某种规则的处理，最终map函数返回一个原数组元素被闭包处理过的新的数组（新的数组元素个数和原先的相等，数组类型可自定义，如数组类型由[Int],变为[String] 或者 [Bool]等）。

let arr = [1, 2, 9, 4, 5]
// 写法一：推荐写法
let mrr1 = arr.map {
    &amp;quot;step.&amp;quot; + String($0)
}
// 写法二：
let mrr2 = arr.map { (a: Int) -&amp;gt; String in
    &amp;quot;step.&amp;quot; + String(a)
}
// 写法三：
let mrr3 = arr.map ({ (a: Int) -&amp;gt; String in
    &amp;quot;step.&amp;quot; + String(a)
})
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;flatMap函数：&quot;&gt;&lt;a href=&quot;#flatMap函数：&quot; class=&quot;headerlink&quot; title=&quot;flatMap函数：&quot;&gt;&lt;/a&gt;flatMap函数：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;flatMap函数：功能和map函数基本相同，不同之处在于，flatMap生成的数组自动去除nil。

// 1、去除nil
let frr = [&amp;quot;af&amp;quot;, &amp;quot;vf&amp;quot;, &amp;quot;&amp;quot;]
let frr1 = frr.flatMap { (a: String) -&amp;gt; Int? in
    if a.characters.count == 0 {
            return nil
    } else {
        return a.characters.count
    }
}   // [2,2]

// 2、对嵌套数组的拆分合并
let fmp = [[2, 6, 4], [5, 3, 7]]
let fmp1 = fmp.flatMap { (a: [Int]) -&amp;gt; [Int] in
    a
}   // [2, 6, 4, 5, 3, 7]

let fmp2 = fmp.map { (a: [Int]) -&amp;gt; [Int] in
    a
}   // [[2, 6, 4], [5, 3, 7]]

// 3、对不同类型数组的合并
let c = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
let i = [1, 2]
let fmp3 = i.flatMap { car in
    c.map { num in
        num + &amp;quot;\(car)&amp;quot;
    }
}   // [&amp;quot;a1&amp;quot;, &amp;quot;b1&amp;quot;, &amp;quot;c1&amp;quot;, &amp;quot;a2&amp;quot;, &amp;quot;b2&amp;quot;, &amp;quot;c2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;filter函数：&quot;&gt;&lt;a href=&quot;#filter函数：&quot; class=&quot;headerlink&quot; title=&quot;filter函数：&quot;&gt;&lt;/a&gt;filter函数：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;let err = arr.filter { (a: Int) -&amp;gt; Bool in
    a % 2 == 0
}   // [2, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;forEach函数：&quot;&gt;&lt;a href=&quot;#forEach函数：&quot; class=&quot;headerlink&quot; title=&quot;forEach函数：&quot;&gt;&lt;/a&gt;forEach函数：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;arr.forEach { (a: Int) -&amp;gt; () in
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;reduce函数：&quot;&gt;&lt;a href=&quot;#reduce函数：&quot; class=&quot;headerlink&quot; title=&quot;reduce函数：&quot;&gt;&lt;/a&gt;reduce函数：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;reduce函数：把数组元素合并成一个新的值, 新值类型不固定。有两个参数，第一个参数是返回值的初始值；第二个参数是一个处理数组元素的函数。

// 返回Int
let crr = arr.reduce(0) { (prevSum: Int, elemen: Int) in
    return prevSum + elemen

}
// 返回String
let crr2 = arr.reduce(&amp;quot;&amp;quot;) {
      &amp;quot;\($0)&amp;quot; + &amp;quot;\($1)&amp;quot;
}

// 实现map和filter
extension Array {
    func mMap&amp;lt;U&amp;gt; (transform: Element -&amp;gt; U) -&amp;gt; [U] {
    return reduce([], combine: { $0 + [transform($1)] })
    }
    func mFilter (includeElement: Element -&amp;gt; Bool) -&amp;gt; [Element] {
        return reduce([]) { includeElement($1) ? $0 + [$1] : $0 }
    }
}

// 利用 reduce 实现 map
let ass = arr.reduce([]) { (a: [Int], element: Int) -&amp;gt;[Int] in
    var t = Array(a)
    t.append(element * 2)
    return t
}

// 利用 reduce 方法一次求出数组中奇数的和、以及偶数乘积
let sss:(Int, Int) = arr.reduce((0, 1)) {
    (a: (Int, Int), element: Int) -&amp;gt; (Int, Int) in
    if element % 2 == 0 {
        return (a.0, a.1 * element)
    } else {
        return (a.0 + element, a.1)
    }
}

// 利用 reduce 方法一次求出数组中偶数的平方和
let kkk = arr.filter {
        $0 % 2 == 0
    }.map {
        $0 * $0
    }.reduce(0){
        $0 + $1
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高阶函数：函数作为参数或者函数作为返回值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的写法：&quot;&gt;&lt;a href=&quot;#函数的写法：&quot; class=&quot;headerlink&quot; title=&quot;函数的写法：&quot;&gt;&lt;/a&gt;函数的写法：&lt;/h3&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NSURLSession_Swift</title>
    <link href="http://yoursite.com/2016/03/09/NSURLSession-Swift/"/>
    <id>http://yoursite.com/2016/03/09/NSURLSession-Swift/</id>
    <published>2016-03-09T06:46:51.000Z</published>
    <updated>2016-03-15T07:12:35.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;一个简单地Swift语言的网络请求封装，包括数据请求、数据上传、图片下载、图片上传。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/NSURLSession_Swift.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据请求&quot;&gt;&lt;a href=&quot;#数据请求&quot; class=&quot;headerlink&quot; title=&quot;数据请求&quot;&gt;&lt;/a&gt;数据请求&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/**
 数据请求

 - parameter urlStr:  请求地址
 - parameter reponse: 请求结果
 */
func get(urlStr: String, reponse: (result: AnyObject, response: NSURLResponse)-&amp;gt;Void)-&amp;gt;Void  {

    if urlStr.isEmpty {
        print(&amp;quot;Request address cannot be empty&amp;quot;)
        return
    }
    let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
    let url: NSURL = NSURL.init(string: strEncode)!
    let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url)

    let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
    let task: NSURLSessionDataTask = session.dataTaskWithRequest(request) { (data, resp, err) -&amp;gt; Void in
        if (err != nil) {
            print(&amp;quot;Data request failed: \(err?.code)&amp;quot;)
            return
        }
        do {
            let json =
            try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.MutableContainers)
            reponse(result: json, response: resp!)

        } catch {
        }
    }
    task.resume()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;数据下载&quot;&gt;&lt;a href=&quot;#数据下载&quot; class=&quot;headerlink&quot; title=&quot;数据下载&quot;&gt;&lt;/a&gt;数据下载&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/**
 数据下载

 - parameter urlStr:  请求地址
 - parameter reponse: 数据本地保存地址
 */
func downLoad(urlStr: String, reponse:(location: String)-&amp;gt;Void)-&amp;gt;Void {
    if urlStr.isEmpty {
        print(&amp;quot;Request address cannot be empty&amp;quot;)
        return
    }
    let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
    let url: NSURL = NSURL.init(string: strEncode)!
    let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url)
    let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
    let downLoadTask: NSURLSessionDownloadTask = session.downloadTaskWithRequest(request) { (location, resp, err) -&amp;gt; Void in
        if (err != nil) {
            print(&amp;quot;DownLoadData request failed: \(err?.code)&amp;quot;)
            return
        }
        let caches: String = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true).last!

        let file: String = caches.stringByAppendingString(&amp;quot;/\(resp!.suggestedFilename!)&amp;quot;)

        if NSFileManager.defaultManager().fileExistsAtPath(file) {
            if NSThread.isMainThread() {
                reponse(location: file)
            } else {
                dispatch_async(dispatch_get_main_queue(), { () -&amp;gt; Void in
                    reponse(location: file)
                })
            }
        } else {
            do {
                try NSFileManager.defaultManager().moveItemAtPath(location!.path!, toPath: file)
                if NSThread.isMainThread() {
                    reponse(location: file)
                } else {
                    dispatch_async(dispatch_get_main_queue(), { () -&amp;gt; Void in
                        reponse(location: file)
                    })
                }
            } catch {

            }
        }
    }
    downLoadTask.resume()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;JSON数据上传&quot;&gt;&lt;a href=&quot;#JSON数据上传&quot; class=&quot;headerlink&quot; title=&quot;JSON数据上传&quot;&gt;&lt;/a&gt;JSON数据上传&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/**
 普通数据上传

 - parameter urlStr:     上传地址
 - parameter uploadData: 字典数据
 - parameter reponse:    上传结果
 */
func upLoadData(urlStr: String, uploadData: AnyObject, reponse: (result: AnyObject, response: NSURLResponse)-&amp;gt;Void)-&amp;gt;Void {
    if urlStr.isEmpty {
        print(&amp;quot;Request address cannot be empty&amp;quot;)
        return
    }

    let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
    let url: NSURL = NSURL.init(string: strEncode)!
    let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url)

    request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
    request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Accept&amp;quot;)

    request.HTTPMethod = &amp;quot;POST&amp;quot;
    request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringCacheData
    request.timeoutInterval = 20
    do {
        let data: NSData =
        try NSJSONSerialization.dataWithJSONObject(uploadData, options: NSJSONWritingOptions.PrettyPrinted)
        let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
        let uploadTask: NSURLSessionUploadTask = session.uploadTaskWithRequest(request, fromData: data, completionHandler: { (result, resp, err) -&amp;gt; Void in
            if (err != nil) {
                print(&amp;quot;UpLoadData request failed: \(err?.code)&amp;quot;)
                return
            }

            do {
                let json: AnyObject =
                try NSJSONSerialization.JSONObjectWithData(result!, options: NSJSONReadingOptions.MutableContainers)
                reponse(result: json, response: resp!)
            } catch {

            }

        })
        uploadTask.resume()
    } catch {

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;图片上传&quot;&gt;&lt;a href=&quot;#图片上传&quot; class=&quot;headerlink&quot; title=&quot;图片上传&quot;&gt;&lt;/a&gt;图片上传&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; /**
 图片上传

 - parameter urlStr:     上传地址
 - parameter uploadData: 图片数据
 - parameter dataType:   图片类型
 - parameter reponse:    上传结果
 */
func upLoadImage(urlStr: String, image: UIImage, dataType: DataType, reponse: (result: String, response: NSURLResponse)-&amp;gt;Void)-&amp;gt;Void {
    if urlStr.isEmpty {
        print(&amp;quot;Request address cannot be empty&amp;quot;)
        return
    }

    let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
    let url: NSURL = NSURL.init(string: strEncode)!
    let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url)
    var daa = NSData()
    switch dataType {
    case .JPEG:
        request.addValue(&amp;quot;image/jpeg&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(&amp;quot;text/html&amp;quot;, forHTTPHeaderField: &amp;quot;Accept&amp;quot;)
        daa = UIImageJPEGRepresentation(image, 1)!
    case .PNG:
        request.addValue(&amp;quot;image/png&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(&amp;quot;text/html&amp;quot;, forHTTPHeaderField: &amp;quot;Accept&amp;quot;)
        daa = UIImagePNGRepresentation(image)!
    }

    request.HTTPMethod = &amp;quot;POST&amp;quot;
    request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringCacheData
    request.timeoutInterval = 20
    let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())

    let uploadTask: NSURLSessionUploadTask = session.uploadTaskWithRequest(request, fromData: daa, completionHandler: { (result, resp, err) -&amp;gt; Void in

        if (err != nil) {
            print(&amp;quot;UpLoadImage request failed: \(err?.code)&amp;quot;)
            return
        }
        let ss: String = String.init(data: result!, encoding: NSUTF8StringEncoding)!
        reponse(result: ss, response: resp!)
    })
    uploadTask.resume()
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个简单地Swift语言的网络请求封装，包括数据请求、数据上传、图片下载、图片上传。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/NSURLSession_Swift.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fabric-Crashlytics</title>
    <link href="http://yoursite.com/2016/03/03/Fabric-Crashlytics/"/>
    <id>http://yoursite.com/2016/03/03/Fabric-Crashlytics/</id>
    <published>2016-03-03T02:59:15.000Z</published>
    <updated>2016-03-15T07:12:13.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Fabric是Twitter公司提供的一款，应用于移动应用开发，统计应用崩溃信息的工具。操作简单，使用方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用介绍&quot;&gt;&lt;a href=&quot;#使用介绍&quot; class=&quot;headerlink&quot; title=&quot;使用介绍&quot;&gt;&lt;/a&gt;使用介绍&lt;/h3&gt;&lt;h4 id=&quot;申请账号&quot;&gt;&lt;a href=&quot;#申请账号&quot; class=&quot;headerlink&quot; title=&quot;申请账号&quot;&gt;&lt;/a&gt;申请账号&lt;/h4&gt;&lt;p&gt;Crashlytics的服务是免费提供的，但是并不能直接注册使用，需要先申请，打开 &lt;a href=&quot;http://try.crashlytics.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crashlytic的官网&lt;/a&gt; ，输入自己的邮箱申请使用。之后Fabric会发一封确认邮件，确认成功之后，还会发一封Welcome to Fabric的邮件，点击Get Started with Fabric，根据提示，现在安装Mac端的App，登陆并根据提示完成配置。&lt;/p&gt;
&lt;h4 id=&quot;设置工程&quot;&gt;&lt;a href=&quot;#设置工程&quot; class=&quot;headerlink&quot; title=&quot;设置工程&quot;&gt;&lt;/a&gt;设置工程&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1、点击&amp;quot;+ New App&amp;quot; 添加工程项目；
2、根据提示配置&amp;quot;Run Script&amp;quot;。打开工程-&amp;gt;Build Phases-&amp;gt;Editor-&amp;gt;Add Build Phase-&amp;gt;Add Run Script Build Phase, 然后将Fabric提供的代码粘贴到Shell下， 然后Command+B;
3、按照提示，将Fabric提供的frameworks(图标)拖到工程里，然后粘贴复制相关代码。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1、可以直接使用Fabric提供的强行Crash代码进行测试，也可以自己写个。
2、测试的时候需要脱离Xcode的调试环境。最简单的方法就是真机测试，但要注意的是，测试的时候手机和Xcode不要用数据线连接。测试之后，会收到Fabric的测试报告，出现Crash的具体位置，十分方便。
3、用户也可以在AppStore中下载Fabric,在手机端查看测试报告。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fabric是Twitter公司提供的一款，应用于移动应用开发，统计应用崩溃信息的工具。操作简单，使用方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用介绍&quot;&gt;&lt;a href=&quot;#使用介绍&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spotlight</title>
    <link href="http://yoursite.com/2016/02/29/Spotlight/"/>
    <id>http://yoursite.com/2016/02/29/Spotlight/</id>
    <published>2016-02-29T05:17:43.000Z</published>
    <updated>2016-03-15T07:12:00.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;iOS9推出的Core Spotlight(CS)框架，利用CS做应用内搜索。&lt;br&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/CoreSpotlight.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;导入MobileCoreServices.framework和CoreSpotligt.framework
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;主要代码&quot;&gt;&lt;a href=&quot;#主要代码&quot; class=&quot;headerlink&quot; title=&quot;主要代码&quot;&gt;&lt;/a&gt;主要代码&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;// 设置spotlight
- (void)setSpotligtht {
    self.searchItemArr = [NSMutableArray array];
    int i = 0;
    for (NSDictionary *dic in self.dataArr) {

        CSSearchableItemAttributeSet *searchItemSet = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:(NSString *)kUTTypeText];

        // 标题
        searchItemSet.title = [dic objectForKey:@&amp;quot;title&amp;quot;];

        // 描述
        searchItemSet.contentDescription = [dic objectForKey:@&amp;quot;desc&amp;quot;];
        NSArray *arr = [[dic objectForKey:@&amp;quot;picture&amp;quot;] componentsSeparatedByString:@&amp;quot;.&amp;quot;];

        // 设置照片路径
        searchItemSet.thumbnailURL = [[NSBundle mainBundle] URLForResource:arr[0] withExtension:arr[1]];

        // 搜索关键词 keywords(字符串形式) / contactKeywords(数组形式)
        searchItemSet.keywords = [dic objectForKey:@&amp;quot;title&amp;quot;];

        /*
         uniqueIdentifier：这个参数唯一地标识Spotlight当前搜索项。你可以用你喜欢的方式构造这个唯一标示符。
         domainIdentifier:使用这个参数对搜索项进行分组。
         attributeSet：它就是我们刚刚设置属性时的属性设置对象。
         */
        CSSearchableItem *searchItem = [[CSSearchableItem alloc] initWithUniqueIdentifier:[NSString stringWithFormat:@&amp;quot;com.spolight.%d&amp;quot;, i] domainIdentifier:@&amp;quot;books&amp;quot; attributeSet:searchItemSet];
        [self.searchItemArr addObject:searchItem];
        i++;
    }

    [[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:self.searchItemArr completionHandler:^(NSError * _Nullable error) {
        if (error) {
            NSLog(@&amp;quot;%@&amp;quot;, error.localizedDescription);
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS9推出的Core Spotlight(CS)框架，利用CS做应用内搜索。&lt;br&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/CoreSpotlight.git&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BLE_Central</title>
    <link href="http://yoursite.com/2016/02/26/BLE-Central/"/>
    <id>http://yoursite.com/2016/02/26/BLE-Central/</id>
    <published>2016-02-26T01:08:38.000Z</published>
    <updated>2016-03-15T07:10:27.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;iOS蓝牙开发，中心模式开发。&lt;a href=&quot;https://github.com/zhangzhaopds/BLE_Central.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;相关DEMO&lt;/a&gt;    &lt;a href=&quot;https://github.com/zhangzhaopds/BluetoothStubOnOSX.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模拟外设&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;iOS链接外设的代码实现流程&quot;&gt;&lt;a href=&quot;#iOS链接外设的代码实现流程&quot; class=&quot;headerlink&quot; title=&quot;iOS链接外设的代码实现流程&quot;&gt;&lt;/a&gt;iOS链接外设的代码实现流程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 建立中心角色
2. 扫描外设（discover）
3. 连接外设(connect)
4. 扫描外设中的服务和特征(discover)
    - 4.1 获取外设的services
    - 4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值
5. 与外设做数据交互(explore and interact)
6. 订阅Characteristic的通知
7. 断开连接(disconnect)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h3&gt;&lt;h4 id=&quot;1-初始化-init&quot;&gt;&lt;a href=&quot;#1-初始化-init&quot; class=&quot;headerlink&quot; title=&quot;1.初始化(init)&quot;&gt;&lt;/a&gt;1.初始化(init)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;#import &amp;lt;CoreBluetooth/CoreBluetooth.h&amp;gt;

@interface ViewController ()&amp;lt;CBCentralManagerDelegate&amp;gt;

@property (nonatomic, strong) manager *centralManager;

@property (nonatomic, strong) CBPeripheral *peripheral;

// CBCentralManagerOptionShowPowerAlertKey的作用是，当设备蓝牙未打开时打开
NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES], CBCentralManagerOptionShowPowerAlertKey, nil];

// 初始化并设置委托和线程队列，默认main线程
self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue() options:options];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-扫描外设-discover&quot;&gt;&lt;a href=&quot;#2-扫描外设-discover&quot; class=&quot;headerlink&quot; title=&quot;2.扫描外设(discover)&quot;&gt;&lt;/a&gt;2.扫描外设(discover)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;-(void)centralManagerDidUpdateState:(CBCentralManager *)central{

        switch (central.state) {
            case CBCentralManagerStateUnknown:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStateUnknown&amp;quot;);
                break;
            case CBCentralManagerStateResetting:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStateResetting&amp;quot;);
                break;
            case CBCentralManagerStateUnsupported:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStateUnsupported&amp;quot;);
                break;
            case CBCentralManagerStateUnauthorized:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStateUnauthorized&amp;quot;);
                break;
            case CBCentralManagerStatePoweredOff:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStatePoweredOff&amp;quot;);
                break;
            case CBCentralManagerStatePoweredOn:
                NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;CBCentralManagerStatePoweredOn&amp;quot;);
                //开始扫描周围的外设
                /*
                 第一个参数nil就是扫描周围所有的外设，扫描到外设后会进入
                      - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI;
                 */
                [manager scanForPeripheralsWithServices:nil options:nil];

                break;
            default:
                break;
        }

    }

    //扫描到设备会进入方法
    -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{

        NSLog(@&amp;quot;当扫描到设备:%@&amp;quot;,peripheral.name);
        //接下来可以连接设备

    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;3-链接外设-connect&quot;&gt;&lt;a href=&quot;#3-链接外设-connect&quot; class=&quot;headerlink&quot; title=&quot;3.链接外设(connect)&quot;&gt;&lt;/a&gt;3.链接外设(connect)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//扫描到设备会进入方法
 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{

//连接设备（注意：这里使用self.peripheral,而不是peripheral,是因为如果peripheral被释放掉，将不会实现连接到外设的回调方法，也就是下面三个方法将不执行）
     self.peripheral = peripheral;
     [manager connectPeripheral:self.peripheral options:nil]; 
 }

 //连接到Peripherals-成功
 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
     NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;连接到名称为（%@）的设备-成功&amp;quot;,peripheral.name);
 }

 //连接到Peripherals-失败
 -(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {
     NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;连接到名称为（%@）的设备-失败,原因:%@&amp;quot;,[peripheral name],[error localizedDescription]);
 }

 //Peripherals断开连接
 - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {
     NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;外设连接断开连接 %@: %@\n&amp;quot;, [peripheral name], [error localizedDescription]);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;4-获取外设的services&quot;&gt;&lt;a href=&quot;#4-获取外设的services&quot; class=&quot;headerlink&quot; title=&quot;4.获取外设的services&quot;&gt;&lt;/a&gt;4.获取外设的services&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//连接到Peripherals-成功
   - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
   {
       NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;连接到名称为（%@）的设备-成功&amp;quot;,peripheral.name);
       //设置的peripheral委托CBPeripheralDelegate
       //@interface ViewController : UIViewController&amp;lt;CBCentralManagerDelegate,CBPeripheralDelegate&amp;gt;
       [peripheral setDelegate:self];
       //扫描外设Services，成功后会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{
       [peripheral discoverServices:nil];

   }

   //扫描到Services
   -(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{
       //  NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;扫描到服务：%@&amp;quot;,peripheral.services);
       if (error)
       {
           NSLog(@&amp;quot;&amp;gt;&amp;gt;&amp;gt;Discovered services for %@ with error: %@&amp;quot;, peripheral.name, [error localizedDescription]);
           return;
       }

       for (CBService *service in peripheral.services) {
                        NSLog(@&amp;quot;%@&amp;quot;,service.UUID);
                        //扫描每个service的Characteristics，扫描到后会进入方法： -(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
                        [peripheral discoverCharacteristics:nil forService:service];
                    }

   }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;5-获取外设的Characteristics-Descriptor&quot;&gt;&lt;a href=&quot;#5-获取外设的Characteristics-Descriptor&quot; class=&quot;headerlink&quot; title=&quot;5.获取外设的Characteristics,Descriptor&quot;&gt;&lt;/a&gt;5.获取外设的Characteristics,Descriptor&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//扫描到Characteristics
 -(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{
     if (error)
     {
         NSLog(@&amp;quot;error Discovered characteristics for %@ with error: %@&amp;quot;, service.UUID, [error localizedDescription]);
         return;
     }

     for (CBCharacteristic *characteristic in service.characteristics)
     {
         NSLog(@&amp;quot;service:%@ 的 Characteristic: %@&amp;quot;,service.UUID,characteristic.UUID);
     }

     //获取Characteristic的值，读到数据会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
     for (CBCharacteristic *characteristic in service.characteristics){
         {
             [peripheral readValueForCharacteristic:characteristic];
         }
     }

     //搜索Characteristic的Descriptors，读到数据会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
     for (CBCharacteristic *characteristic in service.characteristics){
         [peripheral discoverDescriptorsForCharacteristic:characteristic];
     }


 }

//获取的charateristic的值
-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{
    //打印出characteristic的UUID和值
    //!注意，value的类型是NSData，具体开发时，会根据外设协议制定的方式去解析数据
    NSLog(@&amp;quot;characteristic uuid:%@  value:%@&amp;quot;,characteristic.UUID,characteristic.value);

}

//搜索到Characteristic的Descriptors
-(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{

    //打印出Characteristic和他的Descriptors
     NSLog(@&amp;quot;characteristic uuid:%@&amp;quot;,characteristic.UUID);
    for (CBDescriptor *d in characteristic.descriptors) {
        NSLog(@&amp;quot;Descriptor uuid:%@&amp;quot;,d.UUID);
    }

}
//获取到Descriptors的值
-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error{
    //打印出DescriptorsUUID 和value
    //这个descriptor都是对于characteristic的描述，一般都是字符串，所以这里我们转换成字符串去解析
    NSLog(@&amp;quot;characteristic uuid:%@  value:%@&amp;quot;,[NSString stringWithFormat:@&amp;quot;%@&amp;quot;,descriptor.UUID],descriptor.value);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;6-把数据写入到Characteristic中&quot;&gt;&lt;a href=&quot;#6-把数据写入到Characteristic中&quot; class=&quot;headerlink&quot; title=&quot;6.把数据写入到Characteristic中&quot;&gt;&lt;/a&gt;6.把数据写入到Characteristic中&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//写数据
-(void)writeCharacteristic:(CBPeripheral *)peripheral
            characteristic:(CBCharacteristic *)characteristic
                     value:(NSData *)value{

    //打印出 characteristic 的权限，可以看到有很多种，这是一个NS_OPTIONS，就是可以同时用于好几个值，常见的有read，write，notify，indicate，知知道这几个基本就够用了，前连个是读写权限，后两个都是通知，两种不同的通知方式。
    /*
     typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) {
     CBCharacteristicPropertyBroadcast                                                = 0x01,
     CBCharacteristicPropertyRead                                                    = 0x02,
     CBCharacteristicPropertyWriteWithoutResponse                                    = 0x04,
     CBCharacteristicPropertyWrite                                                    = 0x08,
     CBCharacteristicPropertyNotify                                                    = 0x10,
     CBCharacteristicPropertyIndicate                                                = 0x20,
     CBCharacteristicPropertyAuthenticatedSignedWrites                                = 0x40,
     CBCharacteristicPropertyExtendedProperties                                        = 0x80,
     CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0)        = 0x100,
     CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0)    = 0x200
     };

     */
    NSLog(@&amp;quot;%lu&amp;quot;, (unsigned long)characteristic.properties);


    //只有 characteristic.properties 有write的权限才可以写
    if(characteristic.properties &amp;amp; CBCharacteristicPropertyWrite){
        /*
            最好一个type参数可以为CBCharacteristicWriteWithResponse或type:CBCharacteristicWriteWithResponse,区别是是否会有反馈
        */
        [peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];
    }else{
        NSLog(@&amp;quot;该字段不可写！&amp;quot;);
    }


}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;7-订阅Characteristic的通知&quot;&gt;&lt;a href=&quot;#7-订阅Characteristic的通知&quot; class=&quot;headerlink&quot; title=&quot;7.订阅Characteristic的通知&quot;&gt;&lt;/a&gt;7.订阅Characteristic的通知&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//设置通知
-(void)notifyCharacteristic:(CBPeripheral *)peripheral
            characteristic:(CBCharacteristic *)characteristic{
    //设置通知，数据通知会进入：didUpdateValueForCharacteristic方法
    [peripheral setNotifyValue:YES forCharacteristic:characteristic];

}

//取消通知
-(void)cancelNotifyCharacteristic:(CBPeripheral *)peripheral
             characteristic:(CBCharacteristic *)characteristic{

     [peripheral setNotifyValue:NO forCharacteristic:characteristic];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;7-断开连接-disconnect&quot;&gt;&lt;a href=&quot;#7-断开连接-disconnect&quot; class=&quot;headerlink&quot; title=&quot;7.断开连接(disconnect)&quot;&gt;&lt;/a&gt;7.断开连接(disconnect)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//停止扫描并断开连接
-(void)disconnectPeripheral:(CBCentralManager *)centralManager
                 peripheral:(CBPeripheral *)peripheral{
    //停止扫描
    [centralManager stopScan];
    //断开连接
    [centralManager cancelPeripheralConnection:peripheral];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS蓝牙开发，中心模式开发。&lt;a href=&quot;https://github.com/zhangzhaopds/BLE_Central.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;相关DEMO&lt;/a&gt;    &lt;a hre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Refresh-Swift</title>
    <link href="http://yoursite.com/2016/01/29/Refresh-Swift/"/>
    <id>http://yoursite.com/2016/01/29/Refresh-Swift/</id>
    <published>2016-01-29T08:23:29.000Z</published>
    <updated>2016-03-15T07:11:49.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Swift语言实现的数据刷新功能，类似于MJRefresh.(上拉加载，下拉刷新)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/Alamofire-Refresh.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文DEMO&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/BLOG_%E5%88%B7%E6%96%B0.png?imageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/BLOG_%E5%8A%A0%E8%BD%BD.png?imageView2/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swift语言实现的数据刷新功能，类似于MJRefresh.(上拉加载，下拉刷新)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/Alamofire-Refresh.gi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ActivityIndicator-Swift</title>
    <link href="http://yoursite.com/2016/01/28/ActivityIndicator-Swift/"/>
    <id>http://yoursite.com/2016/01/28/ActivityIndicator-Swift/</id>
    <published>2016-01-28T06:14:58.000Z</published>
    <updated>2016-03-15T07:11:21.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/Blogactivity.png?imageView2/2/h/500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swift实现简单的活动指示器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/Indicator..git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文DEMO链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要代码展示&quot;&gt;&lt;a href=&quot;#主要代码展示&quot; class=&quot;headerlink&quot; title=&quot;主要代码展示&quot;&gt;&lt;/a&gt;主要代码展示&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1.创建活动指示器单例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class var shareIndicator: HTTPIndicator {
    struct Static {
        static var onceToken: dispatch_once_t = 0
        static var instance: HTTPIndicator?
    }
    dispatch_once(&amp;amp;Static.onceToken, {() -&amp;gt; Void in
        Static.instance = HTTPIndicator()
    })
    return Static.instance!
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;2.设置活动指示器界面的大小（全屏显示、部分显现）&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum IndicatorSizeModel {
    case Landscape      // 全屏
    case FullScreen        // 非全屏
}

// 重写sizeModel的set方法
var sizeModel: IndicatorSizeModel = .Landscape {
    didSet {
        switch sizeModel {
        case .Landscape:
            self.frame = CGRectMake(0, 64, kScreenWidth, kScreenHeight - 64)
            maskWindow!.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
            indicatorImageView.transform = CGAffineTransformIdentity
            loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)

        case .FullScreen:
            self.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            maskWindow?.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2)
            loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2)
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;3.创建活动指示器图片，由两部分组成&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 中间部分
lazy var indicatorImageView: UIImageView = {
    let imageView = UIImageView(frame: CGRectMake(0, 0, 60 * kScreenWidthFactor, 60 * kScreenWidthFactor))
    imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
    imageView.image = UIImage(named: &amp;quot;Indicator&amp;quot;)
    imageView.contentMode = UIViewContentMode.ScaleToFill
    return imageView
}()

// 外部转圈部分
lazy var loopImageView: UIImageView = {
   let imageView = UIImageView(frame: CGRectMake(0, 0, 80 * kScreenWidthFactor, 80 * kScreenWidthFactor))
    imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
    imageView.image = UIImage(named: &amp;quot;loopIndicator&amp;quot;)
    imageView.contentMode = UIViewContentMode.ScaleToFill
    return imageView
}()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;4.创建window对象，用来承载指示器&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lazy var maskWindow : UIWindow? = {
    let window = UIWindow(frame: CGRectMake(0, 0, kScreenWidth, kScreenHeight))
    window.windowLevel = UIWindowLevelNormal
    return window
}()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;5.指示器的显现&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class func show() {
    shareIndicator.maskWindow?.makeKeyAndVisible()
    shareIndicator.maskWindow?.addSubview(shareIndicator)
    shareIndicator.beginAnimation()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;6.指示器的取消&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为新建了window对象来承载指示器，所以，当取消指示器的时候，一定要将新建的window移除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class func dismiss() {
    shareIndicator.endAnimationWithCompletion { () -&amp;gt; Void in
        shareIndicator.maskWindow?.resignKeyWindow()
        shareIndicator.removeFromSuperview()

        let originalWindow = UIApplication.sharedApplication().delegate?.window
        originalWindow!?.makeKeyAndVisible()

        shareIndicator.resetBounds()
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xoz39.com1.z0.glb.clouddn.com/Blogactivity.png?imageView2/2/h/500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swift实现简单的活动指示器。&lt;/p&gt;
&lt;/b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZXingObjC</title>
    <link href="http://yoursite.com/2015/12/30/ZXingObjC%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2015/12/30/ZXingObjC二维码/</id>
    <published>2015-12-30T06:53:05.000Z</published>
    <updated>2016-03-15T07:12:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近在做一个支付类的APP, 涉及到二维码的使用，上网查一些资料，发现网上的资料都N年之前了。也找到了一些大神的demo,但却是各种封装，一眼看不到重点，几经周折，才搞出来。本文是一个最简单的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/-.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本文DEMO链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/TheLevelUp/ZXingObjC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ZXingObjC链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-基本应用&quot;&gt;&lt;a href=&quot;#1-基本应用&quot; class=&quot;headerlink&quot; title=&quot;1.基本应用&quot;&gt;&lt;/a&gt;1.基本应用&lt;/h2&gt;&lt;h3 id=&quot;二维码扫描&quot;&gt;&lt;a href=&quot;#二维码扫描&quot; class=&quot;headerlink&quot; title=&quot;二维码扫描&quot;&gt;&lt;/a&gt;二维码扫描&lt;/h3&gt;&lt;h4 id=&quot;cocoaPods导入ZXingObjC&quot;&gt;&lt;a href=&quot;#cocoaPods导入ZXingObjC&quot; class=&quot;headerlink&quot; title=&quot;cocoaPods导入ZXingObjC&quot;&gt;&lt;/a&gt;&lt;code&gt;cocoaPods导入ZXingObjC&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;pod &amp;apos;ZXingObjC&amp;apos;, &amp;apos;~&amp;gt; 3.1.0&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;导入头文件&quot;&gt;&lt;a href=&quot;#导入头文件&quot; class=&quot;headerlink&quot; title=&quot;导入头文件&quot;&gt;&lt;/a&gt;&lt;code&gt;导入头文件&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;#import &amp;lt;ZXingObjC.h&amp;gt;

@interface ViewController () &amp;lt;ZXCaptureDelegate&amp;gt; //协议

@property (nonatomic, strong) ZXCapture *capture; 
@property (nonatomic, assign) BOOL isScan; //标记扫描状态

@end    
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;初始化摄像头&quot;&gt;&lt;a href=&quot;#初始化摄像头&quot; class=&quot;headerlink&quot; title=&quot;初始化摄像头&quot;&gt;&lt;/a&gt;&lt;code&gt;初始化摄像头&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)creatCapture {

self.isScan = NO; 

self.capture = [[ZXCapture alloc] init];

self.capture.camera = self.capture.back; //后置摄像头

self.capture.focusMode = AVCaptureFocusModeAutoFocus; //自动对焦

self.capture.rotation = 90.0f;

self.capture.layer.frame = CGRectMake(50, 60, self.view.frame.size.width - 100, 150);

[self.view.layer addSublayer:self.capture.layer];

self.capture.delegate = self; //协议的签订，用于对扫描结果进行处理
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;扫描结果的处理&quot;&gt;&lt;a href=&quot;#扫描结果的处理&quot; class=&quot;headerlink&quot; title=&quot;扫描结果的处理&quot;&gt;&lt;/a&gt;&lt;code&gt;扫描结果的处理&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)captureResult:(ZXCapture *)capture result:(ZXResult *)result {
if (!result || self.isScan == YES ){
    return;
}
self.isScan = YES;
[self.capture stop];

//震动提示（可不加）
AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);

//result就是扫描获取的结果，处理text属性外，还有其他的属性，如条码的类型等。
NSLog(@&amp;quot;%@&amp;quot;,[NSString stringWithFormat:@&amp;quot;%@&amp;quot;, result.text]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二维码的生成&quot;&gt;&lt;a href=&quot;#二维码的生成&quot; class=&quot;headerlink&quot; title=&quot;二维码的生成&quot;&gt;&lt;/a&gt;二维码的生成&lt;/h3&gt;&lt;h4 id=&quot;简单的几行代码&quot;&gt;&lt;a href=&quot;#简单的几行代码&quot; class=&quot;headerlink&quot; title=&quot;简单的几行代码&quot;&gt;&lt;/a&gt;&lt;code&gt;简单的几行代码&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ZXBitMatrix *rusult = [writer encode:@&amp;quot;这里就是要用来生成二维码的文字&amp;quot; format:kBarcodeFormatQRCode width:200 height:200 error:&amp;amp;error];

CGImageRef image = [[ZXImage imageWithMatrix:rusult] cgimage];

// img就是生成的二维码图片
UIImage *img = [UIImage imageWithCGImage:image];
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;2-自定义扫描视图&quot;&gt;&lt;a href=&quot;#2-自定义扫描视图&quot; class=&quot;headerlink&quot; title=&quot;2.自定义扫描视图&quot;&gt;&lt;/a&gt;2.自定义扫描视图&lt;/h2&gt;&lt;p&gt;代码就不一一粘贴了，主要的几个部分看一些，具体看&lt;a href=&quot;https://github.com/zhangzhaopds/-.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;上下扫描的动画效果&quot;&gt;&lt;a href=&quot;#上下扫描的动画效果&quot; class=&quot;headerlink&quot; title=&quot;上下扫描的动画效果&quot;&gt;&lt;/a&gt;上下扫描的动画效果&lt;/h3&gt;&lt;h4 id=&quot;初始化一个扫描线视图&quot;&gt;&lt;a href=&quot;#初始化一个扫描线视图&quot; class=&quot;headerlink&quot; title=&quot;初始化一个扫描线视图&quot;&gt;&lt;/a&gt;&lt;code&gt;初始化一个扫描线视图&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)initQRLine {

self.qrLine  = [[UIImageView alloc] initWithFrame:CGRectMake(self.bounds.size.width / 2 - self.transparentArea.width / 2, self.bounds.size.height / 2 - self.transparentArea.height / 2, self.transparentArea.width, 2)];

//self.qrLine的照片让美工做个好看点的，demo中的是一个截屏图片
self.qrLine.image = [UIImage imageNamed:@&amp;quot;22&amp;quot;];

self.qrLine.contentMode = UIViewContentModeScaleAspectFill;

[self addSubview:self.qrLine];

self.qrLineY = self.qrLine.frame.origin.y;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;h4 id=&quot;扫描线上下循环移动效果&quot;&gt;&lt;a href=&quot;#扫描线上下循环移动效果&quot; class=&quot;headerlink&quot; title=&quot;扫描线上下循环移动效果&quot;&gt;&lt;/a&gt;&lt;code&gt;扫描线上下循环移动效果&lt;/code&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;添加一个计时器
 NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:kQrLineanimateDuration target:self selector:@selector(show) userInfo:nil repeats:YES];

 //实现计时器中的方法，使扫描线上下移动
 - (void)show {

[UIView animateWithDuration:kQrLineanimateDuration animations:^{

    CGRect rect = self.qrLine.frame;
    rect.origin.y = self.qrLineY;
    self.qrLine.frame = rect;

} completion:^(BOOL finished) {

    CGFloat maxBorder = self.frame.size.height / 2 + self.transparentArea.height / 2 - 4;
    if (self.qrLineY &amp;gt; maxBorder) {

        self.qrLineY = self.frame.size.height / 2 - self.transparentArea.height /2;
    }
    self.qrLineY++;
}];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;扫描区域的四个角&quot;&gt;&lt;a href=&quot;#扫描区域的四个角&quot; class=&quot;headerlink&quot; title=&quot;扫描区域的四个角&quot;&gt;&lt;/a&gt;扫描区域的四个角&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)addCornerLineWithContext:(CGContextRef)ctx rect:(CGRect)rect{

//画四个边角
CGContextSetLineWidth(ctx, 2);
CGContextSetRGBStrokeColor(ctx, 83 /255.0, 239/255.0, 111/255.0, 1);//绿色

//左上角
CGPoint poinsTopLeftA[] = {
    CGPointMake(rect.origin.x + 0.7, rect.origin.y),
    CGPointMake(rect.origin.x + 0.7 , rect.origin.y + 15)
};

CGPoint poinsTopLeftB[] = {CGPointMake(rect.origin.x, rect.origin.y + 0.7),CGPointMake(rect.origin.x + 15, rect.origin.y + 0.7)};
[self addLine:poinsTopLeftA pointB:poinsTopLeftB ctx:ctx];

//左下角
CGPoint poinsBottomLeftA[] = {CGPointMake(rect.origin.x + 0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x + 0.7,rect.origin.y + rect.size.height)};
CGPoint poinsBottomLeftB[] = {CGPointMake(rect.origin.x , rect.origin.y + rect.size.height - 0.7) ,CGPointMake(rect.origin.x + 0.7 + 15, rect.origin.y + rect.size.height - 0.7)};
[self addLine:poinsBottomLeftA pointB:poinsBottomLeftB ctx:ctx];

//右上角
CGPoint poinsTopRightA[] = {CGPointMake(rect.origin.x + rect.size.width - 15, rect.origin.y + 0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + 0.7 )};
CGPoint poinsTopRightB[] = {CGPointMake(rect.origin.x + rect.size.width-0.7, rect.origin.y),CGPointMake(rect.origin.x + rect.size.width - 0.7, rect.origin.y + 15 + 0.7 )};
[self addLine:poinsTopRightA pointB:poinsTopRightB ctx:ctx];

CGPoint poinsBottomRightA[] = {CGPointMake(rect.origin.x + rect.size.width -0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x - 0.7 + rect.size.width, rect.origin.y + rect.size.height )};
CGPoint poinsBottomRightB[] = {CGPointMake(rect.origin.x + rect.size.width - 15 , rect.origin.y + rect.size.height-0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + rect.size.height - 0.7)};
[self addLine:poinsBottomRightA pointB:poinsBottomRightB ctx:ctx];
CGContextStrokePath(ctx);


- (void)addLine:(CGPoint[])pointA pointB:(CGPoint[])pointB ctx:(CGContextRef)ctx {
CGContextAddLines(ctx, pointA, 2);
CGContextAddLines(ctx, pointB, 2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做一个支付类的APP, 涉及到二维码的使用，上网查一些资料，发现网上的资料都N年之前了。也找到了一些大神的demo,但却是各种封装，一眼看不到重点，几经周折，才搞出来。本文是一个最简单的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UITextView</title>
    <link href="http://yoursite.com/2015/08/09/UITextView/"/>
    <id>http://yoursite.com/2015/08/09/UITextView/</id>
    <published>2015-08-09T13:41:24.000Z</published>
    <updated>2016-03-15T07:10:12.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;   UITextView的三种应用效果：&lt;br&gt;        1.链接地址在应用程序内跳转&lt;br&gt;        2.占位符（类似于UITextField的占位符效果）&lt;br&gt;        3.改变选中文本的属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;链接地址在应用程序内跳转&quot;&gt;&lt;a href=&quot;#链接地址在应用程序内跳转&quot; class=&quot;headerlink&quot; title=&quot;链接地址在应用程序内跳转&quot;&gt;&lt;/a&gt;链接地址在应用程序内跳转&lt;/h2&gt;&lt;h3 id=&quot;核心API&quot;&gt;&lt;a href=&quot;#核心API&quot; class=&quot;headerlink&quot; title=&quot;核心API&quot;&gt;&lt;/a&gt;核心API&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/UITextView.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class: UITextView

/** UITextView的编辑状态, 默认YES. */
@property(nonatomic, getter=isEditable) BOOL editable

@property(nonatomic) UIDataDetectorTypes dataDetectorTypes

/** 字典内存储链接文本的属性. */
@property(nonatomic, copy) NSDictionary *linkTextAttributes

/** 询问代理人, 是否可以跳转到指定的链接地址. */
- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;功能实现&quot;&gt;&lt;a href=&quot;#功能实现&quot; class=&quot;headerlink&quot; title=&quot;功能实现&quot;&gt;&lt;/a&gt;功能实现&lt;/h3&gt;&lt;p&gt;我们在UITextView里面点击链接地址时, 它是跳到浏览器里面的. 如果我们不想跳到浏览器, 想在自己的程序内部跳转显示, 该怎么做呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;思路
UITextView有一个代理方法是用来链接跳转动作是否执行的. 返回值是BOOL类型, 默认是YES. 
* 当我们返回NO时, 它就不会跳转了. 
* 在这个代理方法内, 我们执行其他的操作, 让链接地址的内容在程序内显示.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;WebViewController.h&amp;quot;

/** 签订协议 */
@interface ViewController ()&amp;lt;UITextViewDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    [self layoutTextView];

    /** 这个属性是UIViewController的属性, 当有Navicontroller的时候, 会自动向下调整UIScrollView及其子类的坐标位置, 默认为YES, 开启状态. */
    /** 如果为YES, TextView里的内容会自动向下移动位置. 可以自己测试一下. */
    self.automaticallyAdjustsScrollViewInsets = NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;- (void)layoutTextView {

/** 第一种链接界面: 地址链接. */

/** 创建UITextView的对象. 在这里我们并不需要textContainer, 设置成nil即可. */
UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(30, 100, 300, 150) textContainer:nil];

textView.text = @&amp;quot;http://blog.csdn.net/sponge_cmz?viewmode=contents&amp;quot;;
textView.font = [UIFont systemFontOfSize:20];
textView.layer.borderColor = [UIColor blackColor].CGColor;
textView.layer.borderWidth = 1;

/** 设置代理人, 我们要实现的效果, 需要用到代理方法. 在上面签订UITextViewDelegate协议. */
textView.delegate = self;

/** 链接地址能够跳转, textView的编辑状态必须为NO, 否则与普通文本无异. */
textView.editable = NO;

/** 设置自动检测类型为链接网址. */
textView.dataDetectorTypes = UIDataDetectorTypeLink;

/** 设置链接文字的属性. */
textView.linkTextAttributes = @{NSForegroundColorAttributeName: [UIColor orangeColor]};

[self.view addSubview:textView];

/** 第二种连接界面: 文字链接 */
UITextView *otherTextView = [[UITextView alloc] initWithFrame:CGRectMake(30, 350, 300, 150) textContainer:nil];

/** font属性是设置text的字体, 但是它对attributedText的字体不起作用. */
//    otherTextView.font = [UIFont systemFontOfSize:20];

otherTextView.layer.borderColor = [UIColor blackColor].CGColor;
otherTextView.layer.borderWidth = 1;
otherTextView.delegate = self;
otherTextView.editable = NO;

/** 详细内容请见博文说明中提到的另外一篇博客. */
NSAttributedString *linkAttribute = [[NSAttributedString alloc] initWithString:@&amp;quot;百度&amp;quot; attributes:@{NSLinkAttributeName: [NSURL URLWithString:@&amp;quot;http://www.baidu.com&amp;quot;], NSFontAttributeName:[UIFont systemFontOfSize:25]}];

otherTextView.attributedText = linkAttribute;

[self.view addSubview:otherTextView];

}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/** 当点击链接时, 是否要跳转到浏览器. 默认返回YES. 想要实现在应用程序内部跳转, 只需要返回NO即可. */

- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange {

/** 跳转到WebViewController的WebView上. */

WebViewController *webContro = [[WebViewController alloc] init];

UIWebView *web = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];

/** URL参数就是我们点击的链接地址. */
[web loadRequest:[NSURLRequest requestWithURL:URL]];

web.scalesPageToFit = YES;
[webContro.view addSubview:web];

[self.navigationController pushViewController:webContro animated:YES];

/** 返回NO, 不跳转到浏览器. */
return NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;占位符（类似于UITextField的占位符效果）&quot;&gt;&lt;a href=&quot;#占位符（类似于UITextField的占位符效果）&quot; class=&quot;headerlink&quot; title=&quot;占位符（类似于UITextField的占位符效果）&quot;&gt;&lt;/a&gt;占位符（类似于UITextField的占位符效果）&lt;/h2&gt;&lt;h3 id=&quot;核心API-1&quot;&gt;&lt;a href=&quot;#核心API-1&quot; class=&quot;headerlink&quot; title=&quot;核心API&quot;&gt;&lt;/a&gt;核心API&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/UITextView3.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class: UITextView
/** 告诉代理人, 用户已经改变指定textView里面的text或者attributes. */
- (void)textViewDidChange:(UITextView *)textView
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;功能实现-1&quot;&gt;&lt;a href=&quot;#功能实现-1&quot; class=&quot;headerlink&quot; title=&quot;功能实现&quot;&gt;&lt;/a&gt;功能实现&lt;/h3&gt;&lt;p&gt;我们在使用UITextView的时候发现, UITextView没有像UITextField一样的占位符. 如果我们想要在UITextView里面实现占位符的效果, 该怎么办呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;思路:
我们想要实现和UITextField一样的占位符效果, 那么我们就先看看UITextField是怎么实现的.

.通过观察UITextField的图层, 我们发现, 占位符在一个单独的UILabel上.
.我们让UITextField处于编辑状态, 再来看图层, 会发现在占位符label的上面又多了两层视图.
.我们输入文字之后再看图层, 会发现占位符的lable没有了.
.由此, 我们可以推测, 这个占位符label, 再输入之后, 就被隐藏了.
.我们再来看UITextView的图层, 会发现它也有两个图层, 一个是UITextView, 一个是UITextContainerView. (还有两个滑条, 是UIImageView, 但是和我们实现的效果无关.)
.那我们也可以仿照UITextField, 把一个label放到UITextContainerView的下面, 输入时就隐藏.
.注: UITextView和UITextField 我是使用StoryBoard创建的, 所以在代码中没有创建的代码.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/** 签订协议. */
@interface ViewController ()&amp;lt;UITextViewDelegate&amp;gt;

@property (weak, nonatomic) IBOutlet UITextView *textView;
@property (nonatomic, strong) UILabel *label_Placeholder; /**&amp;lt; 用来显示占位符的label. */
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];

    _textView.layer.borderColor = [UIColor blackColor].CGColor;
    _textView.layer.borderWidth = 2;

    /** 签订代理人, 实现效果需要用到代理方法. */
    _textView.delegate = self;

    /** 创建占位符label. */
    self.label_Placeholder = [[UILabel alloc] initWithFrame:CGRectMake(5, 0, 200, 40)]; /**&amp;lt; 坐标要根据实际情况做出调整. */

    /** 使用属性文本. 详情请查看博文说明中提到的另一篇博客. */
    _label_Placeholder.attributedText = [[NSAttributedString alloc] initWithString:@&amp;quot;Hello World!&amp;quot; attributes:@{NSFontAttributeName: _textView.font, NSForegroundColorAttributeName: [UIColor grayColor]}];

    /** 我们之前说过了, textView上有UITextContainerView 和 两个UIImageView 子视图, 我们把label_Placeholder放到UITextContainerView的下面, 也就是textView的第一个子视图. */
    [_textView insertSubview:_label_Placeholder atIndex:0];

    /** 可以打印textView的子视图看一下. */
    NSLog(@&amp;quot;%@&amp;quot;, [_textView subviews]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/** 当textView里面的内容发生改变时, 调用这个代理方法. */
- (void)textViewDidChange:(UITextView *)textView{
/** 判断条件是多次尝试的结果. 大家按照自己的想法, 尝试着写判断条件, 会更加理解为什么这么写了! */
if (_textView.text.length != 0 &amp;amp;&amp;amp; _label_Placeholder.hidden == NO) {

    _label_Placeholder.hidden = YES;

} else if (_textView.text.length == 0) {

    _label_Placeholder.hidden = NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;改变选中文本的属性&quot;&gt;&lt;a href=&quot;#改变选中文本的属性&quot; class=&quot;headerlink&quot; title=&quot;改变选中文本的属性&quot;&gt;&lt;/a&gt;改变选中文本的属性&lt;/h2&gt;&lt;h3 id=&quot;核心API-2&quot;&gt;&lt;a href=&quot;#核心API-2&quot; class=&quot;headerlink&quot; title=&quot;核心API&quot;&gt;&lt;/a&gt;核心API&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhangzhaopds/UITextView--.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DEMO链接&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class : UITextViews

/** 用户输入新的文本属性时, 会被存储在这个字典属性里. */
@property(nonatomic, copy) NSDictionary *typingAttributes

/** */
@property(nonatomic, readonly, retain) NSTextStorage *textStorage

/** 被选中的范围. */
@property(nonatomic) NSRange selectedRange
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;功能实现-2&quot;&gt;&lt;a href=&quot;#功能实现-2&quot; class=&quot;headerlink&quot; title=&quot;功能实现&quot;&gt;&lt;/a&gt;功能实现&lt;/h3&gt;&lt;p&gt;我们在看小说或文档时, 可以对一些重点内容进行标注, 例如, 加下划线, 改变颜色之类的. 那么UITextView里的内容, 我们是如何进行标注的呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;思路

首先获取到被选中的文本, 之后改变这段文本的属性设置.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@interface ViewController ()

@property (weak, nonatomic) IBOutlet UITextView *textView;

@property (nonatomic, strong) NSDictionary *oldAttributes; /** 用来接收textView文本的初始属性设置. */

@end
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];

/** 我们在textView的文本还未做出任何改变的时候, 将原始属性设置保存起来, 便于以后恢复. */

/** 
 * 初始化oldAttributes.
 * typingAttributes : 在用户没有输入新的文本属性时, 里面会有一些默认的文本属性.
 */
self.oldAttributes = [NSDictionary dictionaryWithDictionary:[_textView typingAttributes]];

/** 打印看一下里面存储的内容. */
NSLog(@&amp;quot;old: %@&amp;quot;, _oldAttributes);

}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/**
 * textStorage : UITextView的属性, 是NSTextStorage类型.
 * NSTextStorage 继承于NSMutableAttributedString类, 所以可以使用父类的方法.
 * 
 * selectedRange : UITextView的属性, 是NSRange类型.
 * textView当前被选择的文本.
 */
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/** 改变字体的笔画宽度. */
- (IBAction)wordWeight:(UIButton *)sender {

    [_textView.textStorage addAttribute:NSStrokeWidthAttributeName value:@5 range:_textView.selectedRange];

}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/** 给选中的文本添加黄色背景, 以及下划线. */
- (IBAction)backgroundColor:(UIButton *)sender {

/** 
 * 上面使用的是addAttribute: value: rang: 的方法. 它只能添加一个属性.
 * 如果我们要同时添加多个属性, 我们需要使用addAttributes: rang: 方法.
 * 这个方法的第一个参数是一个字典, 可以在字典中存储多个属性.
 */

[_textView.textStorage addAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange];

/** 
 * 要注意 addAttributes 和 setAttributes 的区别: 
 * addAttributes 是添加属性, 不会将之前的属性移除掉, 它们是共同存在的.
 * setAttributes 是设置属性, 会将之前的属性替换掉, 之前的属性将不会存在.
 */

//  [_textView.textStorage setAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange];
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/** 恢复到原来的文本状态. */
- (IBAction)recoverAttribute:(UIButton *)sender {

/** 我们想要恢复之前的属性, 也就是说不再使用做出改变的属性, 所以在这里我使用的是setAttributes: rang: 方法.  */
[_textView.textStorage setAttributes:_oldAttributes range:_textView.selectedRange];

}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   UITextView的三种应用效果：&lt;br&gt;        1.链接地址在应用程序内跳转&lt;br&gt;        2.占位符（类似于UITextField的占位符效果）&lt;br&gt;        3.改变选中文本的属性&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
    
  </entry>
  
</feed>
