{"meta":{"title":"Jmsp's Tips","subtitle":null,"description":"Perseverance does pay off","author":"Mr Fox","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2016-11-18T02:06:34.000Z","updated":"2016-11-18T02:06:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA技术书籍","slug":"JAVA技术书籍","date":"2017-11-22T03:46:38.000Z","updated":"2017-11-22T06:03:22.881Z","comments":true,"path":"2017/11/22/JAVA技术书籍/","link":"","permalink":"http://yoursite.com/2017/11/22/JAVA技术书籍/","excerpt":"","text":"JAVA技术书籍收藏, 仅供学习 JavaEE开发的颠覆者 Spring Boot实战 完整版 SPRING实战 第4版 SPRING技术内幕：深入解析SPRING架构与设计原理 Spring Cloud与Docker微服务架构实战 Spring Boot实战 Spring Cloud微服务实战 SpringBoot揭秘 快速构建微服务体系 亿级流量网站架构核心技术 微服务架构与实践 ,王磊著 微服务设计(中文完整版) 看透springMvc源代码分析与实践 精通Spring+4.x++企业应用开发实战 阿里巴巴Java开发手册-终极版","categories":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/categories/书籍/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"}]},{"title":"合并支付宝和微信的收款二维码","slug":"合并支付宝和微信收款的二维码","date":"2017-11-21T05:45:15.000Z","updated":"2017-11-21T05:57:05.381Z","comments":true,"path":"2017/11/21/合并支付宝和微信收款的二维码/","link":"","permalink":"http://yoursite.com/2017/11/21/合并支付宝和微信收款的二维码/","excerpt":"","text":"支付宝、微信收款二维码合成一、网页应用地址：https://heyfox.herokuapp.com 上传个人的支付宝收款二维码和微信收款二维码，点击合成； 合成的二维码即为新的收款码，需手动保存到本地，收款时向客户展示； 客户使用支付宝或者微信扫描合成的二维码即可完成转账； 注： 客户如果使用支付宝扫码，则自动跳转至输入金额界面； 客户如果使用微信扫码，则需要在扫码后出现的界面里长按识别二维码，以跳转到输入金额界面。 二、【合并收款码】小程序(简版)：","categories":[{"name":"Python3","slug":"Python3","permalink":"http://yoursite.com/categories/Python3/"}],"tags":[{"name":"二维码","slug":"二维码","permalink":"http://yoursite.com/tags/二维码/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"支付宝","slug":"支付宝","permalink":"http://yoursite.com/tags/支付宝/"}]},{"title":" VR的形式查看iPhone本地相册中的全景照片 iWorld-VR","slug":"iWorld-VR","date":"2017-09-14T02:56:01.000Z","updated":"2017-11-21T05:43:29.661Z","comments":true,"path":"2017/09/14/iWorld-VR/","link":"","permalink":"http://yoursite.com/2017/09/14/iWorld-VR/","excerpt":"","text":"以VR的形式查看iPhone本地相册中的全景照片 Python3爬虫 + Django应用 + Heroku免费云 + Swift3 + GVR 1、用户下载app后，可以在app中预览、下载各种各样的高清平面图和全景照片； 2、用户也可以在本地相册中选择要预览的全景照片，在分享界面选择app提供的插件 ‘VR View’ 进行360°的图片预览。 安装地址：https://itunes.apple.com/cn/app/luye-daily-best-hd-stock-photos/id1269107960","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"VR","slug":"VR","permalink":"http://yoursite.com/tags/VR/"}]},{"title":"Django SMTPAuthenticationError","slug":"Django-SMTPAuthenticationError","date":"2017-07-29T01:58:38.000Z","updated":"2017-07-29T02:17:44.000Z","comments":true,"path":"2017/07/29/Django-SMTPAuthenticationError/","link":"","permalink":"http://yoursite.com/2017/07/29/Django-SMTPAuthenticationError/","excerpt":"","text":"在Django应用中，利用SMTP发送验证邮件，本地的环境完全没问题，但当将Django应用部署到Heroku上后，邮件发送失败，报SMTPAuthenticationError错误。解决这个问题发费时间较长，记录一下。 这个问题针对【 Gmail 】邮。 setting.py123456EMAIL_USE_TLS = TrueEMAIL_HOST = 'smtp.gmail.com'EMAIL_PORT = 587EMAIL_HOST_USER = 'jmspvu@gmail.com'EMAIL_HOST_PASSWORD = '*******'DEFAULT_FROM_EMAIL = 'jmspvu@gmail.com' views.py123456789101112try: sendEmail = EmailMessage(subject='用户注册', body=message, to=[loginName]) sendEmail.send(fail_silently=False) print(loginName) msg = &#123;\"isSuccess\": True, \"msg\": 'Verification code sent successfully'&#125; return HttpResponse(json.dumps(msg), content_type='application/json')except: # msg = &#123;\"isSuccess\": False, # \"msg\": 'Verification code sent failure'&#125; # return HttpResponse(json.dumps(msg), content_type='application/json') raise Exception 在Heroku上的报错SMTPAuthenticationError During handling of the above exception ((534, b&#39;5.7.14 Please log in via your web browser and\\n5.7.14 then try again.\\n5.7.14 Learn more at\\n5.7.14 https://support.google.com/mail/answer/78754 q15sm15913999qkl.26 - gsmtp&#39;)), another exception occurred: 解决方法（Gmail）1、检查账号、密码是否匹配; 2、开启gmail邮箱的不安全应用：https://myaccount.google.com/lesssecureapps 3、授权账号访问权限（我的就因为开启这个，浪费了那么多时间）https://accounts.google.com/DisplayUnlockCaptcha","categories":[{"name":"Python3","slug":"Python3","permalink":"http://yoursite.com/categories/Python3/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Heroku","slug":"Heroku","permalink":"http://yoursite.com/tags/Heroku/"},{"name":"SMTP","slug":"SMTP","permalink":"http://yoursite.com/tags/SMTP/"}]},{"title":"椭圆曲线加密ECC","slug":"椭圆曲线加密ECC","date":"2017-06-23T05:39:43.000Z","updated":"2017-06-23T06:24:10.000Z","comments":true,"path":"2017/06/23/椭圆曲线加密ECC/","link":"","permalink":"http://yoursite.com/2017/06/23/椭圆曲线加密ECC/","excerpt":"","text":"椭圆曲线加密是一种类似于RSA的非对称加密算法，具体介绍可以参考这篇文章http://www.itye.org/archives/3254， 写得很明白。 本文内容翻译自 https://github.com/ricmoo/GMEllipticCurveCrypto https://github.com/konstantinpavlikhin/Watchdog openssl生成指令https://github.com/konstantinpavlikhin/Watchdog 生成DSA密钥对1、生成DSA私钥 $ openssl dsaparam -genkey 2048 -noout -out DSAPrivateKey.pem 2、导出公钥 openssl dsa -in DSAPrivateKey.pem -pubout -outform PEM -out DSAPublicKey.pem 生成ECDSA密钥对1、查看支持的曲线类型，常用的如：secp521r1，secp128r1, secp192r1, secp256r1, secp384r1等 $ openssl ecparam -list_curves 2、生成ECDSA私钥 $ openssl ecparam -genkey -name secp521r1 -noout -out ECDSAPrivateKey.pem 3、从私钥中导出公钥 $ openssl ec -in ECDSAPrivateKey.pem -pubout -outform PEM -out ECDSAPublicKey.pem Objective-C中的ECC库https://github.com/ricmoo/GMEllipticCurveCrypto ECDSA允许通过私钥进行签名，然后通过公钥进行验签； ECDH是通过用户自己拥有的私钥和另一个用户的公钥来创建一个密钥，通过这个密钥在进行加密操作。 API创建一个ECC密钥对1GMEllipticCurveCrypto *crypto = [GMEllipticCurveCrypto generateKeyPairForCurve:&#10; GMEllipticCurveSecp192r1];&#10;NSLog(@&#34;Public Key: %@&#34;, crypto.publicKeyBase64);&#10;NSLog(@&#34;Private Key: %@&#34;, crypto.privateKeyBase64); 使用key可以是base64加密过的字符串，也可以是data类型 1crypto.publicKeyBase64 = @&#34;AtF8hCxh9h1zlExuOZutuw+tRzmk3zVdfA==&#34;;&#10;NSLog(@&#34;Public Key: base64=%@, rawBinary=%@&#34;, crypto.publicKeyBase64, crypto.publicKey);&#10;&#10;char bytes[] = &#123; 2, 209, 124, 132, 44, 97, 246, 29, 115, 148, 76, 110, 57, 155, 173, &#10; 187, 15, 173, 71, 57, 164, 223, 53, 93, 124 &#125;;&#10;crypto.publicKey = [NSData dataWithBytes:bytes length:25];&#10;NSLog(@&#34;Public Key: base64=%@, rawBinary=%@&#34;, crypto.publicKeyBase64, crypto.publicKey); 签名需要注意的是：签名的内容长度要和所选取的曲线类型一致。 用ECDSA签名的话，产生的签名是所选曲线的两倍。如：secp192k1类型的曲线，产生的签名的长度为384bit（48字节）。 还需要注意的是：因为有随机k的存在，所以每次产生的签名是不一样的。 1// The first 24 bytes of the SHA-256 hash for &#34;Hack the Planet!&#34;&#10;char bytes[] = &#123; 56, 164, 34, 250, 121, 21, 2, 18, 65, 4, 161, 90, 126, 145, 111, 204, &#10; 151, 65, 181, 4, 231, 177, 117, 154 &#125;;&#10;NSData *messageHash = [NSData dataWithBytes:bytes length:24];&#10; &#10;GMEllipticCurveCrypto *crypto = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;crypto.privateKeyBase64 = @&#34;ENxb+5pCLAGT88vGmE6XLQRH1e8i/0rz&#34;;&#10;NSData *signature = [crypto signatureForHash:messageHash];&#10;NSLog(@&#34;Signature: %@&#34;, signature); 验签1rypto = [GMEllipticCurveCrypto cryptoForCurve:GMEllipticCurveSecp192r1];&#10;crypto.publicKeyBase64 = @&#34;AtF8hCxh9h1zlExuOZutuw+tRzmk3zVdfA==&#34;;;&#10;BOOL valid = [crypto verifySignature:signature forHash:messageHash];&#10;NSLog(@&#34;Valid Signature: %@&#34;, (valid ? @&#34;YES&#34;: @&#34;NO&#34;)); 密钥的交换使用ECDH方式生成与选取的曲线类型相同长度的交换密钥，如，192bit的曲线产生的是192bit的密钥。 1NSString *alicePublicKey = @&#34;A9N+XWIjLCYAwa8Hb7T6Rohttqo91CF8HQ==&#34;;&#10;NSString *alicePrivateKey = @&#34;frs4puAKipcbevvwJb7l77xACgB/FyBv&#34;;&#10;&#10;NSString *bobPublicKey = @&#34;A35aoteno4wnAdJgV8AXKKl1AfPVRrSZQA==&#34;;&#10;NSString *bobPrivateKey = @&#34;LP83qv81MsXVyPOFV7V5jKVOoU4DKPUS&#34;;&#10;&#10;&#10;// Alice performs...&#10;GMEllipticCurveCrypto *alice = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;alice.privateKeyBase64 = alicePrivateKey;&#10;NSData *aliceSharedSecret = [alice sharedSecretForPublicKeyBase64:bobPublicKey];&#10;NSLog(@&#34;Shared Secret Alice: %@&#34;, aliceSharedSecret);&#10;&#10;// Bob performs...&#10;GMEllipticCurveCrypto *bob = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;bob.privateKeyBase64 = bobPrivateKey;&#10;NSData *bobSharedSecret = [bob sharedSecretForPublicKeyBase64:alicePublicKey];&#10;NSLog(@&#34;Shared Secret Bob: %@&#34;, bobSharedSecret);&#10;&#10;// And now both parties have the same secret!&#10;NSLog(@&#34;Shared secrets equal? %d&#34;, [aliceSharedSecret isEqualToData:bobSharedSecret]); 部分原文Elliptic Curve CryptoAn Objective-C library for Elliptic Curve Digital Signing Algorithm (ECDSA) and for Elliptic Curve Diffie-Hellman (ECDH). ECDSA allows signatures to be generated using a private key and validated using a public key. ECDH allows two identities to use their own private keys and each other’s public key to generate a shared secret, which can then be used for encryption. This library is largely based on the easy-ecc library (https://github.com/kmackay/easy-ecc). Features Supports: secp128r1, secp192r1, secp256r1, secp384r1 Automatically detects curve based on private or public key Supports keys as raw bytes or as base64 encoded strings BSD 2-clause license APIGenerate a new ECC key pair1GMEllipticCurveCrypto *crypto = [GMEllipticCurveCrypto generateKeyPairForCurve:&#10; GMEllipticCurveSecp192r1];&#10;NSLog(@&#34;Public Key: %@&#34;, crypto.publicKeyBase64);&#10;NSLog(@&#34;Private Key: %@&#34;, crypto.privateKeyBase64); Using keysKeys can be accessed and set interchangably in either raw bytes or as base64 encoded strings. 1crypto.publicKeyBase64 = @&#34;AtF8hCxh9h1zlExuOZutuw+tRzmk3zVdfA==&#34;;&#10;NSLog(@&#34;Public Key: base64=%@, rawBinary=%@&#34;, crypto.publicKeyBase64, crypto.publicKey);&#10;&#10;char bytes[] = &#123; 2, 209, 124, 132, 44, 97, 246, 29, 115, 148, 76, 110, 57, 155, 173, &#10; 187, 15, 173, 71, 57, 164, 223, 53, 93, 124 &#125;;&#10;crypto.publicKey = [NSData dataWithBytes:bytes length:25];&#10;NSLog(@&#34;Public Key: base64=%@, rawBinary=%@&#34;, crypto.publicKeyBase64, crypto.publicKey); Generate a signature for a messageThe signing operations require a message the same length as the curve; so generally, a hash algorithm is used to fix the original message’s length. Signatures using ECDSA will be twice the curve size. So, the 192 bit curve will produce a signature that is 48 bytes (384 bits) long. Also note that the signature is intentionally different each time because ECDSA uses a random k value. 1// The first 24 bytes of the SHA-256 hash for &#34;Hack the Planet!&#34;&#10;char bytes[] = &#123; 56, 164, 34, 250, 121, 21, 2, 18, 65, 4, 161, 90, 126, 145, 111, 204, &#10; 151, 65, 181, 4, 231, 177, 117, 154 &#125;;&#10;NSData *messageHash = [NSData dataWithBytes:bytes length:24];&#10; &#10;GMEllipticCurveCrypto *crypto = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;crypto.privateKeyBase64 = @&#34;ENxb+5pCLAGT88vGmE6XLQRH1e8i/0rz&#34;;&#10;NSData *signature = [crypto signatureForHash:messageHash];&#10;NSLog(@&#34;Signature: %@&#34;, signature); Verify a signature1// messageHash and signature from above&#10;&#10;crypto = [GMEllipticCurveCrypto cryptoForCurve:GMEllipticCurveSecp192r1];&#10;crypto.publicKeyBase64 = @&#34;AtF8hCxh9h1zlExuOZutuw+tRzmk3zVdfA==&#34;;;&#10;BOOL valid = [crypto verifySignature:signature forHash:messageHash];&#10;NSLog(@&#34;Valid Signature: %@&#34;, (valid ? @&#34;YES&#34;: @&#34;NO&#34;)); Shared secretShared secrets using ECDH are the same length as the curve. So, the 192 bit curve will produce a shared secret that is 24 bytes (192 bits) long. 1NSString *alicePublicKey = @&#34;A9N+XWIjLCYAwa8Hb7T6Rohttqo91CF8HQ==&#34;;&#10;NSString *alicePrivateKey = @&#34;frs4puAKipcbevvwJb7l77xACgB/FyBv&#34;;&#10;&#10;NSString *bobPublicKey = @&#34;A35aoteno4wnAdJgV8AXKKl1AfPVRrSZQA==&#34;;&#10;NSString *bobPrivateKey = @&#34;LP83qv81MsXVyPOFV7V5jKVOoU4DKPUS&#34;;&#10;&#10;&#10;// Alice performs...&#10;GMEllipticCurveCrypto *alice = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;alice.privateKeyBase64 = alicePrivateKey;&#10;NSData *aliceSharedSecret = [alice sharedSecretForPublicKeyBase64:bobPublicKey];&#10;NSLog(@&#34;Shared Secret Alice: %@&#34;, aliceSharedSecret);&#10;&#10;// Bob performs...&#10;GMEllipticCurveCrypto *bob = [GMEllipticCurveCrypto cryptoForCurve:&#10; GMEllipticCurveSecp192r1];&#10;bob.privateKeyBase64 = bobPrivateKey;&#10;NSData *bobSharedSecret = [bob sharedSecretForPublicKeyBase64:alicePublicKey];&#10;NSLog(@&#34;Shared Secret Bob: %@&#34;, bobSharedSecret);&#10;&#10;// And now both parties have the same secret!&#10;NSLog(@&#34;Shared secrets equal? %d&#34;, [aliceSharedSecret isEqualToData:bobSharedSecret]); Convenience functionsAutomatically detects curve and sets up the private or public key1+ (GMEllipticCurveCrypto*)cryptoForKey: (NSData*)privateOrPublicKey;&#10;+ (GMEllipticCurveCrypto*)cryptoForKeyBase64: (NSString*)privateOrPublicKey; Automatically hash and compute the signature for a messageInclude the GMEllipticCurveCrypto+hash.h category to hash data automatically before signing and verifying. The hash algorithm used must be at least the length of the curve. The hash will have the right-most bytes truncated, if necessary. 1- (NSData*)hashSHA256AndSignData: (NSData*)data;&#10;- (BOOL)hashSHA256AndVerifySignature: (NSData*)signature forData: (NSData*)data;&#10;&#10;- (NSData*)hashSHA384AndSignData: (NSData*)data;&#10;- (BOOL)hashSHA384AndVerifySignature: (NSData*)signature forData: (NSData*)data; Why?Kenneth MacKay’s easy-ecc is an awesome, simple-to-use implementation of essential Elliptic Curve Cryptographic functions, however, the curve used is specified as a compile-time constant, so it cannot be changed at runtime. This library allows any and as many different curves to be used at once. Donations?Sure! :-) Bitcoin - 1LNdGsYtZXWeiKjGba7T997qvzrWqLXLma","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"ECC","slug":"ECC","permalink":"http://yoursite.com/tags/ECC/"},{"name":"ECDH","slug":"ECDH","permalink":"http://yoursite.com/tags/ECDH/"},{"name":"ECDSA","slug":"ECDSA","permalink":"http://yoursite.com/tags/ECDSA/"}]},{"title":"【小程序】RSA签名&验签&加密&解密","slug":"【小程序】RSA签名","date":"2017-05-27T09:01:15.000Z","updated":"2017-05-31T05:40:12.000Z","comments":true,"path":"2017/05/27/【小程序】RSA签名/","link":"","permalink":"http://yoursite.com/2017/05/27/【小程序】RSA签名/","excerpt":"","text":"一个适用于微信小程序的RSA签名加密库。 RSA签名的小程序DEMO：https://github.com/zhangzhaopds/WeixinApp_RSA_Signature.git 使用1、引入文件 1var RSA = require('../../utils/wxapp_rsa.js') 2、调用 123456789101112131415161718192021222324252627282930313233343536373839var privateKey_pkcs1 = '-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQCk7WKdggwBOtteLL5sPom8RYCjuw0hy6R1jH39tCaep1Dns02bi4CYHk2dSR / t0ABgF5pHYeMxHa74Dp6Z6SjfAKMUu53BbTR615ehK + 03BjtzJzviTF1 / NtLmGaR3aawrDp7oQgq33dfIYbWLuAMkHNiWaoXaGyHh3a8jS2vxfQIDAQABAoGAIKRnLzts + tVWU5ZRfgUGp7 + tzToZSEYQ378VtJ / yQNZmueUQCCgdJH5i6C1v51aSrHIfc99Y4wC3/ 5qNI3M1RlRpIakmcaiEv1m6huDPLKFq6Y1e+ AZ0Cb0xo3bny + VTOvfGgcAdSa6++K47bGaxyKzwGeNZQkltm5sgbVcKvkECQQDVjWbSU8P8nDb+TP5Aqr + DaMVA425wv2ra2jhxd6KqKxgHHB7yYWlODiYNrtALOEG9zfSpHVQWhZpiKq8XcWwRAkEAxbWzPAqZxaZ / XTs65uCL0 + iqif0qCSDUNis61wYm2UwOh4LqBZIFop94B3ybEXbCvUl0v26H0fgXjFUErvlKrQJBAKjbAe5U5accLi + t2WxwlrXlZfME4hKsiGU8H10455n+ MSWOCrpEY + ugLF6tVztH5FOcQlRmKFMWmRf + ACxdNsECQDBjkEKZtZkSbwm6fWgUfSSYRWUQeUFSr52yZuxJrShx3Px9phlG6 + opbY8niCx2DKOXXuObgdJ6DglipYrNqOECQQCndP + zU / jwlvjQzEabKdP05uFc5JV6ySFBQwuoENbEvW3uz + Yz31xDYbrwIzrysVDovlj0ExL6LC + JRvpJmHcN-----END RSA PRIVATE KEY-----' var publicKey_pkcs1 = '-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCk7WKdggwBOtteLL5sPom8RYCjuw0hy6R1jH39tCaep1Dns02bi4CYHk2dSR / t0ABgF5pHYeMxHa74Dp6Z6SjfAKMUu53BbTR615ehK + 03BjtzJzviTF1/ NtLmGaR3aawrDp7oQgq33dfIYbWLuAMkHNiWaoXaGyHh3a8jS2vxfQIDAQAB-----END PUBLIC KEY-----' // 加签 var sign_rsa = new RSA.RSAKey(); sign_rsa = RSA.KEYUTIL.getKey(privateKey_pkcs1); console.log('签名RSA:') console.log(sign_rsa) var hashAlg = 'sha1'; var hSig = sign_rsa.signString(\"signData\", hashAlg); hSig = RSA.hex2b64(hSig); // hex 转 b64 console.log(\"签名结果：\" + hSig) // 验签 var verify_rsa = new RSA.RSAKey(); verify_rsa = RSA.KEYUTIL.getKey(publicKey_pkcs1); console.log('验签RSA:') console.log(verify_rsa) hSig = RSA.b64tohex(hSig) var ver = verify_rsa.verifyString(\"signData\", hSig) console.log('验签结果：' + ver) // 加密 var encrypt_rsa = new RSA.RSAKey(); encrypt_rsa = RSA.KEYUTIL.getKey(publicKey_pkcs1); console.log('加密RSA:') console.log(encrypt_rsa) var encStr = encrypt_rsa.encrypt('123456') encStr = RSA.hex2b64(encStr); console.log(\"加密结果：\" + encStr) // 解密 var decrypt_rsa = new RSA.RSAKey(); decrypt_rsa = RSA.KEYUTIL.getKey(privateKey_pkcs1); console.log('解密RSA:') console.log(decrypt_rsa) encStr = RSA.b64tohex(encStr) var decStr = decrypt_rsa.decrypt(encStr) console.log(\"解密结果：\" + decStr) 需要注意的是：区分RSA私钥的类型，有pkcs1和pkcs8。pkcs8格式的私钥主要用于java中。 1234567// pkcs1格式：-----BEGIN RSA PRIVATE KEY----------END RSA PRIVATE KEY------// pkcs8格式：-----BEGIN PRIVATE KEY----------END PRIVATE KEY-----","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"},{"name":"签名","slug":"签名","permalink":"http://yoursite.com/tags/签名/"}]},{"title":"【GVR】Google VR","slug":"【GVR】Google-VR","date":"2017-05-26T05:44:17.000Z","updated":"2017-05-26T05:59:49.000Z","comments":true,"path":"2017/05/26/【GVR】Google-VR/","link":"","permalink":"http://yoursite.com/2017/05/26/【GVR】Google-VR/","excerpt":"","text":"Google提供的iOS 版本的VR技术的SDK，主要有三种视图类型：GVRCardboardView这个最为强大，但需要复杂的OpenGL渲染, GVRPanoramaView全景照片, and GVRVideoView这个是VR视频。 官方文档：https://developers.google.com/vr/ios/get-started 非官方但很详细的使用介绍：https://www.raywenderlich.com/136692/introduction-google-cardboard-ios","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"GVR","slug":"GVR","permalink":"http://yoursite.com/tags/GVR/"},{"name":"VR","slug":"VR","permalink":"http://yoursite.com/tags/VR/"}]},{"title":"Release版本的项目只在iOS9.2及以下Crash","slug":"Xcode8打包的Swift3项目在iOS9-2及以下闪退","date":"2017-05-16T06:07:30.000Z","updated":"2017-05-16T06:53:11.000Z","comments":true,"path":"2017/05/16/Xcode8打包的Swift3项目在iOS9-2及以下闪退/","link":"","permalink":"http://yoursite.com/2017/05/16/Xcode8打包的Swift3项目在iOS9-2及以下闪退/","excerpt":"","text":"用Xcode8打包的Swift3的项目，只在iOS9.2及以下的Release版本中Crash，真机测试所有版本都没问题。而且给出的错误报告，也是随机的且还是系统私有的库。 列举几个iOS9.2中收到的错误报告： 1#1&#10;CoreUI&#10;-[CUIStructuredThemeStore renditionWithKey:usingKeySignature]&#10;&#10;#2&#10;CoreFoundation&#10;-[NSCache setObject:forKey:cost:]&#10;&#10;#3&#10;CoreFoundation&#10;-[_CFXNotificationObserverRegistration find:]&#10;&#10;#4 UIKit&#10;_InitiallizeTouchTapCount&#10;&#10;#5&#10;CoreGraphics&#10;subImageProviderCopyImageBlockSet 最终抛出的异常为： 1EXC_BAD_ACCESS KERN_INVALID_ADDRESS 这些错误报告中有反复出现的类：UIImageAsset、UIAssetManager 原因：项目中的图片的 color space 格式不对。 具体就是项目中使用了含有 非sRGB 颜色空间的图片。我的项目中就因为有几张图片是Adobe RGB类型的，导致iOS9.2.1的手机系统在打开使用了这几张图片的页面crash。 而苹果对于图片的使用也有官方文档说明，可以查看 https://developer.apple.com/library/ios/documentation/graphicsimaging/reference/CGColorSpace/Reference/reference.html 解决:可参考：http://stackoverflow.com/questions/39404285/xcode-8-build-crash-on-ios-9-2-and-below 方法一：查看项目中的图片格式：查看方法，手动替换掉所有 Adobe RGB颜色空间的图片为sRGB； 方法二：在项目中运行脚本： 12345678910111213141516#!/bin/bashDIRECTORY=$1echo \"------------------------------\"echo \"Passed Resources with xcassets folder argument is &lt;$DIRECTORY&gt;\"echo \"------------------------------\"echo \"Processing asset:\"find \"$DIRECTORY\" -name '*png' -print0 | while read -d $'\\0' file; do echo \"---------$file\" sips -m \"/System/Library/Colorsync/Profiles/sRGB Profile.icc\" \"$file\" --out \"$file\"doneecho \"------------------------------\"echo \"script successfully finished\"echo \"------------------------------\"","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Adobe RGB","slug":"Adobe-RGB","permalink":"http://yoursite.com/tags/Adobe-RGB/"},{"name":"iOS9.2","slug":"iOS9-2","permalink":"http://yoursite.com/tags/iOS9-2/"},{"name":"sRGB","slug":"sRGB","permalink":"http://yoursite.com/tags/sRGB/"}]},{"title":"【ERROR】relation auth_user does not exist","slug":"relation-auth-user-does-not-exist","date":"2017-05-09T08:46:30.000Z","updated":"2017-05-09T09:03:32.000Z","comments":true,"path":"2017/05/09/relation-auth-user-does-not-exist/","link":"","permalink":"http://yoursite.com/2017/05/09/relation-auth-user-does-not-exist/","excerpt":"","text":"Django应用在本地通过heroku local web测试没有问题，但部署到Heroku后，打开admin站点，出现的relation auth_user does not exist问题。 原因应用只在本地创建了超级管理员，但在部署到Heroku后处于生产环境，而生产环境中没有配置超级管理员。 解决123heroku run python manage.py makemigrationsheroku run python manage.py migrateheroku run python manage.py createsuperuser 执行以上指令，创建生产环境的管理员。 需要注意的是，运行 heroku run 指令，需要先指定 heroku应用，否则会一直出现 Error: No app specified 的报错，如没报错，可忽略。 指定Heroku应用的操作，如下： 12345# 如果存在heroku仓库，但不是当前应用，可先执行删除git remote rm heroku# 添加应用仓库到herokugit remote add heroku https://git.heroku.com/myzz.git 本文参考：http://stackoverflow.com/questions/29689365/auth-user-error-with-django-1-8-and-syncdb-migrate","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Heroku","slug":"Heroku","permalink":"http://yoursite.com/tags/Heroku/"},{"name":"autn_user","slug":"autn-user","permalink":"http://yoursite.com/tags/autn-user/"}]},{"title":"【译】在Heroku上部署Django应用（2、部署）","slug":"【译】在Heroku上部署Django应用（二）","date":"2017-05-09T01:57:25.000Z","updated":"2017-05-09T02:01:24.000Z","comments":true,"path":"2017/05/09/【译】在Heroku上部署Django应用（二）/","link":"","permalink":"http://yoursite.com/2017/05/09/【译】在Heroku上部署Django应用（二）/","excerpt":"","text":"Heroku支持所有类型的Python应用，包括Django应用。需要说明的是，Django的手动配置很繁琐，最便捷的方法是直接在Heroku控制台生成相对应的应用。 本地服务执行以下指令，在本地安装相关依赖库。 12345$ pip install -r requirements.txtDownloading/unpacking ......Successfully installed Django dj-database-url dj-static django-toolbelt gunicorn psycopg2 static3Cleaning up... 开启本地服务 123456$ heroku local web11:48:19 web.1 | started with pid 3608411:48:19 web.1 | 2014-07-17 11:48:19 [36084] [INFO] Starting gunicorn 19.0.011:48:19 web.1 | 2014-07-17 11:48:19 [36084] [INFO] Listening at: http://0.0.0.0:5000 (36084)11:48:19 web.1 | 2014-07-17 11:48:19 [36084] [INFO] Using worker: sync11:48:19 web.1 | 2014-07-17 11:48:19 [36087] [INFO] Booting worker with pid: 36087 最后，一切正常的情况下便可访问http://localhost:5000/ Heroku部署123456789101112131415$ git add .$ git commit -m \"Added a Procfile.\"$ heroku loginEnter your Heroku credentials....$ heroku createCreating intense-falls-9163... done, stack is cedarhttp://intense-falls-9163.herokuapp.com/ | git@heroku.com:intense-falls-9163.gitGit remote heroku added$ git push heroku master...-----&gt; Python app detected...-----&gt; Launching... done, v7 https://intense-falls-9163.herokuapp.com/ deployed to Heroku 最后执行以下指令，便可在浏览器中打开站点 1$ heroku open 原文地址： https://devcenter.heroku.com/articles/deploying-python#django-applications-on-heroku","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Heroku","slug":"Heroku","permalink":"http://yoursite.com/tags/Heroku/"}]},{"title":"【译】在Heroku上部署Django应用（1、配置）","slug":"【译】在Heroku上部署Django应用（一）","date":"2017-05-09T00:56:54.000Z","updated":"2017-05-09T01:50:23.000Z","comments":true,"path":"2017/05/09/【译】在Heroku上部署Django应用（一）/","link":"","permalink":"http://yoursite.com/2017/05/09/【译】在Heroku上部署Django应用（一）/","excerpt":"","text":"Heroku支持所有类型的Python应用，包括Django应用。需要说明的是，Django的手动配置很繁琐，最便捷的方法是直接在Heroku控制台生成相对应的应用。 创建Django应用1、利用Heroku创建这个是最便捷的方法，无需额外配置，极力推荐的一种形式。 2、利用Django指令1$ django-admin startproject --template=https://github.com/heroku/heroku-django-template/archive/master.zip --name=Procfile myproject 这条指令创建了一个预配置的Django应用。之后刷新Django应用即可。 已有Django应用的配置对于一个已经存在的Django应用进行配置。 1、基本配置首先，最重要的一条是Heroku网站应用需要 Procfile文件。这个文件要放置在仓库根目录下。 Procfile 1web: gunicorn myproject.wsgi --log-file - gunicorn是我们推荐使用的Django应用生产环境服务器。 myproject换成自己的工程名。 安装Gunicorn 123$ pip install gunicorn...$ pip freeze &gt; requirements.txt 2、数据库配置安装 dj-database-url 来配置`DATABASE_URL `环境。 123$ pip install dj-database-url...$ pip freeze &gt; requirements.txt settings.py 1234# Update database configuration with $DATABASE_URL.import dj_database_urldb_from_env = dj_database_url.config()DATABASES['default'].update(db_from_env) 3、数据库连接的持久性默认情况下，对于应用的每次请求循环，Django都会创建一个新的持久性数据库连接。这个一个昂贵的开销，会降低应用的性能。所以，更改配置如下。 settings.py 1234# Update database configuration with $DATABASE_URL.import dj_database_urldb_from_env = dj_database_url.config(conn_max_age=500)DATABASES['default'].update(db_from_env) 更多的信息，可以查看Concurrency and Database Connections in Django. 4、静态资源Django应用，对于静态资源的配置和调试相对将困难。更改相关配置，将改变这一状态。 settings.py 123456789101112# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.9/howto/static-files/PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))STATIC_ROOT = os.path.join(PROJECT_ROOT, 'staticfiles')STATIC_URL = '/static/'# Extra places for collectstatic to find static files.STATICFILES_DIRS = ( os.path.join(PROJECT_ROOT, 'static'),) 关于静态资源的知识，可查看Django and Static Assets. 5、WhitenoiseDjango应用在生产环境是没有静态文件的服务的。添加Whitenoise来提升服务。 Whitenoise 123$ pip install whitenoise...$ pip freeze &gt; requirements.txt settings.py 1234# Simplified static file serving.# https://warehouse.python.org/project/whitenoise/STATICFILES_STORAGE = 'whitenoise.django.GzipManifestStaticFilesStorage' wsgi.py 12345from django.core.wsgi import get_wsgi_applicationfrom whitenoise.django import DjangoWhiteNoiseapplication = get_wsgi_application()application = DjangoWhiteNoise(application) 原文地址：https://devcenter.heroku.com/articles/django-app-configuration","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Heroku","slug":"Heroku","permalink":"http://yoursite.com/tags/Heroku/"}]},{"title":"【小程序】中文转码的MD5加密","slug":"【小程序】中文转码的MD5加密","date":"2017-05-03T02:35:49.000Z","updated":"2017-05-03T02:36:54.000Z","comments":true,"path":"2017/05/03/【小程序】中文转码的MD5加密/","link":"","permalink":"http://yoursite.com/2017/05/03/【小程序】中文转码的MD5加密/","excerpt":"","text":"中文转码的MD5加密 http://7xoz39.com1.z0.glb.clouddn.com/md5.js","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[]},{"title":"【小程序】POST请求服务器接收不到参数","slug":"【小程序】POST请求服务器接收不到参数","date":"2017-05-03T02:27:25.000Z","updated":"2017-05-03T02:31:18.000Z","comments":true,"path":"2017/05/03/【小程序】POST请求服务器接收不到参数/","link":"","permalink":"http://yoursite.com/2017/05/03/【小程序】POST请求服务器接收不到参数/","excerpt":"","text":"POST请求服务器接收不到参数的坑 设置header如下 1header: &#123; \"Content-Type\": \"application/x-www-form-urlencoded\" &#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[]},{"title":"【ERROR】RestKit-'objectRequestOpertationDidStart:'","slug":"【ERROR】RestKit-objectRequestOpertationDidStart","date":"2017-03-15T07:29:47.000Z","updated":"2017-03-15T07:52:29.000Z","comments":true,"path":"2017/03/15/【ERROR】RestKit-objectRequestOpertationDidStart/","link":"","permalink":"http://yoursite.com/2017/03/15/【ERROR】RestKit-objectRequestOpertationDidStart/","excerpt":"","text":"RestKit使用时，执行[objectRequestOperation start]方法，在&#39;&#39;objectRequestOpertationDidStart:&#39;&#39;&#39;处报错。 环境Xcode: 8.2.1 RestKit: 0.27.0 iOS: 8.0 报错执行内容： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; RKObjectMapping* articleMapping = [RKObjectMapping mappingForClass:[Duanzi class]]; [articleMapping addAttributeMappingsFromDictionary:@&#123;@\"title\": @\"title\", @\"digest\": @\"digest\", @\"downTimes\": @\"downTimes\"&#125;]; RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:nil keyPath:@\"段子\" statusCodes:RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful)]; NSURL *url = [NSURL URLWithString:@\"http://c.3g.163.com/recommend/getChanRecomNews?channel=duanzi&amp;passport=&amp;devId=676BEC68-01DA-4BB3-9F8F-0A99F9ADFEE2&amp;size=20\"]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; RKObjectRequestOperation *objectRequestOperation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]]; [objectRequestOperation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) &#123; Duanzi *duanzi = [mappingResult firstObject]; RKLogInfo(@\"%ld\", mappingResult.count); RKLogInfo(@\"%@\", duanzi.downTimes); RKLogInfo(@\"%@\", duanzi.digest); RKLogInfo(@\"%@\", duanzi.title); &#125; failure:^(RKObjectRequestOperation *operation, NSError *error) &#123; NSLog(@\"%@\", error.localizedDescription); &#125;]; [objectRequestOperation start];&#125; 解决替换 [objectRequestOperation start]; 方法一：(在我的项目中，这个方法并没有起作用，也就没有采用) 1[[RKObjectManager sharedManager] enqueueObjectRequestOperation:objectRequestOperation]; 方法二：(实际采用的方法) 1NSOperationQueue *queue = [[NSOperationQueue alloc] init];&#10;[queue addOperation:objectRequestOperation];","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"RestKit","slug":"RestKit","permalink":"http://yoursite.com/tags/RestKit/"}]},{"title":"【微信小程序】二维码生成与识别器","slug":"【微信小程序】二维码生成与识别器","date":"2017-03-10T01:34:00.000Z","updated":"2017-03-10T01:53:28.000Z","comments":true,"path":"2017/03/10/【微信小程序】二维码生成与识别器/","link":"","permalink":"http://yoursite.com/2017/03/10/【微信小程序】二维码生成与识别器/","excerpt":"","text":"一个二维码生成与识别的很简单的微信小程序，主要是为了走一下小程序开发的整个流程。7号上午提交的审核，8号出结果，审核速度还可以，发布需要管理员手动发布。唯一令人烦的地方是，开发者的权限太低，除了编码，其他的操作都需要管理员扫描相应操作的二维码（前前后后将近10次）。 二维码生成与识别器项目源码：https://github.com/zhangzhaopds/QrPay.git 效果图： 安装地址","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/微信小程序/"}],"tags":[{"name":"二维码生成","slug":"二维码生成","permalink":"http://yoursite.com/tags/二维码生成/"},{"name":"二维码识别","slug":"二维码识别","permalink":"http://yoursite.com/tags/二维码识别/"}]},{"title":"【Python】Pillow图片处理库","slug":"【Python】Pillow图片处理库","date":"2017-03-02T07:26:19.000Z","updated":"2017-03-02T07:40:32.000Z","comments":true,"path":"2017/03/02/【Python】Pillow图片处理库/","link":"","permalink":"http://yoursite.com/2017/03/02/【Python】Pillow图片处理库/","excerpt":"","text":"Pillow是Python中的图片处理库，来自于PIL，使用时 import PIL; 安装Python2中安装命令: 1sudo pip install PIL Python3中安装命令: 1sudo pip install Pillow 创建12mg = Image.open('pic.JPG')print(img.size, img.mode) # (3264, 2448) RGB 缩略图1234size = (200, 200)img.thumbnail(size)img.save('/Users/zhangzhao/PycharmProjects/pillow_demo/thum.JPEG')print(img.size, img.mode) # (200, 150) RGB 剪切图剪切函数 crop(box)：box = (left, upper, right, lower) 注意：right &gt; left; lower &gt; upper; 剪切后图片长宽： width = right - left; height = lower - upper; 12345frame = (1632, 0, 3264, 1224) # 图片四分之一右上角部分crop_img = Image.open('pic.JPG').crop(frame)crop_img.save('/Users/zhangzhao/PycharmProjects/pillow_demo/crop.jpg')#crop_img.show()print(crop_img.size) # (1632, 1224) 几何转换尺寸转换 12resize_out = crop_img.resize((200, 200))#resize_out.show() 角度转换 12rotate_out = crop_img.rotate(45) # 逆时针 45#rotate_out.show() 模式转换123change_mode = resize_out.convert('L')print(resize_out.mode) # RGBprint(change_mode.mode) # L http://www.cnblogs.com/wbin91/p/3971079.html","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"PIL","slug":"PIL","permalink":"http://yoursite.com/tags/PIL/"},{"name":"Pillow","slug":"Pillow","permalink":"http://yoursite.com/tags/Pillow/"}]},{"title":"【Python】简单应用-xlwt库","slug":"【Python】简单应用-xlwt库","date":"2017-03-02T02:22:03.000Z","updated":"2017-03-02T02:40:18.000Z","comments":true,"path":"2017/03/02/【Python】简单应用-xlwt库/","link":"","permalink":"http://yoursite.com/2017/03/02/【Python】简单应用-xlwt库/","excerpt":"","text":"获取成都教育网的学校信息，并将信息以Excel格式存储。 项目地址 https://github.com/zhangzhaopds/chengdujiaoyu.git 安装 xlwt 库，它可以用来处理 Excel 97/2000/XP/2003 的xls文件。 导入相关类库： 123from bs4 import BeautifulSoupimport requestsimport xlwt 获取页面数据： 1234567891011schs = []for page in range(107): # 页面请求 url = 'http://infomap.cdedu.gov.cn/Home/Index?all=2' req = requests.get(url) # 页面处理 soup = BeautifulSoup(req.content, \"html.parser\") schools = soup.find_all(class_='index_ul01') for school in schools: for item in school: schs.append(item) 学校数据信息的处理： 1234567891011121314151617# 学校信息sch_infos = []for item in schs: # 学校名 title = '【学校】' + item.a.h1.string # 学校信息 text_div = item.find_all(class_='text_div') for ps in text_div: all_p = ps.find_all('p') item_info = [] item_info.append(title) for p in all_p: item_info.append(p.string) sch_infos.append(item_info)sch_infos.insert(0, ['【学校】学校', '【学段】学段', '【区域】区域', '【性质】性质', '【电话】电话', '【地址】地址', '【网站】网站', '【信息】信息'])print(sch_infos) Excel的处理： 12345678910111213# 创建xlwt工作簿workbook = xlwt.Workbook()# 添加板块booksheet = workbook.add_sheet('学校信息', cell_overwrite_ok=True)for i,row in enumerate(sch_infos): for j,col in enumerate(row): if col != None: # 添加数据 booksheet.write(i, j, col[4:])# 保存到本地文件workbook.save('schools.xls')","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"},{"name":"xlwt","slug":"xlwt","permalink":"http://yoursite.com/tags/xlwt/"}]},{"title":"【Python】简单应用-糗事百科","slug":"【Python】简单应用-糗事百科","date":"2017-02-27T07:39:31.000Z","updated":"2017-02-27T07:41:44.000Z","comments":true,"path":"2017/02/27/【Python】简单应用-糗事百科/","link":"","permalink":"http://yoursite.com/2017/02/27/【Python】简单应用-糗事百科/","excerpt":"","text":"一个抓取糗事百科内容的小程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 糗事百科from pip._vendor.distlib.compat import raw_inputfrom bs4 import BeautifulSoupimport requestsclass Qiu: # 获取界面数据 def getPage(self): # 页面 input = raw_input('输入要获取内容的页面：') myUrl = 'http://m.qiushibaike.com/hot/page/' + input headers = &#123;'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'&#125; req = requests.get(myUrl, headers=headers) # 转换成BeautifulSoup对象 soup = BeautifulSoup(req.text, \"html.parser\") # 筛选出所有 class='content' 的标签，用 class_ 来替代 class items = soup.find_all(class_='content') for item in items: sss = '' # 利用stripped_strings去除空格和换行 for str in item.span.stripped_strings: sss = sss + str print(sss + '\\n') # 非 q键 读取下一条内容 inputContent = raw_input() if inputContent == 'q': # 退出程序 print('退出当前页面') break inputContent = raw_input('输入任意键结束程序；输入 n 重新运行：') if inputContent == 'n': self.getPage() print('-----程序已经退出------')# 程序入口qiu = Qiu()qiu.getPage()","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"糗事百科","slug":"糗事百科","permalink":"http://yoursite.com/tags/糗事百科/"}]},{"title":"【Python】简单应用—网站压力测试","slug":"【Python】简单应用-刷博客访问量","date":"2017-02-24T08:45:28.000Z","updated":"2017-02-24T09:19:25.000Z","comments":true,"path":"2017/02/24/【Python】简单应用-刷博客访问量/","link":"","permalink":"http://yoursite.com/2017/02/24/【Python】简单应用-刷博客访问量/","excerpt":"","text":"利用随机生成的请求header，对同一地址进行假身份访问； 代码地址：https://github.com/zhangzhaopds/request_demo randomHeader.py123456789101112131415161718192021222324252627282930313233import randomdef randHeader(): head_connection = ['Keep-Alive', 'close'] head_accept = ['text/html, application/xhtml+xml, */*'] head_accept_language = ['zh-CN,fr-FR;q=0.5', 'en-US,en;q=0.8,zh-Hans-CN;q=0.5,zh-Hans;q=0.3'] head_user_agent = ['Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko', 'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36', 'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; rv:11.0) like Gecko)', 'Mozilla/5.0 (Windows; U; Windows NT 5.2) Gecko/2008070208 Firefox/3.0.1', 'Mozilla/5.0 (Windows; U; Windows NT 5.1) Gecko/20070309 Firefox/2.0.0.3', 'Mozilla/5.0 (Windows; U; Windows NT 5.1) Gecko/20070803 Firefox/1.5.0.12', 'Opera/9.27 (Windows NT 5.2; U; zh-cn)', 'Mozilla/5.0 (Macintosh; PPC Mac OS X; U; en) Opera 8.0', 'Opera/8.0 (Macintosh; PPC Mac OS X; U; en)', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080219 Firefox/2.0.0.12 Navigator/9.0.0.6', 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0)', 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)', 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Maxthon/4.0.6.2000 Chrome/26.0.1410.43 Safari/537.1 ', 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E; QQBrowser/7.3.9825.400)', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0 ', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.92 Safari/537.1 LBBROWSER', 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; BIDUBrowser 2.x)', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/3.0 Safari/536.11'] header = &#123; 'Connection': head_connection[0], 'Accept': head_accept[0], 'Accept-Language': head_accept_language[1], 'User-Agent': head_user_agent[random.randrange(0, len(head_user_agent))] &#125; return header request.py1234567891011121314151617181920212223242526272829import requestsfrom bs4 import BeautifulSoupimport randomHeaderprint(randomHeader.randHeader())data = &#123;'viewmode': 'contents'&#125;headers = &#123;'content-type': 'application/json', 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0'&#125;req = requests.get(\"http://blog.csdn.net/zz110731\", params=data, headers=headers)soup = BeautifulSoup(req.text)articles = soup.find_all(class_='link_title')k = 0while k &lt; 100: m = 0 for article in articles: link = 'http://blog.csdn.net' + article.a['href'] # print(link) head = randomHeader.randHeader() qq = requests.get(link, headers=head) # print(head) m = m + 1 print(m) print(qq) k = k + 1 print(\"第&#123;0&#125;次，请求完毕\".format(k))","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"随机Header","slug":"随机Header","permalink":"http://yoursite.com/tags/随机Header/"}]},{"title":"【Python】BeautifulSoup基本使用","slug":"【Python】BeautifulSoup使用","date":"2017-02-24T06:26:55.000Z","updated":"2017-02-24T07:14:57.000Z","comments":true,"path":"2017/02/24/【Python】BeautifulSoup使用/","link":"","permalink":"http://yoursite.com/2017/02/24/【Python】BeautifulSoup使用/","excerpt":"","text":"BeautifulSoup是Python中用来解析HTML、XML等文档的强大工具。 Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment。 1234567891011html_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;这个是b标签&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\" 1soup = BeautifulSoup(html_doc) 1、Tag标签对象12tag = soup.pprint(type(tag)) # &lt;class 'bs4.element.Tag'&gt; 标签的属性可以被添加,删除或修改，操作如字典 123456tag['class'] = \"very\" # 修改属性值tag['id'] = 1 # 添加id属性print(tag) # &lt;p class=\"verybold\" id=\"1\"&gt;&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;del tag['id'] # 删除id属性print(tag) # &lt;p class=\"very\"&gt;&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt; 多值属性 返回list类型数据 12css_soup = BeautifulSoup('&lt;p class=\"body strikeout\"&gt;&lt;/p&gt;')print(css_soup.p['class']) # ['body', 'strikeout'] 非多值属性 返回string 12n_css_soup = BeautifulSoup('&lt;p id=\"body name\"&gt;&lt;/p&gt;')print(n_css_soup.p['id']) # body name2、NavigableString：标签中的字符串 2、NavigableString标签中的字符串1234print(type(tag.string)) # &lt;class 'bs4.element.NavigableString'&gt;print(tag.string) # 这个是b标签tag.string.replace_with('you are beautiful')print(tag.string) # you are beautiful 3、BeautifulSoup对象12print(type(soup)) # &lt;class 'bs4.BeautifulSoup'&gt;print(soup.name) # [document] 4、Comment注释及特殊字符串Comment 对象是一个特殊类型的 NavigableString 对象 12345678markup = \"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;\"mark_soup = BeautifulSoup(markup)print(type(mark_soup.b.string)) # &lt;class 'bs4.element.Comment'&gt;print(mark_soup.b.string) # Hey, buddy. Want to buy a used parser?print(mark_soup.b.prettify()) # comment 也可以prettify()格式化输出#&lt;b&gt;# &lt;!--Hey, buddy. Want to buy a used parser?--&gt;#&lt;/b&gt; contents子节点以list形式输出 123print(soup.head) # &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;print(soup.head.contents) # [&lt;title&gt;The Dormouse's story&lt;/title&gt;]print(soup.head.contents[0]) # &lt;title&gt;The Dormouse's story&lt;/title&gt; children子节点迭代器 123print(type(soup.head.children)) # &lt;class 'list_iterator'&gt;for child in soup.head.children: print(child) descendants子孙节点生成器 递归循环的列出子节点和子孙节点 12345print(type(soup.head.descendants)) # &lt;class 'generator'&gt;for child in soup.head.descendants: print(child) # &lt;title&gt;The Dormouse's story&lt;/title&gt; 子节点 # The Dormouse's story 孙节点 strings标签中的字符串 123456789101112131415161718for str in soup.strings: print(repr(str))# '\\n'# \"The Dormouse's story\"# '\\n'# '\\n'# 'you are beautiful'# '\\n'# 'Once upon a time there were three little sisters; and their names were\\n'# 'Elsie'# ',\\n'# 'Lacie'# ' and\\n'# 'Tillie'# ';\\nand they lived at the bottom of a well.'# '\\n'# '...'# '\\n stripped_strings去除空格空行 123456789101112for str in soup.stripped_strings: print(repr(str))# \"The Dormouse's story\"# 'you are beautiful'# 'Once upon a time there were three little sisters; and their names were'# 'Elsie'# ','# 'Lacie'# 'and'# 'Tillie'# ';\\nand they lived at the bottom of a well.'# '...' http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id7","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"【Python】视频资源","slug":"【Python】视频资源","date":"2017-02-24T03:44:55.000Z","updated":"2017-02-24T03:46:55.000Z","comments":true,"path":"2017/02/24/【Python】视频资源/","link":"","permalink":"http://yoursite.com/2017/02/24/【Python】视频资源/","excerpt":"","text":"python3英文视频教程(全87集) http://pan.baidu.com/s/1dDnGBvV Python从入门到精通视频（全60集）链接：http://pan.baidu.com/s/1eQw2dd4 密码：9bdl Python学习手册视频教程(全44集) http://pan.baidu.com/s/1o64tpf8 零基础入门学习Python(全42集) 链接：http://pan.baidu.com/s/1qWNmdKo 密码：jrjy 中谷python视频教程（全38集） http://pan.baidu.com/s/1o6LUn1o 老男孩Python运维系统开发（全36集）链接：http://pan.baidu.com/s/1sjuJLEl 密码：kypb Let’s-python系列视频教程（全25集） http://pan.baidu.com/s/1dD4BAi1 老男孩Python高级运维编程实战精品入门进阶（全27集） 链接：http://pan.baidu.com/s/1dDu2k61 密码：q8s8 播布客python基础教程(全21集) http://pan.baidu.com/s/1o6p0krC 老男孩python运维视频教程（全15集）http://pan.baidu.com/s/1o6hYBqi 基于python web框架(全13集) http://pan.baidu.com/s/1mgFSE60 Python.Django视频教程（全13集）http://pan.baidu.com/s/1mgC4RdY python基础教程视频(全13集) http://pan.baidu.com/s/1kTDmOy7 老男孩python自动化运维视频教程（全9集）http://pan.baidu.com/s/1o6Fi9KI Python视频专题讲座（全9集） http://pan.baidu.com/s/1bndBuAr 利用Python SOCKET多线程开发FTP软件（全6集）http://pan.baidu.com/s/1eQcPovo","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"视频资源","slug":"视频资源","permalink":"http://yoursite.com/tags/视频资源/"}]},{"title":"ActiveMQ在Mac上的安装","slug":"ActiveMQ在Mac上的安装","date":"2017-02-03T02:00:18.000Z","updated":"2017-02-03T02:13:42.000Z","comments":true,"path":"2017/02/03/ActiveMQ在Mac上的安装/","link":"","permalink":"http://yoursite.com/2017/02/03/ActiveMQ在Mac上的安装/","excerpt":"","text":"简单记录一下ActiveMQ在Mac上的安装。 具体指令使用的是brew 1brew install activemq // 此过程需要下载组件，速度依据网速 1activemq --version // 安装成功之后，可以查看一下版本进行检查 1activemq start // 启动 启动之后，可在浏览器中访问 http://localhost:8161/ 其他操作指令1234567891011121314151617181920Tasks: browse - Display selected messages in a specified destination. bstat - Performs a predefined query that displays useful statistics regarding the specified broker consumer - Receives messages from the broker create - Creates a runnable broker instance in the specified path. decrypt - Decrypts given text dstat - Performs a predefined query that displays useful tabular statistics regarding the specified destination type encrypt - Encrypts given text export - Exports a stopped brokers data files to an archive file list - Lists all available brokers in the specified JMX context producer - Sends messages to the broker purge - Delete selected destination's messages that matches the message selector query - Display selected broker component's attributes and statistics. start - Creates and starts a broker using a configuration file, or a broker URI. stop - Stops a running broker specified by the broker name.Task Options (Options specific to each task): --extdir &lt;dir&gt; - Add the jar files in the directory to the classpath. --version - Display the version information. -h,-?,--help - Display this help information. To display task specific help, use Main [task] -h,-?,--help","categories":[{"name":"MQTT","slug":"MQTT","permalink":"http://yoursite.com/categories/MQTT/"}],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://yoursite.com/tags/ActiveMQ/"}]},{"title":"摄像头捕捉红包","slug":"摄像头捕捉红包","date":"2017-01-19T01:34:00.000Z","updated":"2017-01-19T01:41:36.000Z","comments":true,"path":"2017/01/19/摄像头捕捉红包/","link":"","permalink":"http://yoursite.com/2017/01/19/摄像头捕捉红包/","excerpt":"","text":"类似于QQ里面的捉财神，开红包游戏。 https://github.com/zhangzhaopds/CatchRedPacket.git","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[]},{"title":"iOS中的感应器","slug":"iOS中的感应器","date":"2017-01-17T08:54:30.000Z","updated":"2017-01-17T09:08:45.000Z","comments":true,"path":"2017/01/17/iOS中的感应器/","link":"","permalink":"http://yoursite.com/2017/01/17/iOS中的感应器/","excerpt":"","text":"iOS中的感应器： ​ Accelerometer（加速器） ​ Gyroscope（陀螺仪） ​ Magnetometer（磁力计） ​ Proximity（距离感应） ​ Device motion ​ CMPedometer（计步器） https://github.com/zhangzhaopds/CMMotionManager_demo.git Proximity-距离感应123456789101112131415161718192021222324override func viewDidLoad() &#123; super.viewDidLoad() // 开启设备的距离感应(默认是关闭) UIDevice.current.isProximityMonitoringEnabled = true // 添加监听 NotificationCenter.default.addObserver(self, selector: #selector(proximityStateChanged), name: NSNotification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; // 销毁监听 deinit &#123; NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; // 监听回调 func proximityStateChanged() &#123; switch UIDevice.current.proximityState &#123; case true: print(\"物体靠近\") default: print(\"物体远离\") &#125; &#125; CoreMotion-加速器、陀螺仪、磁力计12// 导入CoreMotion框架import CoreMotion 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let motionManager = CMMotionManager() override func viewDidLoad() &#123; super.viewDidLoad() // 判断加速器是否可用 if !motionManager.isAccelerometerAvailable &#123; print(\"加速器不可用\") return &#125; // 采样间隔 motionManager.accelerometerUpdateInterval = 0.3 // 加速器采样 motionManager.startAccelerometerUpdates(to: OperationQueue.main) &#123; (accelerometerData, error) in if (error != nil) &#123; print(\"加速器采样错误：\\(error)\") return &#125; print(\"加速器采样数据：\\(accelerometerData)\") &#125; // 螺旋仪 if !motionManager.isGyroAvailable &#123; print(\"螺旋仪不可用\") return &#125; motionManager.gyroUpdateInterval = 0.3 motionManager.startGyroUpdates(to: OperationQueue.main) &#123; (gyroData, error) in if (error != nil) &#123; print(\"螺旋仪采样错误：\\(error)\") return &#125; print(\"螺旋仪数据：\\(gyroData)\") &#125; // 磁力计 if !motionManager.isMagnetometerAvailable &#123; print(\"磁力计不可用\") return &#125; motionManager.magnetometerUpdateInterval = 0.3 motionManager.startMagnetometerUpdates(to: OperationQueue.main) &#123; (magData, error) in if error != nil &#123; print(\"磁力计采样错误:\\(error)\") return &#125; print(\"磁力计数据：\\(magData)\") &#125; &#125; 摇一摇1234567891011121314override func motionBegan(_ motion: UIEventSubtype, with event: UIEvent?) &#123; super.motionBegan(motion, with: event) print(\"开始摇一摇\") &#125; override func motionCancelled(_ motion: UIEventSubtype, with event: UIEvent?) &#123; super.motionCancelled(motion, with: event) print(\"取消\") &#125; override func motionEnded(_ motion: UIEventSubtype, with event: UIEvent?) &#123; super.motionEnded(motion, with: event) print(\"结束摇一摇\") &#125; CMPedometer需先加入 Privacy - Motion Usage Description权限 12345678910111213if !CMPedometer.isStepCountingAvailable() &#123; print(\"计步器不可用\") return &#125; let pedometer = CMPedometer() pedometer.startUpdates(from: Date()) &#123; (data, error) in if error != nil &#123; print(error!) return &#125; print(data?.numberOfSteps ?? 0) &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"CoreMotion","slug":"CoreMotion","permalink":"http://yoursite.com/tags/CoreMotion/"},{"name":"感应器","slug":"感应器","permalink":"http://yoursite.com/tags/感应器/"}]},{"title":"ERROR:  While executing gem","slug":"ERROR-While-executing-gem","date":"2017-01-05T07:48:27.000Z","updated":"2017-01-05T07:53:26.000Z","comments":true,"path":"2017/01/05/ERROR-While-executing-gem/","link":"","permalink":"http://yoursite.com/2017/01/05/ERROR-While-executing-gem/","excerpt":"","text":"Gem和CocoaPods更新时的一个报错。 执行1sudo gem update cocoapods --pre 报错12ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj 解决1sudo gem update -n /usr/local/bin cocoapods","categories":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://yoursite.com/categories/Cocoapods/"}],"tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"http://yoursite.com/tags/cocoapods/"},{"name":"gem","slug":"gem","permalink":"http://yoursite.com/tags/gem/"}]},{"title":"逆向工程-微信自动抢红包","slug":"逆向工程-微信自动抢红包","date":"2017-01-04T08:30:02.000Z","updated":"2017-01-04T09:17:04.000Z","comments":true,"path":"2017/01/04/逆向工程-微信自动抢红包/","link":"","permalink":"http://yoursite.com/2017/01/04/逆向工程-微信自动抢红包/","excerpt":"","text":"微信自动抢红包。 依托于iOS重签名开源框架 ios-app-signer 项目源码地址: https://github.com/codesourse/iInjection 注：如果iTunes安装不成功的话，可尝试用OTA(亲测，好用)。 效果图","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/categories/逆向工程/"}],"tags":[{"name":"逆向工程、iOS_App_resign、微信红包","slug":"逆向工程、iOS-App-resign、微信红包","permalink":"http://yoursite.com/tags/逆向工程、iOS-App-resign、微信红包/"}]},{"title":"npm missing package.json","slug":"npm缺少package异常","date":"2016-12-30T08:58:57.000Z","updated":"2016-12-30T09:03:40.000Z","comments":true,"path":"2016/12/30/npm缺少package异常/","link":"","permalink":"http://yoursite.com/2016/12/30/npm缺少package异常/","excerpt":"","text":"在执行 npm install &lt;模块&gt;时，出现找不到文件路径 package.json等报错。 报错 123456789zhangzhao:util zhangzhao$ npm install n-crypto/Users/zhangzhao└── n-crypto@0.2.1 npm WARN enoent ENOENT: no such file or directory, open '/Users/zhangzhao/package.json'npm WARN zhangzhao No descriptionnpm WARN zhangzhao No repository field.npm WARN zhangzhao No README datanpm WARN zhangzhao No license field. 解决1npm install -g --save n-crypto 参考地址：[https://github.com/npm/npm/issues/9161","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"}],"tags":[{"name":"WARN","slug":"WARN","permalink":"http://yoursite.com/tags/WARN/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"package","slug":"package","permalink":"http://yoursite.com/tags/package/"}]},{"title":"Vapor实现Swift的Server搭建","slug":"Vapor实现Swift的Server搭建","date":"2016-12-29T02:19:06.000Z","updated":"2016-12-29T03:20:59.000Z","comments":true,"path":"2016/12/29/Vapor实现Swift的Server搭建/","link":"","permalink":"http://yoursite.com/2016/12/29/Vapor实现Swift的Server搭建/","excerpt":"","text":"利用开源框架Vapor搭建Swift语言的服务器。 本文翻译自：https://www.bignerdranch.com/blog/server-side-swift-with-vapor/ 一、准备工作1、Xcode 和 Swift第一件事就是下载最新的Xcode版本，其支持Swift3。 2、Vapor第二件事就是安装Vapor和它的toolbox; Vapor的官方文档：https://vapor.github.io/documentation/getting-started/install-swift-3-macos.html 具体的安装指令： 1curl -sL check.vapor.sh | bash 1curl -sL toolbox.vapor.sh | bash 注意： 第一条指令是为了验证Xcode的安装是否正确，可能会提醒设置Xcode的 Command Line Tools： 第二条指令是为了安装toolbox工具，Xcode一定要处于打开状态，不然会有类似No such file or directory的报错。 3、Postgres使用Postgres作为数据库。 如果已经安装了Homebrew,则可以执行下面的指令安装Postgres数据库； 1brew install postgres 4、Heroku在Heroku上面部署自己的云服务器。 需要注册，官网地址：https://dashboard.heroku.com/apps; 下载安装Heroku的Command Line: 地址：https://devcenter.heroku.com/articles/heroku-cli 二、创建Vapor项目以下指令创建了一个名为 Friends 的App，创建过程较慢，耐心等待。 1vapor new Friends App创建成功之后，cd 到 Hello文件，执行以下指令，便可在Xcode中打开并运行项目。这个过程更加漫长。。。 1vapor xcode -y 1、打开默认文件路径: http://localhost:8080在打开的工程中，导航至 Sources/App/main.swift， 看到的代码如下： 12345678910111213import Vaporlet drop = Droplet()drop.get &#123; req in return try drop.view.make(\"welcome\", [ \"message\": drop.localization[req.lang, \"welcome\", \"title\"] ])&#125;drop.resource(\"posts\", PostController())drop.run() 这个文件导入了Vapor框架，初始化一个Droplet类型对象，和添加了一个默认路径； 配置Xcode,如下，并Command+R运行： 在浏览器中打开 http://localhost:8080, 2、创建一个新的访问路径: http://localhost:8080/friends同样实在main.swift文件中操作，具体添加后的代码如下： 1234567891011121314151617181920import Vaporlet drop = Droplet()drop.get &#123; req in return try drop.view.make(\"welcome\", [ \"message\": drop.localization[req.lang, \"welcome\", \"title\"] ])&#125;drop.get(\"friends\") &#123; req in return try JSON(node: [\"friends\": [[\"name\": \"Sarah\", \"age\": 33], [\"name\": \"Steve\", \"age\": 31], [\"name\": \"Drew\", \"age\": 35]] ])&#125;drop.resource(\"posts\", PostController())drop.run() friends路径接受get请求，返回一组json数据。浏览器访问效果如下： 3、创建一个Friend类型的Model在Sources/App/Models下创建一个Friend.swift文件: 1234567891011struct Friend &#123; let name: String let age: Int let email: String init(name: String, age: Int, email: String) &#123; self.name = name self.age = age self.email = email &#125;&#125; 注意：添加了一个email属性 Vapor提供了Model协议来保存model类型，同时也提供了方法来实现model到json的转换。为了结构体Friend遵从Model协议，我们需要导入在Friend.swift中导入Vapor库。 导入Vapor库的同时也意味着导入了Fluent库 。Fluent是针对Swift，处理众多数据库的对象关系映射工具（object relational mapping）。在这里我们使用它来处理我们的Postgres数据库。 注意：当看到Xcode导入Vapor库之后，可能会看到报错，此时返回终端，重新执行 vapor xcode -y; 最终的Friend.swift文件应该是下面的样子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Foundationimport Vaporstruct Friend: Model &#123; var exists: Bool = false var id: Node? let name: String let age: Int let email: String init(name: String, age: Int, email: String) &#123; self.name = name self.age = age self.email = email &#125; // NodeInitializable init(node: Node, in context: Context) throws &#123; id = try node.extract(\"id\") name = try node.extract(\"name\") age = try node.extract(\"age\") email = try node.extract(\"email\") &#125; // NodeRepresentable func makeNode(context: Context) throws -&gt; Node &#123; return try Node(node: [\"id\": id, \"name\": name, \"age\": age, \"email\": email]) &#125; // Preparation static func prepare(_ database: Database) throws &#123; try database.create(\"friends\") &#123; friends in friends.id() friends.string(\"name\") friends.int(\"age\") friends.string(\"email\") &#125; &#125; static func revert(_ database: Database) throws &#123; try database.delete(\"friends\") &#125;&#125; 第一件事是我们要实现Model协议。意味着，我们需要一个Node?类型的id属性；id的值在保存到数据库之前是nil。Friend同时有一个默认值为false的exists的属性，这个属性展示的是从数据库中是否获取到实例对象（This property details whether or not the instance was retrieved from the database and should not be interacted with directly.）。 同时，我们还需要实现其他的协议。NodeInitializable，NodeRepresentable和Preparation。其中，前两个协议 的实现是因为 Model协议继承于Entity协议。第一个协议告诉我们怎样从数据库中初始化model；第二个协议是怎样保存model到数据库中。第三个协议是怎样创建数据库。 接下来，我们在main.swift中利用上面的Friend,在新的路径 friends下创建一个json,如下： 12345678drop.get(\"friends\") &#123; req in let friends = [Friend(name: \"Sarah\", age: 33, email:\"sarah@email.com\"), Friend(name: \"Steve\", age: 31, email:\"steve@email.com\"), Friend(name: \"Drew\", age: 35, email:\"drew@email.com\")] let friendsNode = try friends.makeNode() let nodeDictionary = [\"friends\": friendsNode] return try JSON(node: nodeDictionary)&#125; 我们创建了一个包含三个Friend对象的friends数组。之后数组调用makeNode()方法转换成一个Node。之后的字典和json结果。 重新运行Command+R，在浏览器中访问http://localhost:8080/friends，即可看到效果。 4、配置Postgres数据库设置Postgres涉及几个步骤： 在Package.swift中为Postgres添加一个provider； 在main.swift中导入provider，用Droplet来使用它； 配置我们的app使用Postgres； 获取一个provider postgres-provider是一个优秀的provider。在Package.swift添加这个依赖。 1234567891011121314151617import PackageDescriptionlet package = Package( name: \"Friends\", dependencies: [ .Package(url: \"https://github.com/vapor/vapor.git\", majorVersion: 1, minor: 1), .Package(url: \"https://github.com/vapor/postgresql-provider\", majorVersion: 1, minor: 0) ], exclude: [ \"Config\", \"Database\", \"Localization\", \"Public\", \"Resources\", \"Tests\", ]) 之后，在终端执行 vapor xcode -y。 导入provider打开main.swift，准备使用数据库Postgres。当然需要先安装Postgres。 Postgres地址：https://github.com/vapor/postgresql MacOS上的Postgres安装使用指令： 123456brew install postgresqlbrew link postgresqlbrew services start postgresql// to stop brew services stop postgresql 注：我在Mac上brew install postgresql时出现404报错，导致Postgres安装失败，所以接下来的内容就没办法跟着原文继续实现。 首先，导入 VaporPostgreSQL; 其次，为Droplet的preparations添加Friend.self ; 最后，drop.addProvider(VaporPostgreSQL.Provider.self),添加porvider到drop以使用数据库。 在工程中配置Progres在工程的Config文件夹下创建 secrets文件夹，并在secrets下创建 postgresql.json。最终的路径应该是这样的 Config/secrets/postgresql.json;而postgresql.json中内容如下： 1234567&#123; \"host\": \"127.0.0.1\", \"user\": \"DubbaDubs\", \"password\": \"\", \"database\": \"friends\", \"port\": 5432&#125; 注意：user要用你自己的；friends只是我们生命的一个数据库，仍旧需要创建它。 使用Protgres接下来，我们创建一个新的路径，执行POST方法，将Friend数据保存到数据库； 1234567891011121314151617181920212223242526272829303132333435import Vaporimport VaporPostgreSQLlet drop = Droplet()drop.preparations.append(Friend.self)do &#123; try drop.addProvider(VaporPostgreSQL.Provider.self)&#125; catch &#123; print(\"Error adding provider: \\(error)\")&#125;drop.get &#123; req in return try drop.view.make(\"welcome\", [ \"message\": drop.localization[req.lang, \"welcome\", \"title\"] ])&#125;drop.get(\"friends\") &#123; req in let friends = [Friend(name: \"Sarah\", age: 33, email:\"sarah@email.com\"), Friend(name: \"Steve\", age: 31, email:\"steve@email.com\"), Friend(name: \"Drew\", age: 35, email:\"drew@email.com\")] let friendsNode = try friends.makeNode() let nodeDictionary = [\"friends\": friendsNode] return try JSON(node: nodeDictionary)&#125;drop.post(\"friend\") &#123; req in var friend = try Friend(node: req.json) try friend.save() return try friend.makeJSON()&#125;drop.resource(\"posts\", PostController())drop.run() 这个POST路径的body，类似下面： 12345&#123; \"name\": \"Some Name\", \"age\": 30, \"email\": \"email@email.com\"&#125; 我们尝试用req.json创建一个Friend类型的实例对象,作为POST请求发送出去； 之后，调用friend.save()将对象保存到数据库； 关于friend为什么用 Var .save()的理解：friend中有一个在保存到数据库之前是nil的id属性，这里的作用就是当成功保存到数据后，在回调中修正这个id的值。 我们仍旧需要创建数据库 1postgres -D /usr/local/var/postgres/ 在终端执行上面的指令，Protgres 服务将在本地运行；一旦服务开始运行，我们就可以创建数据库。 在新的终端窗口，执行 12createdb friendspsql 之后，可以输入 \\l来查看数据库列表，应该就可以看到你的friends数据库。 最后，你可以利用POSTMAN等工具发送一个post请求，测试一下。 然后用 psql来确认你发送数据到数据库了。 You can test this new route by building and running your app within Xcode as you did above and using curl or a tool like Postman. You can use psql to verify that you are posting data to the database. From inside the command line interface, type \\c friends to connect to your friends database. Next, type SELECT * FROM friends; and hit enter. You should see the information for the friend that you just POSTed to the &quot;friend&quot; route. Removing Hardcoded DataGET requests to our &quot;friends&quot; currently return hardcoded data. But we can POSTfriends to our database now! Go ahead and POST a few more friends to your database to fill it out a little more. Back in main.swift, let’s update our &quot;friends&quot; route to return the data in our database. That method should now look like this: 12345drop.get(\"friends\") &#123; req in let friends = try Friend.all().makeNode() let friendsDictionary = [\"friends\": friends] return try JSON(node: friendsDictionary)&#125; Visit http://localhost:8080/friends in your browser or send a GET request via Postman and you should see your friends returned to you. GETting by idAdd a new route to main.swift that will use a user’s id to find an entry in the database. 123456drop.get(\"friends\", Int.self) &#123; req, userID in guard let friend = try Friend.find(userID) else &#123; throw Abort.notFound &#125; return try friend.makeJSON()&#125; The above will match a route that will end in something like, .../friends/1, where the integer at the end is the friend’s id. Notice that we use Int.self as the second argument in the path. This means that we can have type safe parameters in our routes! In Vapor, there is no need to cast this parameter from a String to an Int. We can express exactly what we need. The userID parameter in the closure will match the integer passed at the end of the route. Also, through the power of Fluent, we can simply find(_:) the instance of our model by its id. Since this lookup can fail, we must try. If we fail to find a Friend, we’ll throw the error Abort.notFound. Otherwise, we makeJSON() from the friend we found and return. Go ahead and try it out! 部署到 HerokuAll that is left to do is to deploy to Heroku. Vapor makes this process very easy. Heroku works with Git, so you should make sure that you have that installed as well. Create a Git repository and commit your files. 123git initgit add .git commit -m \"Initial commit\" Now, all you need to do is create a Heroku instance and push to it. 1vapor heroku init The Heroku CLI will ask four questions: Would you like to provide a custom Heroku app name? Answer ‘n’ and hit enter if you don’t have a custom name. Would you like to provide a custom Heroku buildpack? Answer ‘n’ and hit enter if you would like to use the default buildpack that Heroku provides. Are you using a custom Executable name? Answer ‘n’ and hit enter here if you aren’t using a custom executable name. Would you like to push to Heroku now? Answer ‘n’ and hit enter. We need to answer ‘no’ because we need to configure our database to work online. We’ll do that below. Before you plug the URL you see in your Terminal output into your browser of choice, we need to provision a Postgres add-on on Heroku. Type the following in your Terminal to add Postgres to your app. 1heroku addons:create heroku-postgresql:hobby-dev Adding the database can take up to five minutes to provision. Once it is ready, you can type heroku config in Terminal to see your database’s URL to confirm that the add-on was provisioned. Now, we need to update our app’s Procfile, which was created via vapor heroku init, to use the DATABASE_URL environment variable that was created by Heroku. Open the Procfile in your text editor and update it so that looks like the below. 12web: App --env=production --workdir=\"./\"web: App --env=production --workdir=./ --config:servers.default.port=$PORT --config:postgresql.url=$DATABASE_URL Notice that we added a new configuration so that Heroku knows to use our database’s URL on the web and not the instance we have been running locally: --config:postgresql.url=$DATABASE_URL. Save the Procfile and type git push heroku master in Terminal to deploy your app. Deploying will take a few minutes. Heroku needs to build your application, install Swift on your Heroku instance, and so on. After some time, your app will be live on the web. Note that we didn’t push up the data from the local database to the remote database. You will have to exercise your app’s API to add some data to your database on Heroku. Making ChangesMaking changes is easy! Simply write your code, commit the changes, and push them up to Heroku. 12git commit -am \"Adds new code\"git push heroku master Wrapping UpThis post covered a lot of ground: We downloaded a number of tools. Introduced Vapor. Wrote a small web app. Developed an API to read and write some data to Postgres. Finally, we deployed the app to Heroku. This post is intended to you get started with server-side Swift. To that end, we introduced Vapor and explored some of its features. But this introduction just scratches the surface; there is a lot more to Vapor. What’s exciting is that server-side Swift is moving fast! Stay tuned here for more posts on the subject. ChallengesIf you’re looking for more to do on your own, try your hand at these extra challenges. Create a route to DELETE a friend from the database. Create a route to PATCH a friend on the database.","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Postgres","slug":"Postgres","permalink":"http://yoursite.com/tags/Postgres/"},{"name":"Swift服务器","slug":"Swift服务器","permalink":"http://yoursite.com/tags/Swift服务器/"},{"name":"Vapor","slug":"Vapor","permalink":"http://yoursite.com/tags/Vapor/"}]},{"title":"Protocol","slug":"Swift中协议的简单介绍","date":"2016-12-27T02:19:06.000Z","updated":"2016-12-27T02:21:36.000Z","comments":true,"path":"2016/12/27/Swift中协议的简单介绍/","link":"","permalink":"http://yoursite.com/2016/12/27/Swift中协议的简单介绍/","excerpt":"","text":"Swift中协议的简单介绍 http://www.cocoachina.com/swift/20161219/18376.html","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"protocol","slug":"protocol","permalink":"http://yoursite.com/tags/protocol/"}]},{"title":"OTA部署","slug":"iOS中的OTA部署","date":"2016-12-26T06:28:47.000Z","updated":"2016-12-26T06:36:48.000Z","comments":true,"path":"2016/12/26/iOS中的OTA部署/","link":"","permalink":"http://yoursite.com/2016/12/26/iOS中的OTA部署/","excerpt":"","text":"利用XC Ad Hoc: *类型的Provisioning Profile打包ipa文件，并部署到HTTPS的局域网内，提供内部人员下载安装。 内网中HTTPS环境搭建http://zhangzhaopds.github.io/2016/12/26/Mac中开启Apache的Https功能/ OTA具体部署http://www.jianshu.com/p/bd016015efe7","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"OTA部署","slug":"OTA部署","permalink":"http://yoursite.com/tags/OTA部署/"}]},{"title":"Mac中开启Apache的Https功能","slug":"Mac中开启Apache的Https功能","date":"2016-12-26T05:22:26.000Z","updated":"2016-12-26T06:16:17.000Z","comments":true,"path":"2016/12/26/Mac中开启Apache的Https功能/","link":"","permalink":"http://yoursite.com/2016/12/26/Mac中开启Apache的Https功能/","excerpt":"","text":"为Mac中自带的Apache开启Https功能，证书是自签名的证书。 以下内容是针对已经配置过Apache，能够利用 http://localhost打开网页的基础上的设置。 配置SSL在终端创建SSL路径 1sudo mkdir /etc/apache2/ssl 接下来创建一个私钥key和证书 12sudo openssl genrsa -out /etc/apache2/ssl/server.key 2048sudo openssl req -new -x509 -key /etc/apache2/ssl/server.key -out /etc/apache2/ssl/server.crt -days 3650 -subj /CN=localhost 最后，添加证书到钥匙串并信任改证书 1sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /etc/apache2/ssl/server.crt 配置SSL虚拟主机1、在终端，编辑httpd.conf1sudo vi /etc/apache2/httpd.conf 找到下面三行， 在英文输入状态下，点击i,进入编辑状态，并将前面的 # 去掉，去掉#之后，control+c退出编辑，再执行:wq回到终端。 1LoadModule socache_shmcb_module libexec/apache2/mod_socache_shmcb.so 1LoadModule ssl_module libexec/apache2/mod_ssl.so 1Include /private/etc/apache2/extra/httpd-ssl.conf 2、在终端，编辑httpd-vhosts.conf1sudo vi /etc/apache2/extra/httpd-vhosts.conf 添加端口443的虚拟主机 注意： ServerName 字段要和 .crt证书生成时的CN（CommonName）字段相一致（可以是域名，也可以是IP，建议用IP），即本例中的 ServerName localhost与CN=localhost 1234567891011121314151617&lt;VirtualHost *:443&gt; ServerName localhost DocumentRoot \"/Users/indieweb/Sites/localhost\" SSLEngine on SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULL SSLCertificateFile /etc/apache2/ssl/server.crt SSLCertificateKeyFile /etc/apache2/ssl/server.key &lt;Directory \"/Users/indieweb/Sites/localhost\"&gt; Options Indexes FollowSymLinks AllowOverride All Order allow,deny Allow from all Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 回到终端，执行 1sudo vi /etc/apache2/extra/httpd-vhosts.conf 配置SSLCertificateFile和SSLCertificateKeyFile文件路径 1SSLCertificateFile \"/etc/apache2/ssl/server.crt\" 1SSLCertificateKeyFile \"/etc/apache2/ssl/server.key\" 回到终端，执行以下指令，如果出现Syntax OK，则代表配置成功 1sudo apachectl configtest 最后，重启Apache 1sudo apachectl restart 如果一切顺利的话，就可以在浏览器中打开 https://localhost 到此就完成配置了。 局域网内的HTTPS配置如果想让局域网内的其他浏览器打开你的网页，则需要将 ServerName和CommonName设置成你的电脑的IP，当然证书都需要重新生成并替换； 同时访问地址变为：https://你的ip地址 注意：要想在iPhone的Safari中访问这个站点，首先ServerName和CommonName一定是IP地址，其次手机要事先安装你生成的server.crt证书，不然Safari会一直处于尝试访问这个的站点的状态，即一闪一闪的现象。 相关链接https://gist.github.com/jonathantneal/774e4b0b3d4d739cbc53","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"},{"name":"Https","slug":"Https","permalink":"http://yoursite.com/tags/Https/"}]},{"title":"@escaping","slug":"escaping","date":"2016-12-23T01:19:55.000Z","updated":"2016-12-23T01:26:00.000Z","comments":true,"path":"2016/12/23/escaping/","link":"","permalink":"http://yoursite.com/2016/12/23/escaping/","excerpt":"","text":"Swift中的逃逸闭包（escape closure）。 逃逸闭包​ 当一个传入函数的闭包在函数执行结束之后才会被调用，这样的闭包就叫做逃逸闭包。如果一个函数的参数有一个逃逸闭包，可以在参数前加@escaping关键字来修饰。 ​ 一个闭包是逃逸必要的条件是这个闭包需要存储在函数外部。举个例子，很多异步操作的函数往往会传入一个complete handler作为异步操作完成后的回调。当这个异步函数开始执行的时候，会开启一个异步操作，然后这个函数就直接结束了，此时，传入的闭包还没有被执行，实际上这个回调需要在异步操作完成后才会被执行。这种情况下这个回调的闭包需要定义成逃逸闭包，因为它在函数调用结束之后才会被执行。比如下面的例子： 1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; ​ someFunctionWithEscapingClosure以一个completionHandler作为参数，这个参数会被保存在函数外部的completionHandlers数组中，这时这个闭包是一个逃逸闭包，所以需要添加@escaping关键字去修饰，否则会有编译错误。 ​ 逃逸闭包如果需要使用对象的变量或常量的时候，必须显示指明self，如果是普通的闭包，可以直接使用对象的变量或常量。比如下面的例子： 12345678910111213141516171819202122232425var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125;func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x)// 输出 \"200\"completionHandlers.first?()print(instance.x)// 输出 \"100\" ​ 在这个例子中，第一个print输出200，因为当调用doSomethig的时候，someFunctionWithNonescapingClosure会直接调用闭包{x = 200},此时instance.x变成200，当completionHandlers.first?()之后，someFunctionWithEscapingClosure传入的闭包才会真正执行，此时instance.x变成100.可以看到，逃逸闭包必须显示指明self，而普通的闭包可以直接使用x。 http://1199game.com/2016/10/Swift-closure-3/","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Closure","slug":"Closure","permalink":"http://yoursite.com/tags/Closure/"},{"name":"Escaping","slug":"Escaping","permalink":"http://yoursite.com/tags/Escaping/"}]},{"title":"斗鱼","slug":"斗鱼","date":"2016-12-20T06:56:10.000Z","updated":"2016-12-20T06:59:58.000Z","comments":true,"path":"2016/12/20/斗鱼/","link":"","permalink":"http://yoursite.com/2016/12/20/斗鱼/","excerpt":"","text":"逆向工程，高仿斗鱼直播，持续更新中。 https://github.com/zhangzhaopds/Douyu","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"斗鱼直播","slug":"斗鱼直播","permalink":"http://yoursite.com/tags/斗鱼直播/"},{"name":"高仿","slug":"高仿","permalink":"http://yoursite.com/tags/高仿/"}]},{"title":"GPUImage图像处理","slug":"GPUImage图像处理","date":"2016-12-07T08:31:34.000Z","updated":"2016-12-07T08:48:13.000Z","comments":true,"path":"2016/12/07/GPUImage图像处理/","link":"","permalink":"http://yoursite.com/2016/12/07/GPUImage图像处理/","excerpt":"","text":"GPUImage是Git上一个非常强大的图像处理框架，现有的滤镜将近200种，还可以自定义新的滤镜。 链接GPUImage https://github.com/BradLarson/GPUImage 简单Demo https://github.com/zhangzhaopds/GPUImage_Demo.git 滤镜效果图（部分）GPUImageZoomBlurFilter GPUImageNonMaximumSuppressionFilter GPUImageSketchFilter GPUImageTransformFilter","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"GPUImage","slug":"GPUImage","permalink":"http://yoursite.com/tags/GPUImage/"},{"name":"滤镜","slug":"滤镜","permalink":"http://yoursite.com/tags/滤镜/"}]},{"title":"直播弹幕BarrageRenderer","slug":"直播弹幕BarrageRenderer","date":"2016-12-06T07:29:28.000Z","updated":"2016-12-06T07:39:08.000Z","comments":true,"path":"2016/12/06/直播弹幕BarrageRenderer/","link":"","permalink":"http://yoursite.com/2016/12/06/直播弹幕BarrageRenderer/","excerpt":"","text":"一个封装的不错的弹幕框架 BarrageRenderer。 https://github.com/unash/BarrageRenderer https://github.com/zhangzhaopds/BarrageRenderer_demo.git","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"BarrageRenderer","slug":"BarrageRenderer","permalink":"http://yoursite.com/tags/BarrageRenderer/"},{"name":"直播弹幕","slug":"直播弹幕","permalink":"http://yoursite.com/tags/直播弹幕/"}]},{"title":"IJKPlayer视频直播框架","slug":"IJKPlayer视频直播框架","date":"2016-12-05T06:37:39.000Z","updated":"2016-12-05T07:53:31.000Z","comments":true,"path":"2016/12/05/IJKPlayer视频直播框架/","link":"","permalink":"http://yoursite.com/2016/12/05/IJKPlayer视频直播框架/","excerpt":"","text":"IJKPlayer是B站的一个开源视频播放框架，基于FFMPEG; 集成的过程较为繁琐，记录一下。 集成按照官方教程一步一步来就行，官网链接https://github.com/Bilibili/ijkplayer 这篇博客写得也很详细，http://www.jianshu.com/p/4f21af680c19 这个我打包好的静态库，下载解压拖到工程、添加依赖库就能用：http://ohp8q40k9.bkt.clouddn.com/IJK.zip iOS的集成主要有以下几步骤： 在本地创建一个文件夹，在Terminal中，cd到文件夹，执行git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-ios； 继续执行cd ijkplayer-ios； 执行git checkout -B latest k0.7.5，开辟新的分支latest； 执行./init-ios.sh,这个过程较慢，因为要下载180MB左右的文件； cd ios; ./compile-ffmpeg.sh clean； ./compile-ffmpeg.sh all,这个过程也较慢；最终效果： 打开工程IJKMediaDemo, 在plist中添加 Camera 和 Photo的系统应用权限；之后编译和运行应该都没问题。 静态库的打包基于上面已经能够成功运行的工程，将IJKPlayer打包成方便使用的framework; 选择 IJKMediaFramework — Edit Scheme — Run — Buid Configuration — Release; 将 IJKMediaFramework 分别在模拟器和真机下编译 command + B; 打开Products下的 IJKMediaFramework.framework, 可以看到Release-iphonesimulator和Release-iphoneos； 将模拟器和真机的两个静态库合并；到文件夹/Build/Products，例如：cd /Users/zhangzhao/Library/Developer/Xcode/DerivedData/IJKMediaDemo-bwancsljxxihfseajvayxkzkonhi/Build/Products 在Products下执行 lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework合并； 之后执行copy操作，cp IJKMediaFramework Release-iphoneos/IJKMediaFramework.framework/; 静态库iphoneos/IJKMediaFramework.framework就是最终的结果。 使用 添加IJKMediaFramework.framework到新建的项目中； 添加依赖 编译的时候出现的以下的报错就是依赖库没添加全","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"IJKPlayer","slug":"IJKPlayer","permalink":"http://yoursite.com/tags/IJKPlayer/"},{"name":"视频直播框架","slug":"视频直播框架","permalink":"http://yoursite.com/tags/视频直播框架/"}]},{"title":"OCR:基于OpenCV、Tesseract的银行卡号识别","slug":"OCR-基于OpenCV、Tesseract的银行卡号识别","date":"2016-12-01T08:50:30.000Z","updated":"2016-12-01T09:28:48.000Z","comments":true,"path":"2016/12/01/OCR-基于OpenCV、Tesseract的银行卡号识别/","link":"","permalink":"http://yoursite.com/2016/12/01/OCR-基于OpenCV、Tesseract的银行卡号识别/","excerpt":"","text":"由于银行卡的卡面背景色彩千差万别，并且卡号的印制方式（平印、凸印）也不相同，所以这种识别方式的效果并不理想，可以说很差，暂时对平印的单一色彩的银行卡的识别效果还行； 这种方式可以用来做身份证的识别，效果很好，因为身份证背景颜色浅，而且样式一致。 效果图： 本文Demohttps://github.com/zhangzhaopds/OCR_OpenCV_Tesseract_demo.git 思路1、对预览图进行初步的手动裁剪，缩小OpenCV的处理范围； 2、利用OpenCV对图片进行初步的处理，包括灰度化处理、二阈值处理、膨胀处理等； 3、利用TesseractIOSOCR进行图片的文字识别； 主要实现依赖库： pod &#39;OpenCV&#39;, &#39;~&gt; 3.0.0&#39;pod &#39;TesseractOCRiOS&#39;, &#39;~&gt; 4.0.0&#39; 实现（代码中有解释）： 图片的剪裁、识别与结果处理:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 图片的剪裁、识别与结果处理- (void)detecteCardWithImage:(UIImage *)cardImage compleate:(CompleteBlock)complete &#123; /** 相对于身份证来说，银行卡片的背景环境千差万别，有的卡片无需处理而有的则需要灰度值或二阈值重新处理，用一种方式处理千百种环境，结果可想而知； 这里的话就简单的，在图片的不同处理阶段进行多次的文字识别，最后在统一处理； 第一次：卡号所在位置的图片截取之后，进行识别； 第二次：灰度值处理之后，进行识别； 第三次：二阈值处理之后，进行识别； 第四次：腐蚀化重新截图并灰度值处理之后，进行识别； 第五次：腐蚀化重新截图、灰度值并二阈值处理之后，进行识别； */ // 将卡号所在的大致位置在图片上截取出来，缩小OpenCV要识别的图片范围，认为的提高识别效率。 UIImage *corpImage = [self cropImageFromImage:cardImage]; if (corpImage == nil) &#123; complete(nil); return; &#125; // 识别结果的初步处理 __weak typeof(self) weakSelf = self; self.myBlock = ^(NSString *res) &#123; // 信用卡16位，储蓄卡19位 if (res.length &lt; 16) &#123; return; &#125; NSString *result = [weakSelf findNumFromStr:res]; NSLog(@\"🔥%@\", result); if (result.length &lt; 16) &#123; return; &#125; complete(result); &#125;; // 第一次识别： [self tesseractDetectorWithImage: corpImage withComplete:^(NSString *result) &#123; NSLog(@\"第一次识别：%@\", result); weakSelf.myBlock(result); &#125;]; // 利用OpenCV，对截取出来的图片进一步处理,并进行类外四次的识别 [self opencvScanCard:corpImage]; &#125; 因为识别的次数增多，所以结果的反馈较慢，可相应减少识别次数。 利用OpenCV对图片的进一步处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (void)opencvScanCard:(UIImage *)image &#123; // 图片转换 cv::Mat resultImage; UIImageToMat(image, resultImage); // 灰度处理（去除图片的色彩和光亮） cvtColor(resultImage, resultImage, cv::COLOR_BGR2GRAY); // 第二次识别： __weak typeof(self) weakSelf = self; [self tesseractDetectorWithImage: MatToUIImage(resultImage) withComplete:^(NSString *result) &#123; NSLog(@\"第二次识别：%@\", result); weakSelf.myBlock(result); &#125;]; // 二阈值处理 cv::threshold(resultImage, resultImage, 100, 255, CV_THRESH_BINARY); // 第三次识别： [self tesseractDetectorWithImage: MatToUIImage(resultImage) withComplete:^(NSString *result) &#123; NSLog(@\"第三次识别：%@\", result); weakSelf.myBlock(result); &#125;]; // 腐蚀：白色背景缩小，黑色扩大 cv::Mat erodeElement = getStructuringElement(cv::MORPH_RECT, cv::Size(25,25)); //3535 cv::erode(resultImage, resultImage, erodeElement); UIImage *ccc = MatToUIImage(resultImage); UIImageWriteToSavedPhotosAlbum(ccc, nil, nil, nil); // 轮廊检测 std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours; cv::findContours(resultImage, contours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cvPoint(0, 0)); // 取出卡号区域 std::vector&lt;cv::Rect&gt; rects; cv::Rect numberRect = cv::Rect(0,0,0,0); std::vector&lt;std::vector&lt;cv::Point&gt;&gt;::const_iterator itContours = contours.begin(); for ( ; itContours != contours.end(); ++itContours) &#123; cv::Rect rect = cv::boundingRect(*itContours); rects.push_back(rect); if (rect.width &gt; numberRect.width &amp;&amp; rect.width &gt; rect.height * 5) &#123; numberRect = rect; &#125; &#125; if (numberRect.width == 0 || numberRect.height == 0) &#123; NSLog(@\"定位失败\"); return; &#125; // 定位成功，重新截图 cv::Mat matImage; UIImageToMat(image, matImage); resultImage = matImage(numberRect); // 第二次灰度值处理 cvtColor(resultImage, resultImage, cv::COLOR_BGR2GRAY); // 第四次识别： [self tesseractDetectorWithImage: MatToUIImage(resultImage) withComplete:^(NSString *result) &#123; NSLog(@\"第四次识别：%@\", result); weakSelf.myBlock(result); &#125;]; // 第二次二阈值处理 cv::threshold(resultImage, resultImage, 100, 255, CV_THRESH_BINARY); // 第五次识别： [self tesseractDetectorWithImage: MatToUIImage(resultImage) withComplete:^(NSString *result) &#123; NSLog(@\"第五次识别：%@\", result); weakSelf.myBlock(result); &#125;];&#125; Tesseract识别12345678910// Tesseract识别- (void)tesseractDetectorWithImage:(UIImage *)img withComplete:(CompleteBlock)complete &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^&#123; G8Tesseract *tesseract = [[G8Tesseract alloc] initWithLanguage:@\"eng\"]; tesseract.image = [img g8_blackAndWhite]; tesseract.image = img; [tesseract recognize]; complete(tesseract.recognizedText); &#125;);&#125; 银行卡片的初次裁剪1234567891011121314151617181920212223242526272829303132// 裁剪银行卡号- (UIImage *)cropImageFromImage:(UIImage *)img &#123; static CGFloat cardWidth = 400; static CGFloat cardHeight = 400/1.59; CGFloat h = img.size.height * 500 / img.size.width; UIGraphicsBeginImageContext(CGSizeMake(500, h)); [img drawInRect:CGRectMake(0, 0, 500, h)]; UIImage *scaleImg = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGFloat y = (scaleImg.size.height - cardHeight) / 2; CGImageRef sourceImageRef = [scaleImg CGImage]; CGImageRef newImageRef = CGImageCreateWithImageInRect(sourceImageRef, CGRectMake(50, y, cardWidth, cardHeight)); CGImageRef resultImgRef = CGImageCreateWithImageInRect(newImageRef, CGRectMake(0, 130, cardWidth, 50)); UIImage *mm = [UIImage imageWithCGImage:resultImgRef]; /** static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"%@\", scaleImg); NSLog(@\"%@\", [UIImage imageWithCGImage:newImageRef]); NSLog(@\"%@\", mm); UIImageWriteToSavedPhotosAlbum(scaleImg, nil, nil, nil); UIImageWriteToSavedPhotosAlbum([UIImage imageWithCGImage:newImageRef], nil, nil, nil); UIImageWriteToSavedPhotosAlbum(mm, nil, nil, nil); &#125;) */ return mm;&#125; 调用1234567- (void)clickedDetecteBtn:(UIButton *)sender &#123; //【点击事件中调用图片识别，防止CPU飙升】 [[DetectorManager shareInstance] detecteCardWithImage:self.myImage compleate:^(NSString *result) &#123; NSLog(@\"识别结果：%@\", result); &#125;];&#125; 参考文献OpenCV教程-http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html SwiftOCR教程-https://github.com/garnele007/SwiftOCR.git Tesseract教程-https://github.com/tesseract-ocr/tesseract.git http://www.jianshu.com/p/7462275f93ac https://github.com/iosWellLin/OCR.git","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"OCR","slug":"OCR","permalink":"http://yoursite.com/tags/OCR/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"Tesseract","slug":"Tesseract","permalink":"http://yoursite.com/tags/Tesseract/"}]},{"title":"iOS中基于CIDetector的人脸识别","slug":"iOS中基于CIDetector的人脸识别","date":"2016-11-28T06:10:07.000Z","updated":"2016-11-28T06:27:08.000Z","comments":true,"path":"2016/11/28/iOS中基于CIDetector的人脸识别/","link":"","permalink":"http://yoursite.com/2016/11/28/iOS中基于CIDetector的人脸识别/","excerpt":"","text":"CIDetector是iOS中自带的人脸识别框架，使用起来相对方便。 效果图 本文Demohttps://github.com/zhangzhaopds/CIDetector_demo.git 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 人脸识别- (void)detectorFace &#123; // 上下文 CIContext *content = [CIContext contextWithOptions:nil]; /** 1、识别精度 Detector Accuracy key: CIDetectorAccuracy value: CIDetectorAccuracyLow 低精度识别速度快 CIDetectorAccuracyHigh 高精度识别速度慢 */ /** 2、识别类型 Detector Types CIDetectorTypeFace 面部识别 CIDetectorTypeRectangle 矩形识别 CIDetectorTypeQRCode 条码识别 CIDetectorTypeText 文本识别 */ /** 3、 具体特征 Feature Detection CIDetectorImageOrientation 图片方向 CIDetectorEyeBlink 识别眨眼（closed eyes） CIDetectorSmile 笑脸 CIDetectorFocalLength 焦距 CIDetectorAspectRatio 矩形宽高比 CIDetectorReturnSubFeatures 是否检测子特征 */ // 配置识别质量 NSDictionary *param = [NSDictionary dictionaryWithObject:CIDetectorAccuracyHigh forKey:CIDetectorAccuracy]; // 创建人脸识别器 CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace context:content options:param]; // 识别图片 CIImage *ciImg = [CIImage imageWithCGImage:_myImageView.image.CGImage]; // 识别特征: 这里添加了眨眼和微笑 // CIDetectorSmile 眼部的识别效果很差，很难识别出来 NSDictionary *featuresParam = @&#123;CIDetectorSmile: [NSNumber numberWithBool:true], CIDetectorEyeBlink: [NSNumber numberWithBool:true]&#125;; // 获取识别结果 NSArray *resultArr = [detector featuresInImage:ciImg options:featuresParam]; UIView *resultView = [[UIView alloc] initWithFrame:_myImageView.frame]; [self.view addSubview:resultView]; for (CIFaceFeature *feature in resultArr) &#123; NSLog(@\"微笑：%d\", feature.hasSmile); NSLog(@\"右眼：%d\", feature.rightEyeClosed); NSLog(@\"左眼：%d\", feature.leftEyeClosed); NSLog(@\"脸框：%d\", feature.hasFaceAngle); NSLog(@\"嘴：%d\", feature.hasMouthPosition); /** 关于feature中的position需要注意的是: position是以所要识别图像的原始尺寸为标准； 因此， 如果装载图片的UIImageView的尺寸与图片原始尺寸不一样的话，会出现识别的位置有偏差。 */ UIView *faceView = [[UIView alloc] initWithFrame:feature.bounds]; faceView.layer.borderColor = [UIColor redColor].CGColor; faceView.layer.borderWidth = 1; [resultView addSubview:faceView]; // 坐标系的转换 [resultView setTransform:CGAffineTransformMakeScale(1, -1)]; // 左眼 if (feature.hasLeftEyePosition) &#123; UIView * leftEyeView = [[UIView alloc] initWithFrame:CGRectMake(0, 30, 20, 20)]; [leftEyeView setCenter:feature.leftEyePosition]; leftEyeView.layer.borderWidth = 1; leftEyeView.layer.borderColor = [UIColor greenColor].CGColor; [resultView addSubview:leftEyeView]; &#125; // 右眼 if (feature.hasRightEyePosition) &#123; UIView * rightEyeView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 20, 20)]; [rightEyeView setCenter:feature.rightEyePosition]; rightEyeView.layer.borderWidth = 1; rightEyeView.layer.borderColor = [UIColor redColor].CGColor; [resultView addSubview:rightEyeView]; &#125; // 嘴部 if (feature.hasMouthPosition) &#123; UIView * mouthView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 30, 30)]; [mouthView setCenter:feature.mouthPosition]; mouthView.layer.borderWidth = 1; mouthView.layer.borderColor = [UIColor redColor].CGColor; [resultView addSubview:mouthView]; &#125; &#125;&#125;","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"CIDetector","slug":"CIDetector","permalink":"http://yoursite.com/tags/CIDetector/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"}]},{"title":"iOS中基于OpenCV的人脸识别","slug":"iOS中基于OpenCV的人脸识别","date":"2016-11-28T01:45:27.000Z","updated":"2016-11-28T06:28:27.000Z","comments":true,"path":"2016/11/28/iOS中基于OpenCV的人脸识别/","link":"","permalink":"http://yoursite.com/2016/11/28/iOS中基于OpenCV的人脸识别/","excerpt":"","text":"OpenCV 是一个开源的计算机视觉和机器学习库。 与iOS系统自带的识别库一样，对于侧脸的识别很无力。简单记录一下。 相关参考https://objccn.io/issue-21-9/ http://www.jianshu.com/p/7a055b7eb14c 本文demohttps://github.com/zhangzhaopds/OpenCV_Demo.git 效果图 部署与使用CocoaPods 1pod &#39;OpenCV&#39;, &#39;~&#62; 3.0.0&#39; 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#import \"OpenCVUtil.h\"#import &lt;opencv2/opencv.hpp&gt;#import &lt;opencv2/imgproc/types_c.h&gt;#import &lt;opencv2/imgcodecs/ios.h&gt;@implementation OpenCVUtil+ (UIImage *)convertImage: (UIImage *)image &#123; // 初始化一个图片的二维矩阵cvImage cv::Mat cvImage; // 将图片UIImage对象转为Mat对象 UIImageToMat(image, cvImage); if (!cvImage.empty()) &#123; cv::Mat gray; // 进一步将图片转为灰度显示 cv::cvtColor(cvImage, gray, CV_RGB2GRAY); // 利用搞死滤镜去除边缘 cv::GaussianBlur(gray, gray, cv::Size(5, 5), 1.2, 1.2); // 计算画布 cv::Mat edges; cv::Canny(gray, edges, 0, 50); // 使用白色填充 cvImage.setTo(cv::Scalar::all(225)); // 修改边缘颜色 cvImage.setTo(cv::Scalar(0,128,255,255),edges); // 将Mat转换为UIImage return MatToUIImage(cvImage); &#125; return nil;&#125;+ (NSArray*)facePointDetectForImage:(UIImage*)image&#123; static cv::CascadeClassifier faceDetector; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 添加xml文件 NSString* cascadePath = [[NSBundle mainBundle] pathForResource:@\"haarcascade_frontalface_alt2\" ofType:@\"xml\"]; faceDetector.load([cascadePath UTF8String]); &#125;); cv::Mat faceImage; UIImageToMat(image, faceImage); // 转为灰度 cv::Mat gray; cvtColor(faceImage, gray, CV_BGR2GRAY); // 检测人脸并储存 std::vector&lt;cv::Rect&gt;faces; faceDetector.detectMultiScale(gray, faces,1.1,2,CV_HAAR_FIND_BIGGEST_OBJECT,cv::Size(30,30)); NSMutableArray *array = [NSMutableArray array]; for(unsigned int i= 0;i &lt; faces.size();i++) &#123; const cv::Rect&amp; face = faces[i]; float height = (float)faceImage.rows; float width = (float)faceImage.cols; CGRect rect = CGRectMake(face.x/width, face.y/height, face.width/width, face.height/height); [array addObject:[NSNumber valueWithCGRect:rect]]; &#125; return [array copy];&#125;+ (UIImage*)faceDetectForImage:(UIImage*)image &#123; static cv::CascadeClassifier faceDetector; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSString* cascadePath = [[NSBundle mainBundle] pathForResource:@\"haarcascade_frontalface_alt\" ofType:@\"xml\"]; faceDetector.load([cascadePath UTF8String]); &#125;); cv::Mat faceImage; UIImageToMat(image, faceImage); // 转为灰度 cv::Mat gray; cvtColor(faceImage, gray, CV_BGR2GRAY); // 检测人脸并储存 std::vector&lt;cv::Rect&gt;faces; faceDetector.detectMultiScale(gray, faces,1.1,2,0,cv::Size(30,30)); // 在每个人脸上画一个红色四方形 for(unsigned int i= 0;i &lt; faces.size();i++) &#123; const cv::Rect&amp; face = faces[i]; cv::Point tl(face.x,face.y); cv::Point br = tl + cv::Point(face.width,face.height); // 四方形的画法 cv::Scalar magenta = cv::Scalar(255, 0, 0, 255); cv::rectangle(faceImage, tl, br, magenta, 11, 8, 0); &#125; return MatToUIImage(faceImage);&#125;+ (UIImage*)circleDetectForImage:(UIImage*)image&#123; cv::Mat circleImage,src_gray; UIImageToMat(image, circleImage); /// Convert it to gray cvtColor( circleImage, src_gray, CV_BGR2GRAY ); /// Reduce the noise so we avoid false circle detection GaussianBlur( src_gray, src_gray, cv::Size(9, 9), 2, 2 ); std::vector&lt;cv::Vec3f&gt; circles; /// Apply the Hough Transform to find the circles HoughCircles( src_gray, circles, CV_HOUGH_GRADIENT, 1, src_gray.rows/8, 200, 100, 0, 0 ); /// Draw the circles detected for( size_t i = 0; i &lt; circles.size(); i++ ) &#123; cv::Point center(cvRound(circles[i][0]), cvRound(circles[i][1])); int radius = cvRound(circles[i][2]); // circle center circle( circleImage, center, 3, cv::Scalar(0,255,0,255), -1, 8, 0 ); // circle outline circle( circleImage, center, radius, cv::Scalar(0,0,255,255), 3, 8, 0 ); &#125; /// Show your results return MatToUIImage(circleImage); &#125;@end 调用12345678- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIImage *img = [UIImage imageNamed:@\"888.JPG\"]; _myImgView.image = img; _detectImgView.image = [OpenCVUtil faceDetectForImage:img];&#125;","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://yoursite.com/tags/人脸识别/"}]},{"title":"RecyclerView中CardView的展开与叠起","slug":"RecyclerView中CardView的展开与叠起","date":"2016-11-23T08:22:03.000Z","updated":"2016-11-23T08:52:21.000Z","comments":true,"path":"2016/11/23/RecyclerView中CardView的展开与叠起/","link":"","permalink":"http://yoursite.com/2016/11/23/RecyclerView中CardView的展开与叠起/","excerpt":"","text":"RecyclerView中CardView的展开与叠起效果。 效果图 实现本文DEMO https://github.com/zhangzhaopds/FlexbleCell.git 主要代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; implements View.OnClickListener &#123; @Override public int getItemCount() &#123; return 20; &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View cell = LayoutInflater.from(parent.getContext()).inflate(R.layout.cell_main_recyclerview, parent, false); MyViewHolder myViewHolder = new MyViewHolder(cell); // 对每一个cell注册点击事件 cell.setOnClickListener(this); // 取消viewHolder的重用机制（很重要） myViewHolder.setIsRecyclable(false); return myViewHolder; &#125; public static class MyViewHolder extends RecyclerView.ViewHolder &#123; MyViewHolder(View view) &#123; super(view); &#125; &#125; @Override public void onClick(View v) &#123; int index; // 尽量用线性垂直布局来动态的添加视图 LinearLayout linearLayout = (LinearLayout)v.findViewById(R.id.cell_main_rootLayout); View subView = LayoutInflater.from(v.getContext()).inflate(R.layout.cell_main_recyclerview_add, (ViewGroup)v, false); // 利用cell控件的Tag值来标记cell是否被点击过,因为已经将重用机制取消，cell退出当前界面时就会被销毁，Tag值也就不存在了。 // 如果不取消重用，那么将会出现未曾点击就已经添加子视图的效果，再点击的时候会继续添加而不是收回。 if (v.findViewById(R.id.cell_main_rootLayout).getTag() == null) &#123; index = 1; &#125; else &#123; index = (int)v.findViewById(R.id.cell_main_rootLayout).getTag(); &#125; // close状态: 添加视图 if (index == 1) &#123; linearLayout.addView(subView); subView.setTag(1000); v.findViewById(R.id.cell_main_rootLayout).setTag(2); &#125; else &#123; // open状态： 移除视图 linearLayout.removeView(v.findViewWithTag(1000)); v.findViewById(R.id.cell_main_rootLayout).setTag(1); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"CardView","slug":"CardView","permalink":"http://yoursite.com/tags/CardView/"},{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"}]},{"title":"依托AlertDialog实现的iOS风格的提醒框","slug":"依托AlertDialog实现的iOS风格的提醒框","date":"2016-11-18T07:40:28.000Z","updated":"2016-11-18T08:00:02.000Z","comments":true,"path":"2016/11/18/依托AlertDialog实现的iOS风格的提醒框/","link":"","permalink":"http://yoursite.com/2016/11/18/依托AlertDialog实现的iOS风格的提醒框/","excerpt":"","text":"第一个Android项目基本做完了，整理一下笔记。个人实在是欣赏不动Android提醒框的审美风格，所以就自己简单封装个，方便今后使用。 效果图： 具体实现：基本原理： 利用Android现有的提醒框AlertDialog，自定义内容视图。 相关代码： 12CustomAlertView.java 是对提醒框的封装；view_alert.xml 是自定义的内容视图； 文件view_alert.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"125dp\" android:orientation=\"vertical\" android:layout_centerInParent=\"true\"&gt; &lt;TextView android:id=\"@+id/alert_title\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:text=\"提示\" android:textAlignment=\"center\" android:textColor=\"@android:color/black\" android:gravity=\"bottom\"/&gt; &lt;TextView android:id=\"@+id/alert_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:text=\"这个是提醒内容\" android:textAlignment=\"center\"/&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"0.3dp\" android:background=\"#e5e5e5\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/alert_leftBtn\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:text=\"取消\" android:gravity=\"center\" android:textColor=\"@android:color/holo_blue_light\" android:background=\"@android:color/transparent\"/&gt; &lt;View android:layout_width=\"0.3dp\" android:layout_height=\"match_parent\" android:background=\"#e5e5e5\"/&gt; &lt;Button android:id=\"@+id/alert_rightBtn\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:text=\"确定\" android:gravity=\"center\" android:textColor=\"@android:color/holo_blue_light\" android:background=\"@android:color/transparent\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 文件CustomAlertView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class CustomAlertView extends View &#123; private TextView alertTitle; private TextView alertContent; private Button alertLeftBtn; private Button alertRightBtn; private Context mContent; private AlertDialog alertDialog; private View mView; public LeftButtonClickedListener leftButtonClickedListener; public RightButtonClickedListener rightButtonClickedListener; public CustomAlertView(Context context) &#123; super(context); mContent = context; initView(mContent); &#125; public CustomAlertView(Context context, AttributeSet attrs) &#123; super(context, attrs); mContent = context; initView(mContent); &#125; public CustomAlertView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mContent = context; initView(mContent); &#125; // 初始化视图 private void initView(Context context) &#123; mView = LayoutInflater.from(mContent).inflate(R.layout.view_alert, null); alertTitle = (TextView)mView.findViewById(R.id.alert_title); alertContent = (TextView)mView.findViewById(R.id.alert_content); alertLeftBtn = (Button)mView.findViewById(R.id.alert_leftBtn); alertRightBtn = (Button)mView.findViewById(R.id.alert_rightBtn); // 初始化AlertDialog alertDialog = new AlertDialog.Builder(mContent).create(); // 监听 alertLeftBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; leftButtonClickedListener.onClickedLeftButton(v); &#125; &#125;); alertRightBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; rightButtonClickedListener.onClickedRightButton(v); &#125; &#125;); &#125; // 配置内容和标题 public void baseConfiguration(String title, String content) &#123; alertTitle.setText(title); alertContent.setText(content); &#125; // 弹出对话框 public void showAlert() &#123; // 以AlertDialog为载体 alertDialog.setView(mView); alertDialog.show(); // 设置宽度，AlertDialog默认的宽度过于夸张。（可以不修改） WindowManager windowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); WindowManager.LayoutParams layoutParams = alertDialog.getWindow().getAttributes(); layoutParams.width = (int)(display.getWidth() * 2 / 3); alertDialog.getWindow().setAttributes(layoutParams); &#125; // 取消对话框 public void dismissAlert() &#123; alertDialog.dismiss(); &#125; public interface LeftButtonClickedListener &#123; void onClickedLeftButton(View view); &#125; public interface RightButtonClickedListener &#123; void onClickedRightButton(View view); &#125; public void setLeftButtonClickedListener(LeftButtonClickedListener leftButtonClickedListener) &#123; this.leftButtonClickedListener = leftButtonClickedListener; &#125; public void setRightButtonClickedListener(RightButtonClickedListener rightButtonClickedListener) &#123; this.rightButtonClickedListener = rightButtonClickedListener; &#125;&#125; 在Activity中的调用： 123456789101112131415161718192021222324252627282930313233343536// 初始化 final CustomAlertView customAlertView = new CustomAlertView(MainActivity.this); customAlertView.baseConfiguration(\"提示\", \"今天是星期五吗\"); Button showBtn = (Button)findViewById(R.id.main_show_btn); showBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 显现 Log.i(TAG, \"onClick: 显现\"); customAlertView.showAlert(); &#125; &#125;); customAlertView.setLeftButtonClickedListener(new CustomAlertView.LeftButtonClickedListener() &#123; @Override public void onClickedLeftButton(View view) &#123; // 取消 Log.i(TAG, \"onClickedLeftButton: 取消\"); customAlertView.dismissAlert(); &#125; &#125;); customAlertView.setRightButtonClickedListener(new CustomAlertView.RightButtonClickedListener() &#123; @Override public void onClickedRightButton(View view) &#123; // 确定 Log.i(TAG, \"onClickedRightButton: 确定\"); /** 此处处理一些事物 **/ // 取消 customAlertView.dismissAlert(); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"AlertDialog","slug":"AlertDialog","permalink":"http://yoursite.com/tags/AlertDialog/"},{"name":"提醒框","slug":"提醒框","permalink":"http://yoursite.com/tags/提醒框/"}]},{"title":"hexo主题yilia的头像无法显现","slug":"hexo主题yilia的头像无法显现","date":"2016-11-18T05:50:17.000Z","updated":"2016-11-18T05:57:41.000Z","comments":true,"path":"2016/11/18/hexo主题yilia的头像无法显现/","link":"","permalink":"http://yoursite.com/2016/11/18/hexo主题yilia的头像无法显现/","excerpt":"","text":"一直懒得整理博客，旧版的yilia主题的头像无法显现。 解决方法在路径 yilia/layout/_partial/left-col.ejs 下，打开 left-col.ejs; 修改第6、8行的： 1&#60;img lazy-src=&#34;&#60;%=theme.avatar%&#62;&#34; class=&#34;js-avatar &#34;&#62;&#10;&#60;img src=&#34;&#60;%=theme.avatar%&#62;&#34; class=&#34;js-avatar &#34; style=&#34;width: 100%;height: 100%;opacity: 1;&#34;&#62; 为： 1&#60;img src=&#34;&#60;%=theme.avatar%&#62;&#34; class=&#34;js-avatar show&#34;&#62;&#10;&#60;img src=&#34;&#60;%=theme.avatar%&#62;&#34; class=&#34;js-avatar show&#34; style=&#34;width: 100%;height: 100%;opacity: 1;&#34;&#62; 最后重新部署就行了。 最新的yilia主题没有这个问题。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"}]},{"title":"MQTT_Android","slug":"MQTT-Android","date":"2016-11-01T05:23:17.000Z","updated":"2016-11-18T02:51:27.000Z","comments":true,"path":"2016/11/01/MQTT-Android/","link":"","permalink":"http://yoursite.com/2016/11/01/MQTT-Android/","excerpt":"","text":"MQTT在Android中的使用，客户端的，记录一下。 官方文档 https://github.com/eclipse/paho.mqtt.android 添加依赖12345compile 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0'//compile 'org.eclipse.paho:org.eclipse.paho.android.service:1.0.2@arr'compile 'org.greenrobot:eventbus:3.0.0' 添加完之后，可能会出现warning: 1ignoring innerclasses attribute for an anonymous inner class 处理方法是在 proguard-rules.pro，中添加 12345-keepattributes InnerClasses-keepattributes EnclosingMethod-dontoptimize 这个问题的处理可参考 http://stackoverflow.com/questions/35796144/progaurd-issue-warningignoring-innerclasses-attribute-for-an-anonymous-inner-c 使用基本使用，可参考以下博客，很详细 博客地址：http://www.longdw.com/mqtt-server-client-android/ 下面是部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void init() &#123;try &#123;//host为主机名，test为clientid即连接MQTT的客户端ID，一般以客户端唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存client = new MqttClient(host, \"test\",new MemoryPersistence());//MQTT的连接设置options = new MqttConnectOptions();//设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接options.setCleanSession(true);//设置连接的用户名options.setUserName(userName);//设置连接的密码options.setPassword(passWord.toCharArray());// 设置超时时间 单位为秒options.setConnectionTimeout(10);// 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制options.setKeepAliveInterval(20);//设置回调client.setCallback(new MqttCallback() &#123;@Overridepublic void connectionLost(Throwable cause) &#123;//连接丢失后，一般在这里面进行重连System.out.println(\"connectionLost----------\");&#125;@Overridepublic void deliveryComplete(IMqttDeliveryToken token) &#123;//publish后会执行到这里System.out.println(\"deliveryComplete---------\"+ token.isComplete());&#125;@Overridepublic void messageArrived(String topicName, MqttMessage message)throws Exception &#123;//subscribe后得到的消息会执行到这里面System.out.println(\"messageArrived----------\");&#125;&#125;);// connect();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"MQTT","slug":"MQTT","permalink":"http://yoursite.com/tags/MQTT/"}]},{"title":"Compiling Swift source files","slug":"Compiling","date":"2016-10-21T15:26:40.000Z","updated":"2016-11-18T02:29:35.000Z","comments":true,"path":"2016/10/21/Compiling/","link":"","permalink":"http://yoursite.com/2016/10/21/Compiling/","excerpt":"","text":"自从项目提交到AppStore之后，一直在学习Android的东西，今天因为要改个接口，就打开了那个Swift版本的项目，结果Xcode就一直处于编译状态 Compiling Swift source files，等了半天没有结束；我把新添加的内容删除，回归到提交AppStroe时的样子，编译很慢，但最终通过了，然后在Command+R也很快，回归正常。然后就Google，遇到了各种各样的解决方案，但真没适合我的。 【Compiling Swift source files】编译很慢； 【解决】Edit Scheme —&gt; Build Configuration，设置为【Debug】 【总结：自己很二逼】app打包的时候将BuildConfiguration设置为了Release，回头继续码代码的时候忘了设置Debug了，为此白白浪费了2个多小时，够二！ 相关参考：http://stackoverflow.com/questions/39476239/xcode-build-stuck-on-compiling-swift-source-files","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Compiling","slug":"Compiling","permalink":"http://yoursite.com/tags/Compiling/"}]},{"title":"Apple LLVM 8.0 Error","slug":"Error","date":"2016-10-14T02:13:12.000Z","updated":"2016-11-18T02:34:08.000Z","comments":true,"path":"2016/10/14/Error/","link":"","permalink":"http://yoursite.com/2016/10/14/Error/","excerpt":"","text":"早上打开项目，冒出了6个红点，报错【Apple LLVM 8.0 Error】，然后就开始goole了。解决方案很多，但并非都适合自己的项目。 报错 Delete之后，记得clean一下，然后编译运行就OK了 参考http://stackoverflow.com/questions/26772504/apple-llvm-6-0-error-clang-failed-with-exit-code-1 http://stackoverflow.com/questions/24052293/apple-llvm-6-0-error","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"LLVM8.0","slug":"LLVM8-0","permalink":"http://yoursite.com/tags/LLVM8-0/"}]},{"title":"Swift3中Dispatch_once的实现","slug":"Swift3中Dispatch-once的实现","date":"2016-10-08T02:01:43.000Z","updated":"2016-11-22T02:41:16.000Z","comments":true,"path":"2016/10/08/Swift3中Dispatch-once的实现/","link":"","permalink":"http://yoursite.com/2016/10/08/Swift3中Dispatch-once的实现/","excerpt":"","text":"Dispatch_once在Swift3中已经被废弃。 实现123456789101112131415161718192021222324public extension DispatchQueue &#123; private static var _onceTracker = [String]() // 利用token字段来作为once的ID public class func once(token: String, block:()-&gt;Void) &#123; // 加锁，保证有序同步执行 objc_sync_enter(self) // 推迟解锁 defer &#123; // 将objc_sync_exit(self)推入栈中，函数结束时执行解锁 objc_sync_exit(self) &#125; if _onceTracker.contains(token) &#123; return &#125; _onceTracker.append(token) block() &#125;&#125; 调用123DispatchQueue.once(token: \"com.once.test\") &#123; print( \"执行一次\" )&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Dispatch_once","slug":"Dispatch-once","permalink":"http://yoursite.com/tags/Dispatch-once/"},{"name":"Swift3","slug":"Swift3","permalink":"http://yoursite.com/tags/Swift3/"}]},{"title":"RecyclerView中动态添加子控件和改变ViewHolder高度","slug":"【android】RecyclerView中动态添加子控件和改变ViewHolder高度","date":"2016-09-29T07:41:43.000Z","updated":"2016-11-18T02:42:33.000Z","comments":true,"path":"2016/09/29/【android】RecyclerView中动态添加子控件和改变ViewHolder高度/","link":"","permalink":"http://yoursite.com/2016/09/29/【android】RecyclerView中动态添加子控件和改变ViewHolder高度/","excerpt":"","text":"想要跨平台，就要对平台有了解，最近在看android开发。在为RecyclerView中动态添加子控件和改变ViewHolder高度时遇到了几个坑，费了不少时间填坑，所以记录一下。 这个是效果图：本文demo链接：https://github.com/zhangzhaopds/RecyclerView_demo.git 点击cell，那么cell的高度就会增加一倍，同时，在cell上面添加一个控件。 关于改变高度的注意点：123在线性布局或者相对布局动态设置宽高时，要先看有没有外层布局，如果有要看外层布局是什么，是LinearLayout，则要用LinearLayout.LayoutParams，如果是RelativeLayout则要用RelativeLayout.LayoutParams，而不是看你要控制的是什么布局，如果外层没有布局文件则要用FrameLayout.LayoutParams。 关于新增控件的注意点：123如果父视图是RelativeLayout 或者 FrameLayout，无法动态添加控件，解决的办法是新建一个LinearLayout，然后把textView添加给它，再把这个LinearLayout添加给父视图： 主要的代码：1234567891011121314151617181920212223242526272829303132333435holder.mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; clickedArr.set(position, !clickedArr.get(position)); if (clickedArr.get(position)) &#123; TextView showView = new TextView(currentView.getContext()); showView.setTextColor(Color.WHITE); showView.setText(\"新增的位置:\" + position + \", 高度增加一倍\"); // 改变高度 FrameLayout.LayoutParams linearParams = (FrameLayout.LayoutParams)relativesArr.get(position).getLayoutParams(); linearParams.height = 200; relativesArr.get(position).setLayoutParams(linearParams); // 新增控件 LinearLayout.LayoutParams param1 = new LinearLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, 40); param1.setMargins(20, 120, 0, 0); showView.setLayoutParams(param1); LinearLayout linear = new LinearLayout(currentView.getContext()); linear.setOrientation(LinearLayout.VERTICAL); linear.addView(showView); subViewsArr.set(position, linear); relativesArr.get(position).addView(linear); &#125; else &#123; Log.i(\"Card\", \"onClick: cuo \" + clickedArr.get(position)); // 移除控件 relativesArr.get(position).removeView(subViewsArr.get(position)); // 返回原先高度100 FrameLayout.LayoutParams linearParams = (FrameLayout.LayoutParams)relativesArr.get(position).getLayoutParams(); linearParams.height = 100; relativesArr.get(position).setLayoutParams(linearParams); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"动态控件添加","slug":"动态控件添加","permalink":"http://yoursite.com/tags/动态控件添加/"},{"name":"动态高度","slug":"动态高度","permalink":"http://yoursite.com/tags/动态高度/"}]},{"title":"【RN】ReactNative基础配置","slug":"【RN】ReactNative基础配置","date":"2016-09-01T07:14:13.000Z","updated":"2016-11-18T02:57:01.000Z","comments":true,"path":"2016/09/01/【RN】ReactNative基础配置/","link":"","permalink":"http://yoursite.com/2016/09/01/【RN】ReactNative基础配置/","excerpt":"","text":"Facebook开源的ReactNative被炒得越来越热了，InfoQ上面关于ReactNative的文章也越来越多，既然大神们那么推崇，肯定有她火的原因，所以静下心来学习学习。 必备工具 Xcode（ReactNative的最终实现还是需要走Xcode, 只是UI部分等可以使用js来实现） The React Native command line tools（React Native命令行工具，用于工程的初始创建） node.js（是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。） Watchman（用来监视文件并且记录文件的改动情况） 编辑环境对于React Native的开发，Facebook官方推荐使用Atom+Nuclide的组合,最主要这个组合适合Mac开发环境。 下载AtomAtom地址 安装nuclide参考链接 https://nuclide.io/docs/editor/setup/#quick-install 在终端执行以下命令： $ apm install nuclide 安装node、watchmanbrew install watchman brew install node 安装React Nativenpm install -g react-native-cli 或者 sudo npm install -g react-native-cli (以管理员的身份安装，需要输入管理员密码) 到此，准备工作完成，接下来就是测试一下 测试react-native init AwesomeProject 这个过程较慢，需要耐心等待；cd AwesomeProjectreact-native run-ios 工程在终端启动后的效果： Xcode运行执行完上面的步骤之后，用Xcode打开并运行AwesomeProject.xcodeproj文件，选择模拟器，运行。效果如下： 参考https://facebook.github.io/react-native/releases/next/docs/getting-started.html","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/categories/ReactNative/"}],"tags":[]},{"title":"【MacOS开发】HotKey(快捷键)","slug":"【MacOS开发】HotKey","date":"2016-08-31T05:37:44.000Z","updated":"2016-11-18T02:57:33.000Z","comments":true,"path":"2016/08/31/【MacOS开发】HotKey/","link":"","permalink":"http://yoursite.com/2016/08/31/【MacOS开发】HotKey/","excerpt":"","text":"在MacOS开发中，设置快捷键是必不可少的，这里总结了两种方法。 方法一：在IB中快速设置如果将快捷键设置为MacAPP默认的，用户不可以更改的快捷键，推荐使用这种方法，十分便捷。具体就是在StoryBoard中为NSMenuItem设置KeyEquivalent属性，简单直接。如下图： 方法二：代码实现快捷键设置允许用户设置快捷键的话，推荐使用这种方法。首先引入Carbon.framework, 具体方法如下： 1// &#27880;&#20876;&#24555;&#25463;&#38190;&#10;- (void)costomHotKey &#123;&#10; &#10; // 1&#12289;&#22768;&#26126;&#30456;&#20851;&#21442;&#25968;&#10; EventHotKeyRef myHotKeyRef;&#10; EventHotKeyID myHotKeyID;&#10; EventTypeSpec myEvenType;&#10; myEvenType.eventClass = kEventClassKeyboard; // &#38190;&#30424;&#31867;&#22411;&#10; myEvenType.eventKind = kEventHotKeyPressed; // &#25353;&#21387;&#20107;&#20214;&#10; &#10; // 2&#12289;&#23450;&#20041;&#24555;&#25463;&#38190;&#10; myHotKeyID.signature = &#39;yuus&#39;; // &#33258;&#23450;&#20041;&#31614;&#21517;&#10; myHotKeyID.id = 4; // &#24555;&#25463;&#38190;ID&#10;&#10; // 3&#12289;&#27880;&#20876;&#24555;&#25463;&#38190;&#10; // &#21442;&#25968;&#19968;&#65306;keyCode; &#22914;18&#20195;&#34920;1&#65292;19&#20195;&#34920;2&#65292;21&#20195;&#34920;4&#65292;49&#20195;&#34920;&#31354;&#26684;&#38190;&#65292;36&#20195;&#34920;&#22238;&#36710;&#38190;&#10; // &#24555;&#25463;&#38190;&#65306;command+4&#10; RegisterEventHotKey(21, cmdKey, myHotKeyID, GetApplicationEventTarget(), 0, &#38;myHotKeyRef);&#10; &#10; // &#24555;&#25463;&#38190;&#65306;command+option+4&#10;// RegisterEventHotKey(21, cmdKey + optionKey, myHotKeyID, GetApplicationEventTarget(), 0, &#38;myHotKeyRef);&#10;&#10; // 5&#12289;&#27880;&#20876;&#22238;&#35843;&#20989;&#25968;&#65292;&#21709;&#24212;&#24555;&#25463;&#38190;&#10; InstallApplicationEventHandler(&#38;hotKeyHandler, 1, &#38;myEvenType, NULL, NULL);&#10;&#125; 12345678910111213141516171819// 4、自定义C类型的回调函数OSStatus hotKeyHandler(EventHandlerCallRef nextHandler, EventRef anEvent, void *userData) &#123; EventHotKeyID hotKeyRef; GetEventParameter(anEvent, kEventParamDirectObject, typeEventHotKeyID, NULL, sizeof(hotKeyRef), NULL, &amp;hotKeyRef); unsigned int hotKeyId = hotKeyRef.id; switch (hotKeyId) &#123; case 4: // do something NSLog(@\"%d\", hotKeyId); break; default: break; &#125; return noErr;&#125; 相关链接：本文DEMO https://github.com/zhangzhaopds/KeyEquivalentDemo.git 参考 http://alvinzhu.me/blog/2013/11/05/cocoakai-fa-an-jian-shi-jian-jian-ting/","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://yoursite.com/categories/MacOS/"}],"tags":[]},{"title":"layer层CornerRadius影响shadow的实现","slug":"layer层CornerRadius影响shadow的实现","date":"2016-07-28T06:30:03.000Z","updated":"2016-07-28T06:49:26.000Z","comments":true,"path":"2016/07/28/layer层CornerRadius影响shadow的实现/","link":"","permalink":"http://yoursite.com/2016/07/28/layer层CornerRadius影响shadow的实现/","excerpt":"","text":"手动设置视图的圆角效果(cornerRadius)，会屏蔽视图的投影效果(Shadow)。问题总是在解决后，才发现仅仅只是个纸老虎！展示下代码，一看就明白。 12345678910111213 let imageShadow = UIImageView.init(frame: CGRectMake(50, 50, UIScreen.mainScreen().bounds.width - 100, UIScreen.mainScreen().bounds.width - 100)) self.view.addSubview(imageShadow) imageShadow.image = UIImage(named: \"IMG_0412.JPG\") imageShadow.layer.shadowColor = UIColor.init(red: 238/225.0, green: 100/255.0, blue: 81/255.0, alpha: 1).CGColor imageShadow.layer.shadowOffset = CGSizeMake(0, 3.0) imageShadow.layer.shadowOpacity = 0.2 // 透明度 imageShadow.layer.shadowRadius = 6.0 // 半径 /** 注意点： 控件的圆角属性，会影响控件的投影的实现。例如：加入下面的设置圆角属性的代码，将看不到控件的投影效果。 */// imageShadow.layer.cornerRadius = 5// imageShadow.layer.masksToBounds = true 效果图对比","categories":[],"tags":[]},{"title":"Swift2.3适配Swift3.0","slug":"【BUG】Swift2-3适配Swift3-0","date":"2016-07-28T05:36:36.000Z","updated":"2016-11-18T02:56:07.000Z","comments":true,"path":"2016/07/28/【BUG】Swift2-3适配Swift3-0/","link":"","permalink":"http://yoursite.com/2016/07/28/【BUG】Swift2-3适配Swift3-0/","excerpt":"","text":"升级Xcode8.0Beta版，看着公司Swift版本的项目200多个报红，那种酸爽也就苹果能给。慢慢改吧！改的东西很多，但基本都不难，记录几个花费较长时间的Bug。 NO.1【报错】“Use Legacy Swift Language Version” (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit &gt; Convert &gt; To Current Swift Syntax…] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly. 【解决方法】设置 Build Settings —-&gt; Use Legacy Swift Language Version —-&gt; YES/NO，改为NO或者YES NO.2【问题】控制台打印出大量无用的信息。 【解决方法】在 Environment Variables中添加字段 name:OS_ACTIVITY_MODE,value:disable NO.3【问题】整个项目能编译通过，但在运行时启动页出现后就黑屏 【解决方法】问题在于，AppDelegate中didFinishLaunchingWithOptions这个方法没有走。虽然是利用系统提供的修复，自动从Swift2.3修复到Swift3，但修复完的这个方法也还是不对的。 1private func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123; &#125; 修改为 1func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; &#125; NO.4【报错】“ambiguous referenc to member datask(with: completionhandler:)” 【解决方法】这个是在URLSessionDataTask中遇到的，属于类型不明确的报错。 修改前的代码： 1let task: URLSessionDataTask = session.dataTask(with: request) &#123; (data, resp, err) in &#125; 修改后的代码: 12let task: URLSessionDataTask = session.dataTask(with: request as URLRequest) &#123; (data, resp, err) in &#125;// 由于request是NSMutableURLRequest类型，在request 后面添加了 as URLRequest NO.5【报错】”Cannot pass immutable value of type ‘NSDate?’ as inout argument” 【解决方法】var beginDate: NSDate? = NSDate() 修改前的代码： 1234var beginDate: Date?var endDate: Date?let calendar: Calendar = Calendar.currentlet ok: Bool = calendar.range(of: Calendar.Unit.month, start: &amp;beginDate, interval: &amp;interval, for: newDate as Date) 修改后的代码： 1234var beginDate: NSDate? = NSDate()var endDate: NSDate? = NSDate()let calendar: Calendar = Calendar.currentlet ok: Bool = calendar.range(of: Calendar.Unit.month, start: &amp;beginDate, interval: &amp;interval, for: newDate as Date) NO.6【警告】”Expression of type “UIViewController?” is unused”. 【解决】Swift3之前，每个方法都有一个默认的可以废弃的结果。 相关解决实例： 12345678910// 例一： _ = navigationController?.popViewController(animated: true)// 例二： t_principal.mas_makeConstraints &#123; (make) in _ = make?.top.mas_equalTo()(0) _ = make?.left.mas_equalTo()(20) _ = make?.height.mas_equalTo()(self.frame.size.height / 3 - 1) _ = make?.width.mas_equalTo()(self.frame.size.width / 2 - 30) &#125; 相关参考http://adcdownload.apple.com/Developer_Tools/Xcode_8_beta_3/Release_Notes_for_Xcode_8_beta_3.pdf https://forums.developer.apple.com/thread/49635 http://stackoverflow.com/questions/37812286/swift-3-urlsession-shared-ambiguous-reference-to-member-datataskwithcomplet http://stackoverflow.com/questions/37946990/cgrectmake-cgpointmake-cgsizemake-cgrectzero-cgpointzero-is-unavailable-in http://stackoverflow.com/questions/37843049/xcode-8-swift-3-expression-of-type-uiviewcontroller-is-unused-warning","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift2.3","slug":"Swift2-3","permalink":"http://yoursite.com/tags/Swift2-3/"},{"name":"Swift3.0","slug":"Swift3-0","permalink":"http://yoursite.com/tags/Swift3-0/"}]},{"title":"[Extension]-Array","slug":"Extension-Array","date":"2016-07-11T03:07:19.000Z","updated":"2016-11-18T02:56:16.000Z","comments":true,"path":"2016/07/11/Extension-Array/","link":"","permalink":"http://yoursite.com/2016/07/11/Extension-Array/","excerpt":"","text":"Swift中Array的实用延展。 接受数组为下标输入的读取延展123456789101112131415161718192021222324252627extension Array &#123; // 接受数组为下标输入的读取延展 subscript(input: [Int])-&gt;ArraySlice&lt;Element&gt; &#123; get &#123; var result = ArraySlice&lt;Element&gt;() for i in input &#123; // 断言 true继续往下走， false则打印且终止 assert(i &lt; self.count, \"Index out of range\") result.append(self[i]) &#125; return result &#125; set &#123; for (index, i) in input.enumerate() &#123; assert(i &lt; self.count, \"Index out of range\") self[i] = newValue[index] &#125; &#125; &#125;&#125;var myArr = [\"ni\", \"hao\", \"wa\"]myArr[[1,2]]// myArr = [\"ni\", \"hao\", \"wa\"]myArr[[1,2]] = [\"zzz\", \"hhh\"]// myArr = [\"ni\", \"zzz\", \"hhh\"]","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]},{"title":"【BUG】require_once","slug":"【BUG】require-once","date":"2016-07-01T06:58:41.000Z","updated":"2016-11-18T02:55:38.000Z","comments":true,"path":"2016/07/01/【BUG】require-once/","link":"","permalink":"http://yoursite.com/2016/07/01/【BUG】require-once/","excerpt":"","text":"GOOD GOOD STUDY, DAY DAY UP ! 【场景】: PHP中，调用支付宝手机网站支付API； 【问题】: 利用require_once调用同一目录下的文件alipay.config.php, require_once(&quot;alipay.config.php&quot;);报路径错误。 【原因】: 编译器问题。 【解决】: require_once($_SERVER[&#39;DOCUMENT_ROOT&#39;].&quot;/tongxingpay/alipay.config.php&quot;); 【参考】:http://stackoverflow.com/questions/5364233/php-fatal-error-failed-opening-required-file","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"【BUG】layer与subView层次顺序","slug":"【BUG】layer与subView添加顺序","date":"2016-06-11T06:14:46.000Z","updated":"2016-11-18T02:54:44.000Z","comments":true,"path":"2016/06/11/【BUG】layer与subView添加顺序/","link":"","permalink":"http://yoursite.com/2016/06/11/【BUG】layer与subView添加顺序/","excerpt":"","text":"GOOD GOOD STUDY, DAY DAY UP! 【场景】: Swift语言环境中，自定义二维码扫描界面; 【问题】: 调用系统摄像头，添加自定义扫描动画视图，在模拟器中可以看到自定义的视图，但在真机测试时却无自定义视图; 【原因】: 先在VC视图添加自定义动画子视图，之后将摄像头capture添加到了VC视图的layer层；添加子视图，那么子视图的layer层也就相应地添加到了父视图的layer层，子layer之间的遮盖造成视图的无法显现。 【修复】: 调整两者的添加顺序","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[]},{"title":"BCrypt随机盐值加密","slug":"BCrypt随机盐值加密","date":"2016-05-31T02:39:12.000Z","updated":"2016-11-18T02:54:23.000Z","comments":true,"path":"2016/05/31/BCrypt随机盐值加密/","link":"","permalink":"http://yoursite.com/2016/05/31/BCrypt随机盐值加密/","excerpt":"","text":"朋友做的一个军检项目中用到BCrypt的加密处理，之前没用过，所以就查了些相关资料。简单的理解就是：BCrypt是一个利用随机盐值进行hash的加密方式。 相关概念： 哈希算法 获取一个任何长度的字符串并采用一致的方式创建一个哈希值：一种固定长度的字符串表示。每次传入同一个原始字符串，您都会收到相同的哈希值。这是一个单向过程，您无法从中获得原始字符串。 盐值 在原始的密码后面添加自定义的尽量随机的长字串，然后进行哈希，这个长字串就是盐值（Salt）。 有时候，为了减轻开发压力，程序员会统一使用一个salt值（固定盐值，储存在某个地方），而不是每个用户都生成私有的salt值。 盐值越复杂、越随机，密码被破解的几率就越小。 实现php: password_hash, password_verify123456789101112131415&lt;?php // hash值 $hashVal = password_hash(\"123456\", PASSWORD_DEFAULT); // $2y$10$QJlsKG/RUU2TEgQcj6.D2e8.QYeBJptiUce9g/IaxxU2GjRpapkA2 // $hashVal = '$2a$10$zpOCjNBFm1XQ7JvmErIkbeXg4KYbD.TOx0NXyPZhqZCjy9N8OxGQO'; echo($hashVal.\"&lt;br&gt;\"); // 验证 if (password_verify(\"123456\", $hashVal)) &#123; echo(\"true\"); &#125; else &#123; echo(\"false\"); &#125; ?&gt; iOS实现DEMO：https://github.com/zhangzhaopds/BCrypt.git 参考http://www.ibm.com/developerworks/cn/web/wa-php-renewed_2/","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"BCrypt","slug":"BCrypt","permalink":"http://yoursite.com/tags/BCrypt/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}]},{"title":"MySQL配置问题","slug":"MySQL配置问题","date":"2016-05-30T07:56:19.000Z","updated":"2016-11-18T02:53:34.000Z","comments":true,"path":"2016/05/30/MySQL配置问题/","link":"","permalink":"http://yoursite.com/2016/05/30/MySQL配置问题/","excerpt":"","text":"我在Mac上为PHP配置MySQL，遇到的一些问题，记录下。 问题1: mysql_connect():No such file or directory in…运行代码： 123456789&lt;?php $con = mysql_connect(\"localhost:3306\", \"root\", \"123456\") or die(mysql_error()); if (mysql_query(\"CREATE DATABASE my_first_db\", $con)) &#123; echo(\"Database created\"); &#125; else &#123; echo(\"error creating database: \".mysql_error()); &#125; mysql_close($con);?&gt; 出现下图的警告： 原因： php默认是在 /var/mysql/mysql.sock中查找mysql.sock， 而Mac上MySQL再安装时自动放在了/tmp/mysql.sock，路径不同，所以造成这个原因。 解决方法： 终端执行：cd /tmp 终端执行：ln -s /tmp/mysql.sock mysql.sock ,这段命令是基于我的 mysql.default_socket是/var/mysql/mysql.sock才选择这段命令，具体可看下文的链接。 关于这个警告的详细参考： http://stackoverflow.com/questions/4219970/warning-mysql-connect-2002-no-such-file-or-directory-trying-to-connect-vi http://verysimple.com/2009/01/07/php-on-os-cant-connect-to-local-mysql-server-through-socket-varmysqlmysqlsock/ 问题2: mysql_connect(): Too many levels of symbolic links in…在系统偏好设置里面将MySQL设置成开机启动，然后重启电脑，就OK了。说白了，就是第一个问题解决了，然后重启了下电脑而已。 大坑、小坑都要跳一边 ！！！！！！！！！！！！","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[]},{"title":"UserAgent（UA）","slug":"UserAgent（UA）","date":"2016-05-30T03:34:22.000Z","updated":"2016-11-18T02:56:41.000Z","comments":true,"path":"2016/05/30/UserAgent（UA）/","link":"","permalink":"http://yoursite.com/2016/05/30/UserAgent（UA）/","excerpt":"","text":"UserAgent（UA）用户代理，是浏览器系统信息，主要在浏览器打开链接的时候获取到。UA的应用场景不太多，我们这边的需求是为商户生成一个收款二维码，商户的用户通过支付宝、微信或者百度钱包等APP中的扫一扫功能，扫描二维码跳转到H5界面，输入金额，然后将APP的名字（作为支付方式）和金额等信息发送到收银台，完成支付。 获取方法1、HTML中获取UA方法：var ua = navigator.userAgent; 结果：Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_2 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13F69 BaiduWallet-5.7.0.1-IOS-walletapp_750_1334_iPhone_9.3.2_9.3.2_2.1.0_2.1.0.4,这个是苹果手机上面的百度钱包扫一扫功能BaiduWallet-5.7.0.1。 2、PHP中获取UA方法：$Agent = $_SERVER[&#39;HTTP_USER_AGENT&#39;]; 结果：Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_2 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13F69 BaiduWallet-5.7.0.1-IOS-walletapp_750_1334_iPhone_9.3.2_9.3.2_2.1.0_2.1.0.4 注意：只有当APP利用内置的浏览器打开链接的时候，才能获取app的相关信息。如支付宝和京东钱包的扫一扫打开的url是无法在UA中查看到app的信息的,因为它们将这个链接推给了手机默认浏览器，并不是在APP自身当中打开。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"PHP学习笔记（3）-json数据生成","slug":"PHP学习笔记（3）-json数据生成","date":"2016-05-25T03:43:52.000Z","updated":"2016-11-18T02:53:02.000Z","comments":true,"path":"2016/05/25/PHP学习笔记（3）-json数据生成/","link":"","permalink":"http://yoursite.com/2016/05/25/PHP学习笔记（3）-json数据生成/","excerpt":"","text":"学习php的最初想法，就是利用PHP来生成iOS开发所需要的json数据，今天终于弄出了点眉目了。 效果 操作：启动本地服务器Apache,浏览器中打开 http://localhost/php/php_3.php?name=zhangzhao； 结果： ) 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // $_GET[]： 获取URL中的请求参数的值(get请求)； $arr1 = array(\"name\"=&gt;$_GET[\"name\"], \"sex\"=&gt;$_GET[\"sex\"], \"dealCode\"=&gt;\"10000\", \"dealMsg\"=&gt;\"成功\", \"list\"=&gt;array( \"address1\"=&gt;\"成都\", \"address2\"=&gt;\"重庆\", \"citys\"=&gt;array( \"city1\"=&gt;\"纬度\", \"city2\"=&gt;\"经度\", ), ), \"key\"=&gt;array( \"key1\"=&gt;\"12345666\", )); // 利用递归函数，对json数据中的value值编码urlencode() function arrayRecursive(&amp;$array, $function, $apply_to_keys_also = false)&#123; static $recursive_counter = 0; if (++$recursive_counter &gt; 1000) &#123; die('possible deep recursion attack'); &#125; foreach ($array as $key =&gt; $value) &#123; if (is_array($value)) &#123; arrayRecursive($array[$key], $function, $apply_to_keys_also); &#125; else &#123; $array[$key] = $function($value); &#125; if ($apply_to_keys_also &amp;&amp; is_string($key)) &#123; $new_key = $function($key); if ($new_key != $key) &#123; $array[$new_key] = $array[$key]; unset($array[$key]); &#125; &#125; &#125; $recursive_counter--; &#125; function JSON($array) &#123; arrayRecursive($array, 'urlencode', true); $json = json_encode($array); return urldecode($json); &#125; echo JSON($arr1); ?&gt; &lt;/body&gt;&lt;/html&gt; 使用：启动Apache服务器，将此php文件放置到Sites文件夹下，浏览器中打开本地服务器，或直接输入如http://localhost/text.php?name=zhangsan&amp;sex=male，参数可不添加。 注意点：在json_encode之前，把所有数组内所有内容都用urlencode()处理一下，然用json_encode()转换成json字符串，最后再用urldecode()将编码过的中文转回来；否则，会出现类似&quot;name&quot;:&quot;\\u4e2d\\u56fd&quot;.....的乱码。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"RTSP_直播推流","slug":"RTSP-H264","date":"2016-05-24T09:04:54.000Z","updated":"2016-11-18T02:40:15.000Z","comments":true,"path":"2016/05/24/RTSP-H264/","link":"","permalink":"http://yoursite.com/2016/05/24/RTSP-H264/","excerpt":"","text":"基于RTSP协议实现的iOS端推流，只是搜集到的资料，对于非科班出身的我正在努力学习相关知识。 文档链接https://github.com/zhangzhaopds/RTSP.git 简单测试 从文档链接下载工程，并在真机上运行。 在MAC上运行VLC(需要预先安装); Open media —&gt; Network —&gt; URL(输入真机上显示的地址，如rtsp://192.168.1.119/) —&gt; Open。如果成功，就可以在VLC中看到手机中拍摄到的视频。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"直播推流","slug":"直播推流","permalink":"http://yoursite.com/tags/直播推流/"}]},{"title":"PHP学习笔记（2）-日期","slug":"PHP学习笔记2-日期","date":"2016-05-24T01:58:29.000Z","updated":"2016-11-18T02:51:53.000Z","comments":true,"path":"2016/05/24/PHP学习笔记2-日期/","link":"","permalink":"http://yoursite.com/2016/05/24/PHP学习笔记2-日期/","excerpt":"","text":"总体感觉，php的字符串转日期的功能很强大。 123456789101112131415161718&lt;?php date_default_timezone_set(\"Asia/Shanghai\"); echo \"今天是 \".date(\"Y.m.d\") .\"&lt;br&gt;\"; echo \"今天是 \".date(\"l\").\"&lt;br&gt;\"; // l - 表示周里的某天 $d = mktime(9, 22, 44, 5, 23, 2016); // 时间戳创建日期 echo \"创建日期 \".date(\"Y-m-d h:i:sa\", $d).\"&lt;br&gt;\"; $y = strtotime(\"10:38pm April 15 2015\"); // 字符串转换日期 echo \"创建日期 \".date(\"Y-m-d h:i:sa\", $y).\"&lt;br&gt;\"; $tomorrow = strtotime(\"tomorrow\"); echo \"明天是：\".date(\"Y-m-d h:i:sa\", $tomorrow).\"&lt;br&gt;\"; $nextSat = strtotime(\"next Saturday\"); echo \"下个周六：\".date(\"Y-m-d h:i:sa\", $nextSat).\"&lt;br&gt;\"; $months = strtotime(\"+3 Months\"); echo \"三个月后：\".date(\"Y-m-d h:i:sa\", $months).\"&lt;br&gt;\";?&gt; Y - 年，四位数字; 如: “1999” y - 年，二位数字; 如: “99” z - 一年中的第几天; 如: “0” 至 “365” F - 月份，英文全名; 如: “January” m - 月份，二位数字，若不足二位则在前面补零; 如: “01” 至 “12” n - 月份，二位数字，若不足二位则不补零; 如: “1” 至 “12” M - 月份，三个英文字母; 如: “Jan” t - 指定月份的天数; 如: “28” 至 “31” d - 几日，二位数字，若不足二位则前面补零; 如: “01” 至 “31” j - 几日，二位数字，若不足二位不补零; 如: “1” 至 “31” h - 12 小时制的小时; 如: “01” 至 “12” H - 24 小时制的小时; 如: “00” 至 “23” g - 12 小时制的小时，不足二位不补零; 如: “1” 至 12” G - 24 小时制的小时，不足二位不补零; 如: “0” 至 “23” i - 分钟; 如: “00” 至 “59” s - 秒; 如: “00” 至 “59” S - 字尾加英文序数，二个英文字母; 如: “th”，”nd” U - 总秒数 D - 星期几，三个英文字母; 如: “Fri” l - 星期几，英文全名; 如: “Friday” w - 数字型的星期几，如: “0” (星期日) 至 “6” (星期六) a - “am” 或是 “pm” A - “AM” 或是 “PM” 参考地址：http://www.sjyhome.com/php/date.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"PHP学习笔记（1）—基础","slug":"PHP学习笔记——基础","date":"2016-05-23T03:52:29.000Z","updated":"2016-11-18T02:51:44.000Z","comments":true,"path":"2016/05/23/PHP学习笔记——基础/","link":"","permalink":"http://yoursite.com/2016/05/23/PHP学习笔记——基础/","excerpt":"","text":"努力学习，天天向上！ echo 和 print echo: 能够输出一个以上的字符串； print: 只能输出一个字符串，并始终返回1 123456789$txt1 = \"Learn php&lt;br&gt;\";$txt2 = array(\"Volvo\", \"BMW\", \"SAAB\");echo($txt1); // Learn phpecho(\"my car is &#123;$txt2[1]&#125;&lt;br&gt;\"); // my car is BMWecho \"my \", \"car \", \"is \", \"BMW\"; // my car is BMWecho(\"&lt;br&gt;\");print(\"my car is &#123;$txt2[0]&#125;\"); // my car is Volvo// print \"my car is &#123;$txt2[2]&lt;br&gt;&#125;\"; // 注意字符串中能包含 HTML 标记,如&lt;br&gt;;// print(\"Hello\", \"world\"); // print 只能输出一个字符串 var_dump()1234567891011121314echo(\"&lt;br&gt;\");var_dump(-444); // 整型 int(-444)echo(\"&lt;br&gt;\"); var_dump(4.456); // 浮点类型 float(4.456)echo(\"&lt;br&gt;\"); var_dump(0x34); // 十六进制 int(52) echo(\"&lt;br&gt;\"); var_dump(076); // 八进制 int(62)echo(\"&lt;br&gt;\"); var_dump(2.4e-3); // float(0.0024)echo(\"&lt;br&gt;\");var_dump($txt2); // 数组 array(3) &#123; [0]=&gt; string(5) \"Volvo\" [1]=&gt; string(3) \"BMW\" [2]=&gt; string(4) \"SAAB\" &#125; echo(\"&lt;br&gt;\");var_dump($null); // NULL 字符串12345678// 字符串长度echo \"字符串长度：\", strlen(\"HELLO\"); // 5echo(\"&lt;br&gt;\");// 文本检索echo \"文本检索：\", strpos(\"Hello world\", \"world\"); // 6echo(\"&lt;br&gt;\");echo \"文本检索：\", strpos(\"Hello world\", \"III\"); // echo(\"&lt;br&gt;\"); define()常量：常量用define()定义，且一旦被定义就无法更改或者撤销定义。常量以字符或者下划线开头（常量名称前面没有$符号）。类似OC中的宏。 12define(\"BGCOLOR\", \"green\");echo \"BGCOLOR: \",BGCOLOR; // BGCOLOR: green 字符串运算符 . 串接 123$one = \"Hello\";$two = $one.\" world&lt;br&gt;\";echo($two); // Hello world .= 串接赋值 12$one .= \" world&lt;br&gt;\";echo($one); // Hello world 递增 ++$x: 先递增，后返回; $x++: 先返回，后递增; 1234567$x = 10;echo ++$x; // 11echo(\"&lt;br&gt;\");$y = 10;echo $y++; // 10echo(\"&lt;br&gt;\"); 比较运算符 ==： 等于（如果$x等于$y,则返回true） ===：全等（如果 $x 等于 $y，且它们类型相同，则返回 true。） 12345678$p = 100;$q = \"100\";var_dump($p == $q); // trueecho(\"&lt;br&gt;\");echo $p === $q;var_dump($p === $q); // falseecho(\"&lt;br&gt;\"); 逻辑运算符 xor: 异或（如果 $x 和 $y 有且仅有一个为 true，则返回 true。） 1var_dump(34&gt;45 xor 33 == 33); // true 数组运算符12345678910111213141516171819202122$array_1 = array(\"a\"=&gt;\"red\", \"b\"=&gt;\"green\");$array_2 = array(\"a\"=&gt;\"yellow\", \"d\"=&gt;\"blue\");$array_3 = array(\"a\"=&gt;\"yellow\", \"d\"=&gt;\"blue\");$array_4 = array(\"d\"=&gt;\"blue\", \"a\"=&gt;\"yellow\");// key被覆盖，但value值不会呗覆盖var_dump($array_1 + $array_2); // array(3) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"d\"]=&gt; string(4) \"blue\" &#125; echo(\"&lt;br&gt;\");// 如果 $x 和 $y 拥有相同的键/值对，则返回 true。var_dump($array_1 == $array_3); // bool(false) echo(\"&lt;br&gt;\");var_dump($array_2 == $array_3); // bool(true) echo(\"&lt;br&gt;\");// 如果 $x 和 $y 拥有相同的键/值对，且顺序相同类型相同，则返回 true。var_dump($array_3 === $array_4); // bool(false)echo(\"&lt;br&gt;\");var_dump($array_3 === $array_2); // // bool(true) echo(\"&lt;br&gt;\");","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"移动端数据库Realm","slug":"移动端数据库Realm","date":"2016-05-17T06:57:20.000Z","updated":"2016-11-18T02:49:52.000Z","comments":true,"path":"2016/05/17/移动端数据库Realm/","link":"","permalink":"http://yoursite.com/2016/05/17/移动端数据库Realm/","excerpt":"","text":"Realm是一个跨平台移动数据库引擎，支持iOS、OS X（Objective-C和Swift）以及Android。 目标是取代SQLite。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[]},{"title":"TypeEncodings","slug":"TypeEncodings","date":"2016-05-17T04:48:59.000Z","updated":"2016-11-18T02:51:09.000Z","comments":true,"path":"2016/05/17/TypeEncodings/","link":"","permalink":"http://yoursite.com/2016/05/17/TypeEncodings/","excerpt":"","text":"Type_Encodings是运行时系统的辅助工具。编译器将函数返回值、参数类型以及实现编译成特定的字符。例如：v@:表示：参数类型为静态类型或者id类型，无返回值的一个方法实现。 @encode()1char *buf1 = @encode(void); // buf1 = v&#10;char *buf2 = @encode(float); // buf2 = f&#10;char *buf3 = @encode(NSArray); // buf3 = &#123;NSArray=#&#125; Objective-C type encodings Code Meaning c A char i An int s A short l A long q A long long c An unsigned char I An unsigned int S An unsigned short L An unsigned long Q An unsigned long long f A float d A double B A C++ bool or a C99 _Bool v A void * A character string (char *) @ An object (whether statically typed or typed id) # A class object (Class) : A method selector (SEL) [array type] An array Code Meaning {name=type…} A structure (name=type…) A union bnum A bit field of num bits ^type A pointer to type ? An unknown type (among other things, this code is used for function pointers) r const n in N inout o out O bycopy R byref V oneway **OC不支持long double类型的编码。 @encode(long double)返回值是d, 与@encode(double)编码结果一样","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/编码/"}]},{"title":"Swift中protocol的三种实现以及mutating关键词","slug":"Swift中protocol的三种实现以及mutating关键词","date":"2016-05-11T09:12:21.000Z","updated":"2016-11-18T02:53:23.000Z","comments":true,"path":"2016/05/11/Swift中protocol的三种实现以及mutating关键词/","link":"","permalink":"http://yoursite.com/2016/05/11/Swift中protocol的三种实现以及mutating关键词/","excerpt":"","text":"Swift中protocol除了可以被class实现外，也可以被struct和enum实现。而mutating关键词则出现在当你用struct或者enum来实现协议并且在协议方法中修改变量的值得时候，用mutating来修饰协议方法。 首先，定义一个protocol12345678910// 协议protocol VehicleProtocol &#123; // 颜色 var color: UIColor&#123;get set&#125; // 改变颜色(假定changeColor()方法要改变 color 的值，则需要用 mutating 关键词修饰) mutating func changeColor() &#125; 结构体实现协议123456789// 结构体实现协议struct StructProtocol: VehicleProtocol &#123; var color: UIColor = UIColor.blueColor() // 此处需要 mutating 关键词修饰 mutating func changeColor() &#123; color = UIColor.redColor() &#125;&#125; 类实现协议123456789// 类实现协议class ClassProtocol: VehicleProtocol &#123; var color: UIColor = UIColor.blueColor() // 此处 不需要使用 mutating 关键词来修饰 func changeColor() &#123; color = UIColor.greenColor() &#125;&#125; 枚举实现协议12345678910111213141516171819202122232425262728293031// 枚举实现协议enum EnumProtocol: VehicleProtocol &#123; case first(UIColor) var color: UIColor &#123; get &#123; switch self &#123; case .first(UIColor.blueColor()): return UIColor.blueColor() case .first(UIColor.redColor()): return UIColor.purpleColor() default: return UIColor.whiteColor() &#125; &#125; set &#123; switch self &#123; case .first(_): self = .first(newValue) &#125; &#125; &#125; // 此处需要 mutating 关键词修饰 mutating func changeColor() &#123; switch self &#123; case .first(UIColor.blueColor()): self = .first(UIColor.redColor()) default: self = .first(UIColor.whiteColor()) &#125; &#125; &#125; 本文代码链接：https://github.com/zhangzhaopds/Protocol_mutating.git","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"mutating","slug":"mutating","permalink":"http://yoursite.com/tags/mutating/"},{"name":"protocol","slug":"protocol","permalink":"http://yoursite.com/tags/protocol/"}]},{"title":"大牛们的博客集","slug":"大牛们的博客集","date":"2016-05-06T03:40:28.000Z","updated":"2016-11-18T02:54:01.000Z","comments":true,"path":"2016/05/06/大牛们的博客集/","link":"","permalink":"http://yoursite.com/2016/05/06/大牛们的博客集/","excerpt":"","text":"活到老，学到老，学无止境！ Github备忘录一个涵盖了iOS开发各个方面知识的github链接集合，整体来说比较全面：http://github.ibireme.com/github/list/ios/，来自于于YYKit的博客 Blogs备忘录 唐巧的技术博客 http://blog.devtang.com/atom.xml YYKit http://blog.ibireme.com/about/ OneV’s Den http://onevcat.com/atom.xml 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy Lex iOS notes http://ios.lextang.com/rss 念茜的博客 http://nianxi.net/feed.xml Xcode Dev http://blog.xcodev.com/atom.xml Ted’s Homepage http://wufawei.com/feed txx’s blog http://blog.t-xx.me/atom.xml KEVIN BLOG http://imkevin.me/rss 阿毛的蛋疼地 http://www.xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed 言无不尽 http://tang3w.com/atom.xml Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ vclwei http://vclwei.com/posts.rss Cocoabit http://blog.cocoabit.com/atom.xml nixzhu on scriptogr.am http://nixzhu.me/feed 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://www.taofengping.com/rss.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://webfrogs.me/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://www.imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 会写代码的猪 http://gaosboy.com/feed/atom/ 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 Shining IO http://shiningio.com/atom.xml YIFEIYANG—易飞扬的博客 http://www.yifeiyang.net/feed KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml 标哥的技术博客http://www.henishuo.com ​ ​","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]},{"title":"在Mac上搭建HLS视频直播","slug":"在Mac上搭建HLS视频直播","date":"2016-05-05T01:59:16.000Z","updated":"2016-11-18T02:52:48.000Z","comments":true,"path":"2016/05/05/在Mac上搭建HLS视频直播/","link":"","permalink":"http://yoursite.com/2016/05/05/在Mac上搭建HLS视频直播/","excerpt":"","text":"HTTP Live Streaming(HLS)， 是苹果公司推出的视频直播协议，具体的内容可以到苹果开发者后台查看相关文档。简单地讲，就是将实时直播的视频，切割成大小基本相等的.ts 文件和一个索引文件prog_index.m3u8,然后通过索引文件来在web或者app中实现直播效果。 目标/思路本文目标：利用HLS技术，模拟一个视频直播平台。具体包括以下几个步骤： 通过VLC模拟一个直播视频的输入源； 利用mediastreamsegmenter将捕捉到的输入源视频切割成 .m3u8 格式文件； 利用Apache搭建本地服务器，在Safari中打开localhost，实现直播效果。 具体实现VLC: 多媒体播放器 直接在百度上输入VLC，搜索下载安装Mac版的。 配置VLC: 打开VLC —&gt; Open media —&gt; Browse选择视频输入源，即将要用来以直播的形式展现出来的视频；然后勾选 Streaming/Saving,点击Setting,进行设置； 其中，Address是当前Mac的ip地址，Port自定义。这个地址是输入源视频的地址，在切割视频的时候会用到这个地址。配置完成之后，点击ok, 然后如果你的视频很短，就不要着急点击open。 启动Apache本地服务器 打开Mac终端，执行指令 sudo apachectl start, 在浏览器中打开 localhost，如果出现 It works，则说明Apache打开成功； 在路径 /Library/WebServer/Documents/下建立文件新文件，我建的是 Games； 在路径 /Library/WebServer/Documents/下新建一个文件名为index.html文件，html里的内容为： 12345678&lt;html&gt; &lt;head&gt; &lt;meda name=\"viewport\" content=\"width=320;initial-scale=1.0;maximum-scale=1.0;user-scalable=0;\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;video src=\"Games/prog_index.m3u8\" controls autoplay&gt;&lt;/video&gt;&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; mediastreamsegmenter切割视频 这个是苹果公司提供的视频切割工具，可以在https://developer.apple.com/streaming/进行下载，需要开发者账号登陆； 在终端运行mediastreamsegmenter -s 20 -D -f /Library/WebServer/Documents/Games 192.168.1.113:1234, 同时将运行VLC,即点击VLC中的Open。 在Safari中打开localhost, 刚开始出现的是一个含有错误字样的播放控制条，稍等一会，直播就开始了。 注意：VLC，mediastreamsegmenter，和Apache，在同一时间段，都要处于开启状态才可以在浏览器中看到直播效果。 参考文档：https://developer.apple.com/library/ios/technotes/tn2224/_index.html https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"HLS","slug":"HLS","permalink":"http://yoursite.com/tags/HLS/"},{"name":"直播","slug":"直播","permalink":"http://yoursite.com/tags/直播/"}]},{"title":"Mac上使用Apache搭建服务器","slug":"Mac上使用Apache搭建服务器","date":"2016-05-04T08:08:24.000Z","updated":"2016-11-18T02:50:06.000Z","comments":true,"path":"2016/05/04/Mac上使用Apache搭建服务器/","link":"","permalink":"http://yoursite.com/2016/05/04/Mac上使用Apache搭建服务器/","excerpt":"","text":"本来是要搞HLS(苹果的视频直播处理技术)的，而且已经将mp4文件分割成m3u8类型直播文件，最后要验证m3u8文件的时候，却发现是要利用服务器来处理的，所以只好查了些服务器的知识。因为Mac自带Apache，所以为了省事就直接学习了下就拿来用了。 启用Apache 开启apache命令：sudo apachectl start 关闭apache命令：sudo apachectl stop 重启apache命令：sudo apachectl restart 开启apache后，可以直接在浏览器中访问 localhost, 如果出现“It works”，表示运行正常。 具体使用：目标：在浏览器中打开localhost，显示自定义的web页面。 在Mac的Finder中，利用前往文件夹，进入路径/Library/WebServer/Documents，这是默认的根路径，里面有三个文件：index.html.en, PoweredByMacOSX.gif, PoweredByMacOSXLarge.gif。这三个文件不用管，放在那里就行。 利用Coda，或者eclipse创建一个html文件，内容自己定义就行。然后将这个html文件名字改为index.html, 只能是这个名字，除非你利用vim更改Apache的httpd.conf文件，重新配置首页文件名。 将创建的index.html文件保存到 /Library/WebServer/Documents下。因为这是个私有文件夹，是需要root权限的，所有每次更改这个文件夹都是需要输入Mac密码的，除非Mac没有设定密码。 最后，浏览器中打开localhost,就可以看到自定义的html。 当然，也可以利用Xcode创建一个工程，利用UIWebView进行验证。只需要将 localhost 换成 Mac当前连接的网络的IP就行, URL最好是：http://192.168.1.103， 也可以是：http://localhost。 具体可看以下代码： 1UIWebView *web = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];&#10; [web setScalesPageToFit:YES];&#10; [self.view addSubview:web];&#10; [web loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&#34;http://192.168.1.103&#34;]]];&#9;// 192.168.1.103 &#25442;&#25104;&#20320;&#30340;ip&#22320;&#22336;&#23601;&#34892;","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[]},{"title":"Cookie","slug":"Cookie","date":"2016-05-03T08:15:58.000Z","updated":"2016-11-18T02:49:03.000Z","comments":true,"path":"2016/05/03/Cookie/","link":"","permalink":"http://yoursite.com/2016/05/03/Cookie/","excerpt":"","text":"许多网站登录了一次之后，下次就不需要再次登录。这种操作很常见，然而网页与程序的逻辑是完全的不同，也就是说网页并不像程序那样拥有自己的存储路径。 Web端基本都是使用HTTP/HTTPS协议传输数据的。这种协议是无状态的协议。也就是说一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪上次的状态。所以为了解决以上问题，W3C组织提出了Cookie(甜饼)。 由于HTTP是一种无状态的协议，服务器单从网络连接上是无法知道客户身份。那如何解决呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理 Cookie本质上是一小段的文本信息，当客户端请求服务器的时候，如果服务器需要记录客户端状态，就会向客户端颁发一个Cookie。客户端会把Cookie保存起来，当客户端再次请求的时候，把网址以及保存下来的Cookie一同提交服务器，这样服务器就可以辨认用户的状态。 iOS中网络请求中的CookieiOS中的网络请求对于Cookie的支持是非常强大的，当你访问一个网站的时候，NSURLRequest都会帮你记录访问站点的Cookie，而且当你下次访问这个网站的时候，NSURLRequest会带着上次保存下来的Cookie继续请求。 1234567891011// 请求一个网址，即可分配到cookie let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: NSURL.init(string: \"http://www.tongxingpay.com\")!) let sessionConfig: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration() let session: NSURLSession = NSURLSession.init(configuration: sessionConfig) let task: NSURLSessionDataTask = session.dataTaskWithRequest(request) &#123; (data, response, error) in // 打印 cookie print(NSHTTPCookieStorage.sharedHTTPCookieStorage().cookies) &#125; task.resume()","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]},{"title":"Typora","slug":"Typora","date":"2016-04-29T05:17:56.000Z","updated":"2016-11-18T02:49:38.000Z","comments":true,"path":"2016/04/29/Typora/","link":"","permalink":"http://yoursite.com/2016/04/29/Typora/","excerpt":"","text":"Typora是一款非常方便的Markdown文档编辑器，相对于Mou来说，它的强大之处在于它的及时渲染, 将【写字】与【预览】这两件事情合并了。What You See Is What You Get. 表格添加表格，只需Command+T即可。表格里面的文本对齐方式类似于office一样方便设置。 标题一 标题二 标题三 左对齐 居中 右对齐 代码Typora 里代码和数学公式的输入，也做得一样出色。当插入代码区域时，你可以先选择代码的种类，Typora 基本支持了所有主流的代码高亮（C#、PHP、Java 等等），连 Swift 也不在例外。而数学公式更加，Typora 甚至连 Latex 都支持了。 1var custom: String = \"友谊的小船说翻就翻\" 照片对于图片可以直接进行拖拽，方便快捷。下面这个就是一张图片。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[]},{"title":"Swift代码片段：颜色值","slug":"Swift代码片段：颜色值","date":"2016-04-28T03:36:40.000Z","updated":"2016-11-18T02:47:41.000Z","comments":true,"path":"2016/04/28/Swift代码片段：颜色值/","link":"","permalink":"http://yoursite.com/2016/04/28/Swift代码片段：颜色值/","excerpt":"","text":"利用延展，为UIColor添加颜色值的初始化方法，遍历构造器。 extension UIColor { // 三色值 convenience init(red: Int, green: Int, blue: Int) { assert(red &gt;= 0 &amp;&amp; red &lt;= 255, &quot;Invalid red component&quot;) assert(green &gt;= 0 &amp;&amp; green &lt;= 255, &quot;Invalid green component&quot;) assert(blue &gt;= 0 &amp;&amp; blue &lt;= 255, &quot;Invalid blue component&quot;) self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: 1.0) } // 颜色值 0x6fd66b convenience init(netHex:Int) { self.init(red:(netHex &gt;&gt; 16) &amp; 0xff, green:(netHex &gt;&gt; 8) &amp; 0xff, blue:netHex &amp; 0xff) } }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[]},{"title":"Swift代码片段：GCD创建单例","slug":"Swift代码片段：单例","date":"2016-04-28T03:14:32.000Z","updated":"2016-11-18T02:47:32.000Z","comments":true,"path":"2016/04/28/Swift代码片段：单例/","link":"","permalink":"http://yoursite.com/2016/04/28/Swift代码片段：单例/","excerpt":"","text":"Swift中利用GCD创建单例 class var sharedInstance: QRMakeVC { struct Static { static var onceToken: dispatch_once_t = 0 static var instance: QRMakeVC? = nil } dispatch_once(&amp;Static.onceToken) { Static.instance = QRMakeVC() } return Static.instance! }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[]},{"title":"MQTT应用内消息推送","slug":"MQTT消息推送","date":"2016-04-11T06:35:30.000Z","updated":"2016-11-18T02:47:03.000Z","comments":true,"path":"2016/04/11/MQTT消息推送/","link":"","permalink":"http://yoursite.com/2016/04/11/MQTT消息推送/","excerpt":"","text":"因为需求，需要从服务器获取支付结果的通知，而后台已经在POS和安卓端使用MTQQ,没办法iOS端消息推送也只能用MTQQ，查询了一些资料发现MTQQ好像要比信鸽、极光的应用内消息更加简单点，至少iOS端少去了推送证书的配置等一些繁琐的流程。MQTT本质上就是一个TCP长连接而已。 MQTTKitDEMO_1DEMO_2 初始化MQTT// 获取设备uuid if Keychain.load(&quot;kUUID&quot;) == nil { let uuidRef: CFUUIDRef = CFUUIDCreate(kCFAllocatorDefault) Keychain.save(&quot;kUUID&quot;, data: CFUUIDCreateString(kCFAllocatorDefault, uuidRef)) } let uuid: String = Keychain.load(&quot;kUUID&quot;) as! String // clientId:用来区分接受消息的设备，此处我用的是设备的UUID,并保存在了钥匙串里，确保唯一性。 mqtt = MQTTSession.init(clientId: uuid, userName: &quot;name&quot;, password: &quot;psw&quot;) mqtt?.connectToHost(&quot;111.111.111.111&quot;, port: 1111) mqtt?.setDelegate(self) 消息回调链接状态回调 // 链接状态回调 override func session(session: MQTTSession!, handleEvent eventCode: MQTTSessionEvent) { switch eventCode { case MQTTSessionEventConnected: print(&quot;消息推送: connected&quot;) // 链接成功后，订阅主题 self.mqtt?.subscribeTopic(&quot;TX_APP_PAY&quot;) case MQTTSessionEventConnectionRefused: print(&quot;消息推送: connection refused&quot;) case MQTTSessionEventConnectionClosed: print(&quot;消息推送: connection closed&quot;) case MQTTSessionEventConnectionError: print(&quot;消息推送: connection error&quot;) print(&quot; reconnecting...&quot;) // 链接错误的话，尝试重新链接 self.mqtt?.connectToHost(&quot;111.111.111.111&quot;, port: 1111) case MQTTSessionEventProtocolError: print(&quot;消息推送: protocol error&quot;) default: break } } 接收到消息回调 // 接收到消息回调 override func session(session: MQTTSession!, newMessage data: NSData!, onTopic topic: String!) { var dic = NSDictionary() do { dic = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers) as! NSDictionary } catch { } print(&quot;推送内容：&quot;, dic) print(&quot;推送主题：&quot;, topic) }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"MQTT","slug":"MQTT","permalink":"http://yoursite.com/tags/MQTT/"}]},{"title":"GCD_API_Main/Global_Dispatch_Queue","slug":"GCD-API-Main-Global-Dispatch-Queue","date":"2016-04-04T03:21:17.000Z","updated":"2016-11-18T02:31:44.000Z","comments":true,"path":"2016/04/04/GCD-API-Main-Global-Dispatch-Queue/","link":"","permalink":"http://yoursite.com/2016/04/04/GCD-API-Main-Global-Dispatch-Queue/","excerpt":"","text":"获取系统标准提供的Dispatch Queue: Main Dispatch Queue 和 Global Dispatch Queue. Main Dispatch QueueMain Dispatch Queue 正如其名称中含有的‘main’一样，是在主线程中执行Dispatch Queue。因为主线程只有一个，所以Main Dispatch Queue 自然就是 Serial Dispatch Queue。 追加到 Main Dispatch Queue 的处理在主线程的RunLoop中执行。由于在主线程中执行，因此要将用户界面的界面更新等一些必须在主线程中执行的处理追加到 Main Dispatch Queue 使用。 Global Dispatch QueueGlobal Dispatch Queue 是所有的应用程序都能够使用的 Concurrent Dispatch Queue。 没有必要通过 dispatch_queue_create 函数逐个生成 Concurrent Dispatch Queue。 只要获取 Global Dispatch Queue 使用就行。 获取方法// 获取 Main Dispatch Queue let mainDispatchQueue: dispatch_queue_t = dispatch_get_main_queue() // 获取 Global Dispatch Queue(高优先级) let globalDispatchQueueHigh: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) // 获取 Global Dispatch Queue(默认优先级) let globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) // 获取 Global Dispatch Queue(低优先级) let globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0) // 获取 Global Dispatch Queue(后台优先级) let globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0) 常用例子// 在默认优先级 Global Dispatch Queue 中执行 Block dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { // 可以并行执行的处理（如： 图片下载） // 在 Main Dispatch Queue 中执行的 Block dispatch_async(dispatch_get_main_queue(), { // 只能在主线程中执行的处理（如：将缓存在本地的图片呈现在界面中） }) }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"Global_Dispatch_Queue","slug":"Global-Dispatch-Queue","permalink":"http://yoursite.com/tags/Global-Dispatch-Queue/"}]},{"title":"GCD_API_DispatchQueue","slug":"CGD-API-DispatchQueue","date":"2016-03-31T10:35:06.000Z","updated":"2016-11-18T02:46:26.000Z","comments":true,"path":"2016/03/31/CGD-API-DispatchQueue/","link":"","permalink":"http://yoursite.com/2016/03/31/CGD-API-DispatchQueue/","excerpt":"","text":"关于 Dispatch Queue 和 Dispatch_queue_create 的介绍。 Dispatch QueueDispatch Queue,字面意思就是执行处理的等待队列。将想要执行的任务，通过dispatch_async函数“追加”赋值在变量queue的“Dispatch Queue”中。放在dispatch_async函数的block里面的任务就可以在另个一线程中执行。 dispatch_async(queue) { // 想要执行的任务 } Dispatch Queue 按照追加的顺序（先进先出FIFO）执行处理。 Dispatch Queue 分为两种：Serial Dispatch Queue 和 Concurrent Dispatch Queue。 Serial Dispatch QueueSerial Dispatch Queue 等待处理结束。简单的理解，比方说，Dispatch Queue中有多个任务，那么这几个任务只能使用同一个线程，按照这几个任务添加的顺序，逐个处理。 优点：可以有效的避免数据多线程产生的数据竞争问题。因为一个Serial Dispatch Queue只能有一个线程。当然，如果你创建3000个这样的queue,就又会绕到多线程消耗大量内存的问题上来，会大幅度降低系统的响应性能。过犹不及。因此，Serial Dispatch Queue的生成个数应当仅限所必须的数量。 Concurrent Dispatch QueueConcurrent Dispatch Queue 不等待处理。当在这种Dispatch Queue中有多个任务时，会有多个线程来处理这些任务。比方说，有3个线程A、B、C, 5个先后添加的任务a.b.c.d.e, 那么线程A就会处理任务a, 同时B处理b, C处理c; 如果线程B优先其他线程把任务处理完了，那么线程B就会去处理任务d; 下一个空余出来的线程就会去处理任务e, 直至任务都处理完成。 Dispatch_queue_create创建一个Dispatch_queue时会使用用到函数Dispatch_queue_create。 // 创建一个Serial Dispatch Queue let mySerialQueue: dispatch_queue_t = dispatch_queue_create(&quot;com.SerialDispatchQueue&quot;, nil) // 创建一个Concurrent Dispatch Queue let myConcurrentQueue: dispatch_queue_t = dispatch_queue_create(&quot;com.SerialDispatchQueue&quot;, DISPATCH_QUEUE_CONCURRENT) 以上是创建这两种dispatch_queue的方法，区别在于第二个参数的设定，第一个参数是dispatch_queue的署名。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]},{"title":"GCD","slug":"GCD学习笔记","date":"2016-03-30T13:06:18.000Z","updated":"2016-11-18T02:46:20.000Z","comments":true,"path":"2016/03/30/GCD学习笔记/","link":"","permalink":"http://yoursite.com/2016/03/30/GCD学习笔记/","excerpt":"","text":"时间总是匆匆而过，上篇学习笔记还在月初，这篇就已经到月末了，感觉对自己太溺爱了。还是看看书，写点笔记，督促自己不断学习吧！ 什么是GCDGrand Central Dispath(GCD),就是异步执行任务的一种技术。简单地说就是GCD提供了极为简单的方法，实现了极为复杂繁琐的多线程编程。 // 自定义一个线程 let queue: dispatch_queue_t = dispatch_queue_create(&quot;myqueue&quot;, nil) // 耗时的任务放到后台处理 dispatch_async(queue) { var num = Int() for i in 1...900 { num += i } // 在主线程中打印求和结果 dispatch_async(dispatch_get_main_queue(), { print(num) }) } 以上就是一个很简单地GCD应用，开辟新的线程用来处理耗时的任务，在主线程中处理必要操作，比如UI的展示，网络请求结果的处理等。 多线程多线程说白了，就像工厂里面的流水线，每条流水线都有各自的任务，流水线之间原则上没有太大的相关性。 使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，看上去就像一个CPU核能够并列的执行多个线程一样。当然，多个CPU核的情况下，是真的提供了多个CPU核并列执行多个线程的技术。 多线程的优点：1、数据竞争（多个线程更新相同的资源会导致数据的不一致）；2、死锁(停止等待事件的线程会导致多个线程相互持续等待)；3、使用太多线程会消耗大量内存等。 多线程的优点：使用多线程编程，在执行长时间的处理是仍可保证用户界面的响应性能。比如：程序启动的时候，最先执行的是主线程，用来描绘用户界面、处理触摸屏幕的事件等；而其他耗时操作，如数据请求、图片下载等则是开辟新的线程进行处理。这样可以避免妨碍主线程中NSRunLoop的执行，从而保证用户界面的响应性能。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]},{"title":"URL中特殊字符的转义","slug":"URL中特殊字符的处理","date":"2016-03-30T03:40:38.000Z","updated":"2016-11-18T02:45:07.000Z","comments":true,"path":"2016/03/30/URL中特殊字符的处理/","link":"","permalink":"http://yoursite.com/2016/03/30/URL中特殊字符的处理/","excerpt":"","text":"在做RSA签名和加密的过程中，由于RSA生成的字段中含有 + ,需要进行转义，思路很简单，但总有坑要跳 解决思路// 对URL进行转义 - (NSString *)formatURLwithText:(NSString *)text { return (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)text, NULL, (CFStringRef)@&quot;!*’();:@&amp;=+$,/?%#[]&quot;, kCFStringEncodingUTF8)); } 上面代码是就是最近本的处理方法，关键在用的时机。 生成sign值：通常的做法是对所有参数按key排序，然后拼接成a=x&amp;b=y…这样的字符串，然后RSA一下。但是如果encode一下，iOS端和安卓端出现不同的结果，那么服务端拿到以后是可以得到原串的，但是服务端encode一下所得到的结果会不一样，那么校验sign就会失败。 但是，如果不对每个value进行转码，在服务端就无法通过&amp;来分割了，因为value中有&amp;时，若不转码就会出问题，因此encode是必须的。 解决方法：生成sign时，是遍历所有的key-value，然后拼接，最后RSA。那么，生成sign时，我们只要不对value进行encode，而其他上传的参数值都encode，这样就可以解决我们的问题了。 注意点：转义之后的URL不可再用encode；例如，value里面含有中文字段，正常情况下是要进行中文编码的，如果调用转义的方法后，就不需要在进行中文编码的。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"字符转义","slug":"字符转义","permalink":"http://yoursite.com/tags/字符转义/"}]},{"title":"高阶函数：map、flatMap、forEach、filter、reduce","slug":"高阶函数：map、flatMap、forEach、filter、reduce","date":"2016-03-15T03:40:38.000Z","updated":"2016-11-18T02:33:12.000Z","comments":true,"path":"2016/03/15/高阶函数：map、flatMap、forEach、filter、reduce/","link":"","permalink":"http://yoursite.com/2016/03/15/高阶函数：map、flatMap、forEach、filter、reduce/","excerpt":"","text":"高阶函数：函数作为参数或者函数作为返回值。 函数的写法：1.正常写法let res = numbers.sort({$0 &lt; $1}) 2.Trailing Closurelet ree = numbers.sort{$0 &lt; $1} 常用实例map函数：map函数：当数组调用map函数时，闭包作为它的参数，闭包实现对数组单个元素进行某种规则的处理，最终map函数返回一个原数组元素被闭包处理过的新的数组（新的数组元素个数和原先的相等，数组类型可自定义，如数组类型由[Int],变为[String] 或者 [Bool]等）。 let arr = [1, 2, 9, 4, 5] // 写法一：推荐写法 let mrr1 = arr.map { &quot;step.&quot; + String($0) } // 写法二： let mrr2 = arr.map { (a: Int) -&gt; String in &quot;step.&quot; + String(a) } // 写法三： let mrr3 = arr.map ({ (a: Int) -&gt; String in &quot;step.&quot; + String(a) }) flatMap函数：flatMap函数：功能和map函数基本相同，不同之处在于，flatMap生成的数组自动去除nil。 // 1、去除nil let frr = [&quot;af&quot;, &quot;vf&quot;, &quot;&quot;] let frr1 = frr.flatMap { (a: String) -&gt; Int? in if a.characters.count == 0 { return nil } else { return a.characters.count } } // [2,2] // 2、对嵌套数组的拆分合并 let fmp = [[2, 6, 4], [5, 3, 7]] let fmp1 = fmp.flatMap { (a: [Int]) -&gt; [Int] in a } // [2, 6, 4, 5, 3, 7] let fmp2 = fmp.map { (a: [Int]) -&gt; [Int] in a } // [[2, 6, 4], [5, 3, 7]] // 3、对不同类型数组的合并 let c = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] let i = [1, 2] let fmp3 = i.flatMap { car in c.map { num in num + &quot;\\(car)&quot; } } // [&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;, &quot;a2&quot;, &quot;b2&quot;, &quot;c2&quot;] filter函数：let err = arr.filter { (a: Int) -&gt; Bool in a % 2 == 0 } // [2, 4] forEach函数：arr.forEach { (a: Int) -&gt; () in print(a) } reduce函数：reduce函数：把数组元素合并成一个新的值, 新值类型不固定。有两个参数，第一个参数是返回值的初始值；第二个参数是一个处理数组元素的函数。 // 返回Int let crr = arr.reduce(0) { (prevSum: Int, elemen: Int) in return prevSum + elemen } // 返回String let crr2 = arr.reduce(&quot;&quot;) { &quot;\\($0)&quot; + &quot;\\($1)&quot; } // 实现map和filter extension Array { func mMap&lt;U&gt; (transform: Element -&gt; U) -&gt; [U] { return reduce([], combine: { $0 + [transform($1)] }) } func mFilter (includeElement: Element -&gt; Bool) -&gt; [Element] { return reduce([]) { includeElement($1) ? $0 + [$1] : $0 } } } // 利用 reduce 实现 map let ass = arr.reduce([]) { (a: [Int], element: Int) -&gt;[Int] in var t = Array(a) t.append(element * 2) return t } // 利用 reduce 方法一次求出数组中奇数的和、以及偶数乘积 let sss:(Int, Int) = arr.reduce((0, 1)) { (a: (Int, Int), element: Int) -&gt; (Int, Int) in if element % 2 == 0 { return (a.0, a.1 * element) } else { return (a.0 + element, a.1) } } // 利用 reduce 方法一次求出数组中偶数的平方和 let kkk = arr.filter { $0 % 2 == 0 }.map { $0 * $0 }.reduce(0){ $0 + $1 }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"filter","slug":"filter","permalink":"http://yoursite.com/tags/filter/"},{"name":"flatMap","slug":"flatMap","permalink":"http://yoursite.com/tags/flatMap/"},{"name":"forEach","slug":"forEach","permalink":"http://yoursite.com/tags/forEach/"},{"name":"map","slug":"map","permalink":"http://yoursite.com/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"http://yoursite.com/tags/reduce/"}]},{"title":"NSURLSession_Swift","slug":"NSURLSession-Swift","date":"2016-03-09T06:46:51.000Z","updated":"2016-11-18T02:41:10.000Z","comments":true,"path":"2016/03/09/NSURLSession-Swift/","link":"","permalink":"http://yoursite.com/2016/03/09/NSURLSession-Swift/","excerpt":"","text":"一个简单地Swift语言的网络请求封装，包括数据请求、数据上传、图片下载、图片上传。 本文链接 数据请求/** 数据请求 - parameter urlStr: 请求地址 - parameter reponse: 请求结果 */ func get(urlStr: String, reponse: (result: AnyObject, response: NSURLResponse)-&gt;Void)-&gt;Void { if urlStr.isEmpty { print(&quot;Request address cannot be empty&quot;) return } let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! let url: NSURL = NSURL.init(string: strEncode)! let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url) let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) let task: NSURLSessionDataTask = session.dataTaskWithRequest(request) { (data, resp, err) -&gt; Void in if (err != nil) { print(&quot;Data request failed: \\(err?.code)&quot;) return } do { let json = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.MutableContainers) reponse(result: json, response: resp!) } catch { } } task.resume() } 数据下载/** 数据下载 - parameter urlStr: 请求地址 - parameter reponse: 数据本地保存地址 */ func downLoad(urlStr: String, reponse:(location: String)-&gt;Void)-&gt;Void { if urlStr.isEmpty { print(&quot;Request address cannot be empty&quot;) return } let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! let url: NSURL = NSURL.init(string: strEncode)! let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url) let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) let downLoadTask: NSURLSessionDownloadTask = session.downloadTaskWithRequest(request) { (location, resp, err) -&gt; Void in if (err != nil) { print(&quot;DownLoadData request failed: \\(err?.code)&quot;) return } let caches: String = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true).last! let file: String = caches.stringByAppendingString(&quot;/\\(resp!.suggestedFilename!)&quot;) if NSFileManager.defaultManager().fileExistsAtPath(file) { if NSThread.isMainThread() { reponse(location: file) } else { dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in reponse(location: file) }) } } else { do { try NSFileManager.defaultManager().moveItemAtPath(location!.path!, toPath: file) if NSThread.isMainThread() { reponse(location: file) } else { dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in reponse(location: file) }) } } catch { } } } downLoadTask.resume() } JSON数据上传/** 普通数据上传 - parameter urlStr: 上传地址 - parameter uploadData: 字典数据 - parameter reponse: 上传结果 */ func upLoadData(urlStr: String, uploadData: AnyObject, reponse: (result: AnyObject, response: NSURLResponse)-&gt;Void)-&gt;Void { if urlStr.isEmpty { print(&quot;Request address cannot be empty&quot;) return } let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! let url: NSURL = NSURL.init(string: strEncode)! let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url) request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;) request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;) request.HTTPMethod = &quot;POST&quot; request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringCacheData request.timeoutInterval = 20 do { let data: NSData = try NSJSONSerialization.dataWithJSONObject(uploadData, options: NSJSONWritingOptions.PrettyPrinted) let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) let uploadTask: NSURLSessionUploadTask = session.uploadTaskWithRequest(request, fromData: data, completionHandler: { (result, resp, err) -&gt; Void in if (err != nil) { print(&quot;UpLoadData request failed: \\(err?.code)&quot;) return } do { let json: AnyObject = try NSJSONSerialization.JSONObjectWithData(result!, options: NSJSONReadingOptions.MutableContainers) reponse(result: json, response: resp!) } catch { } }) uploadTask.resume() } catch { } } 图片上传 /** 图片上传 - parameter urlStr: 上传地址 - parameter uploadData: 图片数据 - parameter dataType: 图片类型 - parameter reponse: 上传结果 */ func upLoadImage(urlStr: String, image: UIImage, dataType: DataType, reponse: (result: String, response: NSURLResponse)-&gt;Void)-&gt;Void { if urlStr.isEmpty { print(&quot;Request address cannot be empty&quot;) return } let strEncode: String = urlStr.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! let url: NSURL = NSURL.init(string: strEncode)! let request: NSMutableURLRequest = NSMutableURLRequest.init(URL: url) var daa = NSData() switch dataType { case .JPEG: request.addValue(&quot;image/jpeg&quot;, forHTTPHeaderField: &quot;Content-Type&quot;) request.addValue(&quot;text/html&quot;, forHTTPHeaderField: &quot;Accept&quot;) daa = UIImageJPEGRepresentation(image, 1)! case .PNG: request.addValue(&quot;image/png&quot;, forHTTPHeaderField: &quot;Content-Type&quot;) request.addValue(&quot;text/html&quot;, forHTTPHeaderField: &quot;Accept&quot;) daa = UIImagePNGRepresentation(image)! } request.HTTPMethod = &quot;POST&quot; request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringCacheData request.timeoutInterval = 20 let session: NSURLSession = NSURLSession.init(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) let uploadTask: NSURLSessionUploadTask = session.uploadTaskWithRequest(request, fromData: daa, completionHandler: { (result, resp, err) -&gt; Void in if (err != nil) { print(&quot;UpLoadImage request failed: \\(err?.code)&quot;) return } let ss: String = String.init(data: result!, encoding: NSUTF8StringEncoding)! reponse(result: ss, response: resp!) }) uploadTask.resume() }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"网络封装","slug":"网络封装","permalink":"http://yoursite.com/tags/网络封装/"}]},{"title":"Fabric-Crashlytics","slug":"Fabric-Crashlytics","date":"2016-03-03T02:59:15.000Z","updated":"2016-11-18T02:37:31.000Z","comments":true,"path":"2016/03/03/Fabric-Crashlytics/","link":"","permalink":"http://yoursite.com/2016/03/03/Fabric-Crashlytics/","excerpt":"","text":"Fabric是Twitter公司提供的一款，应用于移动应用开发，统计应用崩溃信息的工具。操作简单，使用方便。 使用介绍申请账号Crashlytics的服务是免费提供的，但是并不能直接注册使用，需要先申请，打开 Crashlytic的官网 ，输入自己的邮箱申请使用。之后Fabric会发一封确认邮件，确认成功之后，还会发一封Welcome to Fabric的邮件，点击Get Started with Fabric，根据提示，现在安装Mac端的App，登陆并根据提示完成配置。 设置工程1、点击&quot;+ New App&quot; 添加工程项目； 2、根据提示配置&quot;Run Script&quot;。打开工程-&gt;Build Phases-&gt;Editor-&gt;Add Build Phase-&gt;Add Run Script Build Phase, 然后将Fabric提供的代码粘贴到Shell下， 然后Command+B; 3、按照提示，将Fabric提供的frameworks(图标)拖到工程里，然后粘贴复制相关代码。 测试1、可以直接使用Fabric提供的强行Crash代码进行测试，也可以自己写个。 2、测试的时候需要脱离Xcode的调试环境。最简单的方法就是真机测试，但要注意的是，测试的时候手机和Xcode不要用数据线连接。测试之后，会收到Fabric的测试报告，出现Crash的具体位置，十分方便。 3、用户也可以在AppStore中下载Fabric,在手机端查看测试报告。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"},{"name":"应用分析工具","slug":"应用分析工具","permalink":"http://yoursite.com/tags/应用分析工具/"}]},{"title":"Spotlight","slug":"Spotlight","date":"2016-02-29T05:17:43.000Z","updated":"2016-11-18T02:44:01.000Z","comments":true,"path":"2016/02/29/Spotlight/","link":"","permalink":"http://yoursite.com/2016/02/29/Spotlight/","excerpt":"","text":"iOS9推出的Core Spotlight(CS)框架，利用CS做应用内搜索。本文链接 框架导入MobileCoreServices.framework和CoreSpotligt.framework 主要代码// 设置spotlight - (void)setSpotligtht { self.searchItemArr = [NSMutableArray array]; int i = 0; for (NSDictionary *dic in self.dataArr) { CSSearchableItemAttributeSet *searchItemSet = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:(NSString *)kUTTypeText]; // 标题 searchItemSet.title = [dic objectForKey:@&quot;title&quot;]; // 描述 searchItemSet.contentDescription = [dic objectForKey:@&quot;desc&quot;]; NSArray *arr = [[dic objectForKey:@&quot;picture&quot;] componentsSeparatedByString:@&quot;.&quot;]; // 设置照片路径 searchItemSet.thumbnailURL = [[NSBundle mainBundle] URLForResource:arr[0] withExtension:arr[1]]; // 搜索关键词 keywords(字符串形式) / contactKeywords(数组形式) searchItemSet.keywords = [dic objectForKey:@&quot;title&quot;]; /* uniqueIdentifier：这个参数唯一地标识Spotlight当前搜索项。你可以用你喜欢的方式构造这个唯一标示符。 domainIdentifier:使用这个参数对搜索项进行分组。 attributeSet：它就是我们刚刚设置属性时的属性设置对象。 */ CSSearchableItem *searchItem = [[CSSearchableItem alloc] initWithUniqueIdentifier:[NSString stringWithFormat:@&quot;com.spolight.%d&quot;, i] domainIdentifier:@&quot;books&quot; attributeSet:searchItemSet]; [self.searchItemArr addObject:searchItem]; i++; } [[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:self.searchItemArr completionHandler:^(NSError * _Nullable error) { if (error) { NSLog(@&quot;%@&quot;, error.localizedDescription); } }]; }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"Spotlight","slug":"Spotlight","permalink":"http://yoursite.com/tags/Spotlight/"},{"name":"应用内搜索","slug":"应用内搜索","permalink":"http://yoursite.com/tags/应用内搜索/"}]},{"title":"BLE_Central","slug":"BLE-Central","date":"2016-02-26T01:08:38.000Z","updated":"2016-11-18T02:35:50.000Z","comments":true,"path":"2016/02/26/BLE-Central/","link":"","permalink":"http://yoursite.com/2016/02/26/BLE-Central/","excerpt":"","text":"iOS蓝牙开发，中心模式开发。相关DEMO 模拟外设 iOS链接外设的代码实现流程1. 建立中心角色 2. 扫描外设（discover） 3. 连接外设(connect) 4. 扫描外设中的服务和特征(discover) - 4.1 获取外设的services - 4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值 5. 与外设做数据交互(explore and interact) 6. 订阅Characteristic的通知 7. 断开连接(disconnect) 实现步骤1.初始化(init)#import &lt;CoreBluetooth/CoreBluetooth.h&gt; @interface ViewController ()&lt;CBCentralManagerDelegate&gt; @property (nonatomic, strong) manager *centralManager; @property (nonatomic, strong) CBPeripheral *peripheral; // CBCentralManagerOptionShowPowerAlertKey的作用是，当设备蓝牙未打开时打开 NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES], CBCentralManagerOptionShowPowerAlertKey, nil]; // 初始化并设置委托和线程队列，默认main线程 self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue() options:options]; 2.扫描外设(discover)-(void)centralManagerDidUpdateState:(CBCentralManager *)central{ switch (central.state) { case CBCentralManagerStateUnknown: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStateUnknown&quot;); break; case CBCentralManagerStateResetting: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStateResetting&quot;); break; case CBCentralManagerStateUnsupported: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStateUnsupported&quot;); break; case CBCentralManagerStateUnauthorized: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStateUnauthorized&quot;); break; case CBCentralManagerStatePoweredOff: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStatePoweredOff&quot;); break; case CBCentralManagerStatePoweredOn: NSLog(@&quot;&gt;&gt;&gt;CBCentralManagerStatePoweredOn&quot;); //开始扫描周围的外设 /* 第一个参数nil就是扫描周围所有的外设，扫描到外设后会进入 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI; */ [manager scanForPeripheralsWithServices:nil options:nil]; break; default: break; } } //扫描到设备会进入方法 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{ NSLog(@&quot;当扫描到设备:%@&quot;,peripheral.name); //接下来可以连接设备 } 3.链接外设(connect)//扫描到设备会进入方法 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{ //连接设备（注意：这里使用self.peripheral,而不是peripheral,是因为如果peripheral被释放掉，将不会实现连接到外设的回调方法，也就是下面三个方法将不执行） self.peripheral = peripheral; [manager connectPeripheral:self.peripheral options:nil]; } //连接到Peripherals-成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@&quot;&gt;&gt;&gt;连接到名称为（%@）的设备-成功&quot;,peripheral.name); } //连接到Peripherals-失败 -(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;&gt;&gt;&gt;连接到名称为（%@）的设备-失败,原因:%@&quot;,[peripheral name],[error localizedDescription]); } //Peripherals断开连接 - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;&gt;&gt;&gt;外设连接断开连接 %@: %@\\n&quot;, [peripheral name], [error localizedDescription]); } 4.获取外设的services//连接到Peripherals-成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@&quot;&gt;&gt;&gt;连接到名称为（%@）的设备-成功&quot;,peripheral.name); //设置的peripheral委托CBPeripheralDelegate //@interface ViewController : UIViewController&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt; [peripheral setDelegate:self]; //扫描外设Services，成功后会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ [peripheral discoverServices:nil]; } //扫描到Services -(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ // NSLog(@&quot;&gt;&gt;&gt;扫描到服务：%@&quot;,peripheral.services); if (error) { NSLog(@&quot;&gt;&gt;&gt;Discovered services for %@ with error: %@&quot;, peripheral.name, [error localizedDescription]); return; } for (CBService *service in peripheral.services) { NSLog(@&quot;%@&quot;,service.UUID); //扫描每个service的Characteristics，扫描到后会进入方法： -(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error [peripheral discoverCharacteristics:nil forService:service]; } } 5.获取外设的Characteristics,Descriptor//扫描到Characteristics -(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{ if (error) { NSLog(@&quot;error Discovered characteristics for %@ with error: %@&quot;, service.UUID, [error localizedDescription]); return; } for (CBCharacteristic *characteristic in service.characteristics) { NSLog(@&quot;service:%@ 的 Characteristic: %@&quot;,service.UUID,characteristic.UUID); } //获取Characteristic的值，读到数据会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error for (CBCharacteristic *characteristic in service.characteristics){ { [peripheral readValueForCharacteristic:characteristic]; } } //搜索Characteristic的Descriptors，读到数据会进入方法：-(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error for (CBCharacteristic *characteristic in service.characteristics){ [peripheral discoverDescriptorsForCharacteristic:characteristic]; } } //获取的charateristic的值 -(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{ //打印出characteristic的UUID和值 //!注意，value的类型是NSData，具体开发时，会根据外设协议制定的方式去解析数据 NSLog(@&quot;characteristic uuid:%@ value:%@&quot;,characteristic.UUID,characteristic.value); } //搜索到Characteristic的Descriptors -(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{ //打印出Characteristic和他的Descriptors NSLog(@&quot;characteristic uuid:%@&quot;,characteristic.UUID); for (CBDescriptor *d in characteristic.descriptors) { NSLog(@&quot;Descriptor uuid:%@&quot;,d.UUID); } } //获取到Descriptors的值 -(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error{ //打印出DescriptorsUUID 和value //这个descriptor都是对于characteristic的描述，一般都是字符串，所以这里我们转换成字符串去解析 NSLog(@&quot;characteristic uuid:%@ value:%@&quot;,[NSString stringWithFormat:@&quot;%@&quot;,descriptor.UUID],descriptor.value); } 6.把数据写入到Characteristic中//写数据 -(void)writeCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic value:(NSData *)value{ //打印出 characteristic 的权限，可以看到有很多种，这是一个NS_OPTIONS，就是可以同时用于好几个值，常见的有read，write，notify，indicate，知知道这几个基本就够用了，前连个是读写权限，后两个都是通知，两种不同的通知方式。 /* typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) { CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200 }; */ NSLog(@&quot;%lu&quot;, (unsigned long)characteristic.properties); //只有 characteristic.properties 有write的权限才可以写 if(characteristic.properties &amp; CBCharacteristicPropertyWrite){ /* 最好一个type参数可以为CBCharacteristicWriteWithResponse或type:CBCharacteristicWriteWithResponse,区别是是否会有反馈 */ [peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse]; }else{ NSLog(@&quot;该字段不可写！&quot;); } } 7.订阅Characteristic的通知//设置通知 -(void)notifyCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic{ //设置通知，数据通知会进入：didUpdateValueForCharacteristic方法 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; } //取消通知 -(void)cancelNotifyCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic{ [peripheral setNotifyValue:NO forCharacteristic:characteristic]; } 7.断开连接(disconnect)//停止扫描并断开连接 -(void)disconnectPeripheral:(CBCentralManager *)centralManager peripheral:(CBPeripheral *)peripheral{ //停止扫描 [centralManager stopScan]; //断开连接 [centralManager cancelPeripheralConnection:peripheral]; }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"BLE_Central","slug":"BLE-Central","permalink":"http://yoursite.com/tags/BLE-Central/"},{"name":"蓝牙中心模式","slug":"蓝牙中心模式","permalink":"http://yoursite.com/tags/蓝牙中心模式/"}]},{"title":"Refresh-Swift","slug":"Refresh-Swift","date":"2016-01-29T08:23:29.000Z","updated":"2016-11-18T02:41:31.000Z","comments":true,"path":"2016/01/29/Refresh-Swift/","link":"","permalink":"http://yoursite.com/2016/01/29/Refresh-Swift/","excerpt":"","text":"Swift语言实现的数据刷新功能，类似于MJRefresh.(上拉加载，下拉刷新) 本文DEMO 效果图","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[]},{"title":"ActivityIndicator-Swift","slug":"ActivityIndicator-Swift","date":"2016-01-28T06:14:58.000Z","updated":"2016-11-18T02:34:47.000Z","comments":true,"path":"2016/01/28/ActivityIndicator-Swift/","link":"","permalink":"http://yoursite.com/2016/01/28/ActivityIndicator-Swift/","excerpt":"","text":"Swift实现简单的活动指示器。 本文DEMO链接 主要代码展示1.创建活动指示器单例 class var shareIndicator: HTTPIndicator { struct Static { static var onceToken: dispatch_once_t = 0 static var instance: HTTPIndicator? } dispatch_once(&amp;Static.onceToken, {() -&gt; Void in Static.instance = HTTPIndicator() }) return Static.instance! } 2.设置活动指示器界面的大小（全屏显示、部分显现） enum IndicatorSizeModel { case Landscape // 全屏 case FullScreen // 非全屏 } // 重写sizeModel的set方法 var sizeModel: IndicatorSizeModel = .Landscape { didSet { switch sizeModel { case .Landscape: self.frame = CGRectMake(0, 64, kScreenWidth, kScreenHeight - 64) maskWindow!.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight) indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32) indicatorImageView.transform = CGAffineTransformIdentity loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32) case .FullScreen: self.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight) maskWindow?.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight) indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2) loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2) } } } 3.创建活动指示器图片，由两部分组成 // 中间部分 lazy var indicatorImageView: UIImageView = { let imageView = UIImageView(frame: CGRectMake(0, 0, 60 * kScreenWidthFactor, 60 * kScreenWidthFactor)) imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32) imageView.image = UIImage(named: &quot;Indicator&quot;) imageView.contentMode = UIViewContentMode.ScaleToFill return imageView }() // 外部转圈部分 lazy var loopImageView: UIImageView = { let imageView = UIImageView(frame: CGRectMake(0, 0, 80 * kScreenWidthFactor, 80 * kScreenWidthFactor)) imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32) imageView.image = UIImage(named: &quot;loopIndicator&quot;) imageView.contentMode = UIViewContentMode.ScaleToFill return imageView }() 4.创建window对象，用来承载指示器 lazy var maskWindow : UIWindow? = { let window = UIWindow(frame: CGRectMake(0, 0, kScreenWidth, kScreenHeight)) window.windowLevel = UIWindowLevelNormal return window }() 5.指示器的显现 class func show() { shareIndicator.maskWindow?.makeKeyAndVisible() shareIndicator.maskWindow?.addSubview(shareIndicator) shareIndicator.beginAnimation() } 6.指示器的取消 因为新建了window对象来承载指示器，所以，当取消指示器的时候，一定要将新建的window移除。 class func dismiss() { shareIndicator.endAnimationWithCompletion { () -&gt; Void in shareIndicator.maskWindow?.resignKeyWindow() shareIndicator.removeFromSuperview() let originalWindow = UIApplication.sharedApplication().delegate?.window originalWindow!?.makeKeyAndVisible() shareIndicator.resetBounds() } }","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"活动指示器","slug":"活动指示器","permalink":"http://yoursite.com/tags/活动指示器/"}]},{"title":"ZXingObjC","slug":"ZXingObjC二维码","date":"2015-12-30T06:53:05.000Z","updated":"2016-11-18T02:46:03.000Z","comments":true,"path":"2015/12/30/ZXingObjC二维码/","link":"","permalink":"http://yoursite.com/2015/12/30/ZXingObjC二维码/","excerpt":"","text":"最近在做一个支付类的APP, 涉及到二维码的使用，上网查一些资料，发现网上的资料都N年之前了。也找到了一些大神的demo,但却是各种封装，一眼看不到重点，几经周折，才搞出来。本文是一个最简单的使用。 本文DEMO链接ZXingObjC链接 1.基本应用二维码扫描cocoaPods导入ZXingObjCpod &apos;ZXingObjC&apos;, &apos;~&gt; 3.1.0&apos; 导入头文件#import &lt;ZXingObjC.h&gt; @interface ViewController () &lt;ZXCaptureDelegate&gt; //协议 @property (nonatomic, strong) ZXCapture *capture; @property (nonatomic, assign) BOOL isScan; //标记扫描状态 @end 初始化摄像头- (void)creatCapture { self.isScan = NO; self.capture = [[ZXCapture alloc] init]; self.capture.camera = self.capture.back; //后置摄像头 self.capture.focusMode = AVCaptureFocusModeAutoFocus; //自动对焦 self.capture.rotation = 90.0f; self.capture.layer.frame = CGRectMake(50, 60, self.view.frame.size.width - 100, 150); [self.view.layer addSublayer:self.capture.layer]; self.capture.delegate = self; //协议的签订，用于对扫描结果进行处理 } 扫描结果的处理- (void)captureResult:(ZXCapture *)capture result:(ZXResult *)result { if (!result || self.isScan == YES ){ return; } self.isScan = YES; [self.capture stop]; //震动提示（可不加） AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); //result就是扫描获取的结果，处理text属性外，还有其他的属性，如条码的类型等。 NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%@&quot;, result.text]); } 二维码的生成简单的几行代码ZXBitMatrix *rusult = [writer encode:@&quot;这里就是要用来生成二维码的文字&quot; format:kBarcodeFormatQRCode width:200 height:200 error:&amp;error]; CGImageRef image = [[ZXImage imageWithMatrix:rusult] cgimage]; // img就是生成的二维码图片 UIImage *img = [UIImage imageWithCGImage:image]; 2.自定义扫描视图代码就不一一粘贴了，主要的几个部分看一些，具体看demo 上下扫描的动画效果初始化一个扫描线视图- (void)initQRLine { self.qrLine = [[UIImageView alloc] initWithFrame:CGRectMake(self.bounds.size.width / 2 - self.transparentArea.width / 2, self.bounds.size.height / 2 - self.transparentArea.height / 2, self.transparentArea.width, 2)]; //self.qrLine的照片让美工做个好看点的，demo中的是一个截屏图片 self.qrLine.image = [UIImage imageNamed:@&quot;22&quot;]; self.qrLine.contentMode = UIViewContentModeScaleAspectFill; [self addSubview:self.qrLine]; self.qrLineY = self.qrLine.frame.origin.y; } 扫描线上下循环移动效果添加一个计时器 NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:kQrLineanimateDuration target:self selector:@selector(show) userInfo:nil repeats:YES]; //实现计时器中的方法，使扫描线上下移动 - (void)show { [UIView animateWithDuration:kQrLineanimateDuration animations:^{ CGRect rect = self.qrLine.frame; rect.origin.y = self.qrLineY; self.qrLine.frame = rect; } completion:^(BOOL finished) { CGFloat maxBorder = self.frame.size.height / 2 + self.transparentArea.height / 2 - 4; if (self.qrLineY &gt; maxBorder) { self.qrLineY = self.frame.size.height / 2 - self.transparentArea.height /2; } self.qrLineY++; }]; } 扫描区域的四个角- (void)addCornerLineWithContext:(CGContextRef)ctx rect:(CGRect)rect{ //画四个边角 CGContextSetLineWidth(ctx, 2); CGContextSetRGBStrokeColor(ctx, 83 /255.0, 239/255.0, 111/255.0, 1);//绿色 //左上角 CGPoint poinsTopLeftA[] = { CGPointMake(rect.origin.x + 0.7, rect.origin.y), CGPointMake(rect.origin.x + 0.7 , rect.origin.y + 15) }; CGPoint poinsTopLeftB[] = {CGPointMake(rect.origin.x, rect.origin.y + 0.7),CGPointMake(rect.origin.x + 15, rect.origin.y + 0.7)}; [self addLine:poinsTopLeftA pointB:poinsTopLeftB ctx:ctx]; //左下角 CGPoint poinsBottomLeftA[] = {CGPointMake(rect.origin.x + 0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x + 0.7,rect.origin.y + rect.size.height)}; CGPoint poinsBottomLeftB[] = {CGPointMake(rect.origin.x , rect.origin.y + rect.size.height - 0.7) ,CGPointMake(rect.origin.x + 0.7 + 15, rect.origin.y + rect.size.height - 0.7)}; [self addLine:poinsBottomLeftA pointB:poinsBottomLeftB ctx:ctx]; //右上角 CGPoint poinsTopRightA[] = {CGPointMake(rect.origin.x + rect.size.width - 15, rect.origin.y + 0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + 0.7 )}; CGPoint poinsTopRightB[] = {CGPointMake(rect.origin.x + rect.size.width-0.7, rect.origin.y),CGPointMake(rect.origin.x + rect.size.width - 0.7, rect.origin.y + 15 + 0.7 )}; [self addLine:poinsTopRightA pointB:poinsTopRightB ctx:ctx]; CGPoint poinsBottomRightA[] = {CGPointMake(rect.origin.x + rect.size.width -0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x - 0.7 + rect.size.width, rect.origin.y + rect.size.height )}; CGPoint poinsBottomRightB[] = {CGPointMake(rect.origin.x + rect.size.width - 15 , rect.origin.y + rect.size.height-0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + rect.size.height - 0.7)}; [self addLine:poinsBottomRightA pointB:poinsBottomRightB ctx:ctx]; CGContextStrokePath(ctx); - (void)addLine:(CGPoint[])pointA pointB:(CGPoint[])pointB ctx:(CGContextRef)ctx { CGContextAddLines(ctx, pointA, 2); CGContextAddLines(ctx, pointB, 2); }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"ZXing","slug":"ZXing","permalink":"http://yoursite.com/tags/ZXing/"},{"name":"二维码","slug":"二维码","permalink":"http://yoursite.com/tags/二维码/"}]},{"title":"UITextView","slug":"UITextView","date":"2015-08-09T13:41:24.000Z","updated":"2016-11-18T02:44:31.000Z","comments":true,"path":"2015/08/09/UITextView/","link":"","permalink":"http://yoursite.com/2015/08/09/UITextView/","excerpt":"","text":"UITextView的三种应用效果： 1.链接地址在应用程序内跳转 2.占位符（类似于UITextField的占位符效果） 3.改变选中文本的属性 链接地址在应用程序内跳转核心APIDEMO Class: UITextView /** UITextView的编辑状态, 默认YES. */ @property(nonatomic, getter=isEditable) BOOL editable @property(nonatomic) UIDataDetectorTypes dataDetectorTypes /** 字典内存储链接文本的属性. */ @property(nonatomic, copy) NSDictionary *linkTextAttributes /** 询问代理人, 是否可以跳转到指定的链接地址. */ - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange 功能实现我们在UITextView里面点击链接地址时, 它是跳到浏览器里面的. 如果我们不想跳到浏览器, 想在自己的程序内部跳转显示, 该怎么做呢? 思路 UITextView有一个代理方法是用来链接跳转动作是否执行的. 返回值是BOOL类型, 默认是YES. * 当我们返回NO时, 它就不会跳转了. * 在这个代理方法内, 我们执行其他的操作, 让链接地址的内容在程序内显示. 代码#import &quot;ViewController.h&quot; #import &quot;WebViewController.h&quot; /** 签订协议 */ @interface ViewController ()&lt;UITextViewDelegate&gt; - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self layoutTextView]; /** 这个属性是UIViewController的属性, 当有Navicontroller的时候, 会自动向下调整UIScrollView及其子类的坐标位置, 默认为YES, 开启状态. */ /** 如果为YES, TextView里的内容会自动向下移动位置. 可以自己测试一下. */ self.automaticallyAdjustsScrollViewInsets = NO; } - (void)layoutTextView { /** 第一种链接界面: 地址链接. */ /** 创建UITextView的对象. 在这里我们并不需要textContainer, 设置成nil即可. */ UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(30, 100, 300, 150) textContainer:nil]; textView.text = @&quot;http://blog.csdn.net/sponge_cmz?viewmode=contents&quot;; textView.font = [UIFont systemFontOfSize:20]; textView.layer.borderColor = [UIColor blackColor].CGColor; textView.layer.borderWidth = 1; /** 设置代理人, 我们要实现的效果, 需要用到代理方法. 在上面签订UITextViewDelegate协议. */ textView.delegate = self; /** 链接地址能够跳转, textView的编辑状态必须为NO, 否则与普通文本无异. */ textView.editable = NO; /** 设置自动检测类型为链接网址. */ textView.dataDetectorTypes = UIDataDetectorTypeLink; /** 设置链接文字的属性. */ textView.linkTextAttributes = @{NSForegroundColorAttributeName: [UIColor orangeColor]}; [self.view addSubview:textView]; /** 第二种连接界面: 文字链接 */ UITextView *otherTextView = [[UITextView alloc] initWithFrame:CGRectMake(30, 350, 300, 150) textContainer:nil]; /** font属性是设置text的字体, 但是它对attributedText的字体不起作用. */ // otherTextView.font = [UIFont systemFontOfSize:20]; otherTextView.layer.borderColor = [UIColor blackColor].CGColor; otherTextView.layer.borderWidth = 1; otherTextView.delegate = self; otherTextView.editable = NO; /** 详细内容请见博文说明中提到的另外一篇博客. */ NSAttributedString *linkAttribute = [[NSAttributedString alloc] initWithString:@&quot;百度&quot; attributes:@{NSLinkAttributeName: [NSURL URLWithString:@&quot;http://www.baidu.com&quot;], NSFontAttributeName:[UIFont systemFontOfSize:25]}]; otherTextView.attributedText = linkAttribute; [self.view addSubview:otherTextView]; } /** 当点击链接时, 是否要跳转到浏览器. 默认返回YES. 想要实现在应用程序内部跳转, 只需要返回NO即可. */ - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange { /** 跳转到WebViewController的WebView上. */ WebViewController *webContro = [[WebViewController alloc] init]; UIWebView *web = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].bounds]; /** URL参数就是我们点击的链接地址. */ [web loadRequest:[NSURLRequest requestWithURL:URL]]; web.scalesPageToFit = YES; [webContro.view addSubview:web]; [self.navigationController pushViewController:webContro animated:YES]; /** 返回NO, 不跳转到浏览器. */ return NO; } 占位符（类似于UITextField的占位符效果）核心APIDEMO Class: UITextView /** 告诉代理人, 用户已经改变指定textView里面的text或者attributes. */ - (void)textViewDidChange:(UITextView *)textView 功能实现我们在使用UITextView的时候发现, UITextView没有像UITextField一样的占位符. 如果我们想要在UITextView里面实现占位符的效果, 该怎么办呢? 思路: 我们想要实现和UITextField一样的占位符效果, 那么我们就先看看UITextField是怎么实现的. .通过观察UITextField的图层, 我们发现, 占位符在一个单独的UILabel上. .我们让UITextField处于编辑状态, 再来看图层, 会发现在占位符label的上面又多了两层视图. .我们输入文字之后再看图层, 会发现占位符的lable没有了. .由此, 我们可以推测, 这个占位符label, 再输入之后, 就被隐藏了. .我们再来看UITextView的图层, 会发现它也有两个图层, 一个是UITextView, 一个是UITextContainerView. (还有两个滑条, 是UIImageView, 但是和我们实现的效果无关.) .那我们也可以仿照UITextField, 把一个label放到UITextContainerView的下面, 输入时就隐藏. .注: UITextView和UITextField 我是使用StoryBoard创建的, 所以在代码中没有创建的代码. 代码/** 签订协议. */ @interface ViewController ()&lt;UITextViewDelegate&gt; @property (weak, nonatomic) IBOutlet UITextView *textView; @property (nonatomic, strong) UILabel *label_Placeholder; /**&lt; 用来显示占位符的label. */ - (void)viewDidLoad { [super viewDidLoad]; _textView.layer.borderColor = [UIColor blackColor].CGColor; _textView.layer.borderWidth = 2; /** 签订代理人, 实现效果需要用到代理方法. */ _textView.delegate = self; /** 创建占位符label. */ self.label_Placeholder = [[UILabel alloc] initWithFrame:CGRectMake(5, 0, 200, 40)]; /**&lt; 坐标要根据实际情况做出调整. */ /** 使用属性文本. 详情请查看博文说明中提到的另一篇博客. */ _label_Placeholder.attributedText = [[NSAttributedString alloc] initWithString:@&quot;Hello World!&quot; attributes:@{NSFontAttributeName: _textView.font, NSForegroundColorAttributeName: [UIColor grayColor]}]; /** 我们之前说过了, textView上有UITextContainerView 和 两个UIImageView 子视图, 我们把label_Placeholder放到UITextContainerView的下面, 也就是textView的第一个子视图. */ [_textView insertSubview:_label_Placeholder atIndex:0]; /** 可以打印textView的子视图看一下. */ NSLog(@&quot;%@&quot;, [_textView subviews]); } /** 当textView里面的内容发生改变时, 调用这个代理方法. */ - (void)textViewDidChange:(UITextView *)textView{ /** 判断条件是多次尝试的结果. 大家按照自己的想法, 尝试着写判断条件, 会更加理解为什么这么写了! */ if (_textView.text.length != 0 &amp;&amp; _label_Placeholder.hidden == NO) { _label_Placeholder.hidden = YES; } else if (_textView.text.length == 0) { _label_Placeholder.hidden = NO; } 改变选中文本的属性核心APIDEMO链接 Class : UITextViews /** 用户输入新的文本属性时, 会被存储在这个字典属性里. */ @property(nonatomic, copy) NSDictionary *typingAttributes /** */ @property(nonatomic, readonly, retain) NSTextStorage *textStorage /** 被选中的范围. */ @property(nonatomic) NSRange selectedRange 功能实现我们在看小说或文档时, 可以对一些重点内容进行标注, 例如, 加下划线, 改变颜色之类的. 那么UITextView里的内容, 我们是如何进行标注的呢? 思路 首先获取到被选中的文本, 之后改变这段文本的属性设置. 代码@interface ViewController () @property (weak, nonatomic) IBOutlet UITextView *textView; @property (nonatomic, strong) NSDictionary *oldAttributes; /** 用来接收textView文本的初始属性设置. */ @end - (void)viewDidLoad { [super viewDidLoad]; /** 我们在textView的文本还未做出任何改变的时候, 将原始属性设置保存起来, 便于以后恢复. */ /** * 初始化oldAttributes. * typingAttributes : 在用户没有输入新的文本属性时, 里面会有一些默认的文本属性. */ self.oldAttributes = [NSDictionary dictionaryWithDictionary:[_textView typingAttributes]]; /** 打印看一下里面存储的内容. */ NSLog(@&quot;old: %@&quot;, _oldAttributes); } /** * textStorage : UITextView的属性, 是NSTextStorage类型. * NSTextStorage 继承于NSMutableAttributedString类, 所以可以使用父类的方法. * * selectedRange : UITextView的属性, 是NSRange类型. * textView当前被选择的文本. */ /** 改变字体的笔画宽度. */ - (IBAction)wordWeight:(UIButton *)sender { [_textView.textStorage addAttribute:NSStrokeWidthAttributeName value:@5 range:_textView.selectedRange]; } /** 给选中的文本添加黄色背景, 以及下划线. */ - (IBAction)backgroundColor:(UIButton *)sender { /** * 上面使用的是addAttribute: value: rang: 的方法. 它只能添加一个属性. * 如果我们要同时添加多个属性, 我们需要使用addAttributes: rang: 方法. * 这个方法的第一个参数是一个字典, 可以在字典中存储多个属性. */ [_textView.textStorage addAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange]; /** * 要注意 addAttributes 和 setAttributes 的区别: * addAttributes 是添加属性, 不会将之前的属性移除掉, 它们是共同存在的. * setAttributes 是设置属性, 会将之前的属性替换掉, 之前的属性将不会存在. */ // [_textView.textStorage setAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange]; } /** 恢复到原来的文本状态. */ - (IBAction)recoverAttribute:(UIButton *)sender { /** 我们想要恢复之前的属性, 也就是说不再使用做出改变的属性, 所以在这里我使用的是setAttributes: rang: 方法. */ [_textView.textStorage setAttributes:_oldAttributes range:_textView.selectedRange]; }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]},{"title":" NSAttributedString","slug":"NSAttributedString","date":"2015-03-20T11:14:35.000Z","updated":"2016-11-18T02:38:52.000Z","comments":true,"path":"2015/03/20/NSAttributedString/","link":"","permalink":"http://yoursite.com/2015/03/20/NSAttributedString/","excerpt":"","text":"NSAttributedString 可以非常方便的实现文字排版和图文混排功能. 共有21中效果(API), 本文将较详细的介绍21种的属性的使用 API文本API:Character Attributes , NSAttributedString 共有21个属性 1NSFontAttributeName -&gt;设置字体属性，默认值：字体：Helvetica(Neue) 字号：12 1NSParagraphStyleAttributeName -&gt;设置文本段落排版格式，取值为 NSParagraphStyle 对象(详情见下面的API说明) 1NSForegroundColorAttributeName -&gt;设置字体颜色，取值为 UIColor对象，默认值为黑色 1NSBackgroundColorAttributeName -&gt;设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色 1NSLigatureAttributeName -&gt;设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符 1NSKernAttributeName -&gt;设置字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄 1NSStrikethroughStyleAttributeName -&gt;设置删除线，取值为 NSNumber 对象（整数） 1NSStrikethroughColorAttributeName -&gt;设置删除线颜色，取值为 UIColor 对象，默认值为黑色 1NSUnderlineStyleAttributeName -&gt;设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似 1NSUnderlineColorAttributeName -&gt;设置下划线颜色，取值为 UIColor 对象，默认值为黑色 1NSStrokeWidthAttributeName -&gt;设置笔画宽度(粗细)，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果 1NSStrokeColorAttributeName -&gt;填充部分颜色，不是字体颜色，取值为 UIColor 对象 1NSShadowAttributeName -&gt;设置阴影属性，取值为 NSShadow 对象 1NSTextEffectAttributeName -&gt;设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用 1NSBaselineOffsetAttributeName -&gt;设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏 1NSObliquenessAttributeName -&gt;设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾 1NSExpansionAttributeName -&gt;设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本 1NSWritingDirectionAttributeName -&gt;设置文字书写方向，从左向右书写或者从右向左书写 1NSVerticalGlyphFormAttributeName -&gt;设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本 1NSLinkAttributeName -&gt;设置链接属性，点击后调用浏览器打开指定URL地址 1NSAttachmentAttributeName -&gt;设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排 段落API:NSParagraphStyleAttributeName 值为NSParagraphStyle，设置段落属性，默认值为[NSParagraphStyle defaultParagraphStyle]返回的值。NSMutableParagraphStyle与NSParagraphStyle包括一下属性 alignment -&gt;对齐方式 firstLineHeadIndent -&gt;首行缩进 headIndent -&gt;缩进 tailIndent -&gt;尾部缩进 lineBreakMode -&gt;断行方式 maximumLineHeight -&gt;最大行高 minimumLineHeight -&gt;最低行高 lineSpacing -&gt;行距 paragraphSpacing -&gt;段距 paragraphSpacingBefore -&gt;段首空间 baseWritingDirection -&gt;句子方向 lineHeightMultiple -&gt;可变行高,乘因数。 hyphenationFactor -&gt;连字符属性 代码self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 50, 320, 400)]; self.titleLabel.numberOfLines = 0; self.titleLabel.layer.borderColor = [UIColor grayColor].CGColor; self.titleLabel.layer.borderWidth = 0.5; self.titleLabel.textAlignment = NSTextAlignmentLeft; [self.view addSubview:self.titleLabel]; NSString *string = @&quot;An NSAttributedString object manages character strings and associated sets of attributes (for example, font and kerning) that apply to individual characters or ranges of characters in the string. An association of characters and their attributes is called an attributed string. &quot;; 这句话就是对这个类的一个最简明扼要的概括。 NSAttributedString管理一个字符串，以及与该字符串中的 单个字符或某些范围的字符串相关的属性。它有一个子类NSMutableAttributedString具体实现时,NSAttributedString 维护了一个NSString，用来保存最原始的字符串，另有一个NSDictionary用来保存各个子串/字符的属性。 创建#pragma mark - NSMutableAttributedString 创建 三种初始化方法,NSMutableAttributedString没有初始化方法,使用父类初始化方法, 使用initWithString:, initWithString:attributes:, 或者 initWithAttributedString: NSAttributedString *attStri = [[NSAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:30]}]; NSMutableAttributedString *mAttStri = [[NSMutableAttributedString alloc] initWithString:string]; 字体属性#pragma mark ** 1. NSFontAttributeName 设置字体属性 /* 字体大小 及 字体类型 */ NSRange font_range = [string rangeOfString:@&quot;An&quot;]; [mAttStri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:font_range]; [mAttStri addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;Courier-BoldOblique&quot; size:17.0] range:NSMakeRange(10, 10)]; 文本段落排版格式#pragma mark ** 2. NSParagraphStyleAttributeName 设置文本段落排版格式 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; style.firstLineHeadIndent = 20; style.lineSpacing = 10; [mAttStri addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, mAttStri.length / 2)]; 字体颜色#pragma mark ** 3. NSForegroundColorAttributeName 设置字体颜色 /* 值为UIColor，字体颜色，默认为黑色. */ [mAttStri addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, mAttStri.length)]; 字体所在区域背景颜色#pragma mark ** 4. NSBackgroundColorAttributeName 设置字体所在区域背景颜色 /* 值为UIColor，字体背景色，默认透明. */ [mAttStri addAttribute:NSBackgroundColorAttributeName value:[UIColor grayColor] range:NSMakeRange(0, 20)]; 连体属性#pragma mark ** 5. NSLigatureAttributeName 设置连体属性 /* 取值为NSNumber 对象(整数). 0 表示没有连体字符, 1 表示使用默认的连体字符. 一般中文用不到，在英文中可能出现相邻字母连笔的情况 */ [mAttStri addAttribute:NSLigatureAttributeName value:@0 range:NSMakeRange(0, mAttStri.length)]; 字符间距#pragma mark ** 6. NSKernAttributeName 设置字符间距 /* 值为浮点数NSNumber，字距属性，默认值为0。*/ [mAttStri addAttribute:NSKernAttributeName value:@3 range:NSMakeRange(0, mAttStri.length)]; 删除线#pragma mark ** 7. NSStrikethroughStyleAttributeName 设置删除线 /* 值为整型NSNumber，可取值为 enum { NSUnderlineStyleNone = 0×00, NSUnderlineStyleSingle = 0×01, }; 设置删除线。 */ [mAttStri addAttribute:NSStrikethroughStyleAttributeName value:@3 range:NSMakeRange(3, 7)]; 删除线颜色#pragma mark ** 8. NSStrikethroughColorAttributeName 设置删除线颜色 /* 这个属性的值是一个UIColor对象. */ [mAttStri addAttribute:NSStrikethroughColorAttributeName value:[UIColor blueColor] range:NSMakeRange(3, 3)]; 下划线#pragma mark ** 9. NSUnderlineStyleAttributeName 设置下划线 /* 取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似 */ [mAttStri addAttribute:NSUnderlineStyleAttributeName value:@2 range:NSMakeRange(6, 5)]; 下划线颜色#pragma mark ** 10. NSUnderlineColorAttributeName 设置下划线颜色 /* 这个属性的值是一个UIColor对象.默认值为nil. */ [mAttStri addAttribute:NSUnderlineColorAttributeName value:[UIColor blackColor] range:NSMakeRange(6, 5)]; 笔画粗细#pragma mark ** 11. NSStrokeWidthAttributeName 设置笔画宽度(粗细) /* 值为浮点数NSNumber。设置笔画的粗细。负值填充效果，正值中空效果. */ [mAttStri addAttribute:NSStrokeWidthAttributeName value:@10 range:NSMakeRange(50, 30)]; 填充部分颜色(不是字体颜色)#pragma mark ** 12. NSStrokeColorAttributeName 填充部分颜色， /* 不是字体颜色，取值为 UIColor 对象 默认值为nil，设置的属性同ForegroundColor。*/ [mAttStri addAttribute:NSStrokeColorAttributeName value:[UIColor orangeColor] range:NSMakeRange(50, 20)]; 阴影属性#pragma mark ** 13. NSShadowAttributeName 设置阴影属性 /* 值为NSShadow，设置笔画的阴影，默认值为nil。*/ NSShadow *shadow = [[NSShadow alloc]init]; shadow.shadowOffset = CGSizeMake(10, 10); shadow.shadowColor = [UIColor greenColor]; [mAttStri addAttribute:NSShadowAttributeName value:shadow range:NSMakeRange(20, 10)]; 文本特效#pragma mark ** 14. NSTextEffectAttributeName 设置文本特殊效果 /* 这个属性的值是一个NSString对象。使用此属性指定的文字效果，如NSTextEffectLetterpressStyle。此属性的默认值为nil，表示没有文本效应。*/ [mAttStri addAttribute:NSTextEffectAttributeName value:NSTextEffectLetterpressStyle range:NSMakeRange(80, 10)]; 基线偏移值#pragma mark ** 15. NSBaselineOffsetAttributeName 设置基线偏移值 /* 此属性的值是包含一个浮点值的NSNumber对象,表示的字符从基线偏移的NSNumber对象，默认值是0。正值上偏，负值下偏 */ [mAttStri addAttribute:NSBaselineOffsetAttributeName value:@5 range:NSMakeRange(112, 10)]; 字形(左倾 右倾)#pragma mark ** 16. NSObliquenessAttributeName 设置字形倾斜度取值为 NSNumber （float）,正值右倾，负值左倾 /* 此属性的值是包含一个浮点值的NSNumber对象。默认值为0，表示没有倾斜, 正值右倾，负值左倾。 */ [mAttStri addAttribute:NSObliquenessAttributeName value:@0.8 range:NSMakeRange(135, 15)]; 文本横向 拉伸 压缩#pragma mark ** 17. NSExpansionAttributeName 设置文本横向拉伸属性 /* 取值为 NSNumber(float), 正值横向拉伸文本, 负值横向压缩文本 */ NSRange range = [string rangeOfString:@&quot;An association of&quot;]; [mAttStri addAttribute:NSExpansionAttributeName value:@1.0 range:range]; 文字书写方向#pragma mark ** 18. NSWritingDirectionAttributeName 设置文字书写方向 /** * 取值为包含NSNumber对象的数组. 从左向右书写或者从右向左书写. * * The values of the NSNumber objects should be 0, 1, 2, or 3, for LRE, RLE, LRO, or RLO respectively, and combinations of NSWritingDirectionLeftToRight and NSWritingDirectionRightToLeft with NSTextWritingDirectionEmbedding or NSTextWritingDirectionOverride, as shown in Values of NSWritingDirectionAttributeName and equivalent markup. */ NSRange rang2 = [string rangeOfString:@&quot;characters and their&quot;]; [mAttStri addAttribute:NSWritingDirectionAttributeName value:@[@3] range:rang2]; 文字排版方向(水平、垂直)#pragma mark ** 19. NSVerticalGlyphFormAttributeName 设置文字排版方向 /** * 值为整型NSNumber，0为水平排版的字，1为垂直排版的字。注意,在iOS中, 总是以横向排版 * * In iOS, horizontal text is always used and specifying a different value is undefined. */ [mAttStri addAttribute:NSVerticalGlyphFormAttributeName value:@1 range:NSMakeRange(1, 10)]; 超链接#pragma mark ** 20. NSLinkAttributeName 设置链接属性 /** * 此属性的值是NSURL对象（首选）或一个NSString对象。此属性的默认值为nil，表示没有链接。 * UILabel无法使用该属性, 可以使用UITextView 控件. */ UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 450, 320, 60)]; [self.view addSubview:textView]; textView.backgroundColor = [UIColor lightGrayColor]; NSString *strLink = @&quot;百度链接&quot;; NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:strLink attributes:@{NSLinkAttributeName: [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]}]; textView.editable = NO; /* 签订协议, 指定代理人之后. 但点击链接时, 会回调协议方法 (- textView:shouldInteractWithURL:inRange:) */ textView.delegate = self; textView.attributedText = attStr; 文本附件#pragma mark ** 21. NSAttachmentAttributeName 设置文本附件 /* 这个属性的值是一个NSTextAttachment对象。此属性的默认值为nil，表示无附件。*/ /** * 关于NSTextAttachment类的简单说明 * * NSTextAttachment 类有一个指定的初始化方法(- initWithData:ofType:), 需要指定附件文档的数据和附件文件的类型. 如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值. 因此, 也可以通过这个特性实现图文混排. * 下面就以附件为image对象来说明NSAttachmentAttributeName的使用. */ UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(20, 550, 320, 60)]; label.backgroundColor = [UIColor yellowColor]; [self.view addSubview:label]; /* 下面实现在百度两个汉字之间插入一个照片 */ NSString *stiAtt = @&quot;百度&quot;; NSTextAttachment *attach = [[NSTextAttachment alloc] initWithData:nil ofType:nil]; attach.bounds = CGRectMake(0, 0, 50, 50); attach.image = [UIImage imageNamed:@&quot;baidu.jpg&quot;]; NSAttributedString *strAtt = [NSAttributedString attributedStringWithAttachment:attach]; NSMutableAttributedString *strMatt = [[NSMutableAttributedString alloc] initWithString:stiAtt]; [strMatt insertAttributedString:strAtt atIndex:1]; label.attributedText = strMatt; self.titleLabel.attributedText = mAttStri; [self.titleLabel sizeToFit]; } UITextView协议#pragma mark - textView delegate -(BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange { NSLog(@&quot;%s&quot;, __func__); NSLog(@&quot;url: %@&quot;, URL); return YES; }","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://yoursite.com/tags/NSAttributedString/"}]},{"title":"Runtime","slug":"runtime的那些巧用","date":"2015-03-06T13:53:22.000Z","updated":"2016-11-18T02:42:52.000Z","comments":true,"path":"2015/03/06/runtime的那些巧用/","link":"","permalink":"http://yoursite.com/2015/03/06/runtime的那些巧用/","excerpt":"","text":"1.获取类的属性列表API`class_copyPropertyList(Class cls, unsigned int *outCount)` 在复杂对象存储中的简单应用-归档和反归档12345678910111213141516171819202122归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int num = 0; 获取属性列表 objc_property_t *propertys = class_copyPropertyList([Person class], &amp;num); 遍历Person类的属性列表，逐一归档 for (int i = 0; i &lt; num; i++) &#123; objc_property_t property = propertys[i]; const char *name = property_getName(property); NSString *key = [NSString stringWithUTF8String:name]; 归档 [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125; 123456789101112131415161718192021222324252627反归档- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; unsigned int num = 0; objc_property_t *propertys = class_copyPropertyList([Person class], &amp;num); 遍历Person类的属性列表，逐一反归档 for (int i = 0; i &lt; num; i++) &#123; objc_property_t property = propertys[i]; const char *name = property_getName(property); NSString *key = [NSString stringWithUTF8String:name]; // 反归档 [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125; 2.为类添加方法API`class_addMethod(Class cls, SEL name, IMP imp, const char *types)` 简单应用123456789101112131415161718192021222324252627282930313233`为Person类添加一个Method3的方法，此方法能打印出“Hello”`下面的方法的是 `- void sayHello;` 方法的实现函数：void sayHello(id self, SEL _cmd) &#123; NSLog(@\"Hello\");&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; 为Person类添加method3方法 class_addMethod([Person class], @selector(method3), (IMP)sayHello, \"v\"); unsigned int count = 0; 获取Person类的方法列表 Method * mem = class_copyMethodList([Person class], &amp;count); 通过遍历，查看Person类的所有方法 for ( int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@\"%d: %@\" , i, method); &#125; Person *person = [Person new]; 实现method3方法 [person performSelector:@selector(method3)];&#125; 123456输出结果为：2015-12-06 22:57:30.391 Runtime[42093:505478] 0: method3`这条信息说明method3方法已经添加到了Person类里面`2015-12-06 22:57:30.393 Runtime[42093:505478] Hello`Hello的打印,说明method3方法实现了方法 `- void sayHello;` 的实现` types参数 12345678910111213141516171819202122如要添加一个这样的方法：-(int)say:(NSString *)str;相应的实现函数就应该是这样：int say(id self, SEL _cmd, NSString *str) &#123; NSLog(@\"%@\", str); return 100;//随便返回个值 &#125; class_addMethod这句就应该这么写：class_addMethod([EmptyClass class], @selector(say:), (IMP)say, \"i@:@\");其中types参数为\"i@:@“，按顺序分别表示：i ：返回值类型int，若是v则表示void@ ：参数id(self): ：SEL(_cmd)@ ：id(str) 3.方法调剂API`method_exchangeImplementations(Method m1, Method m2)` 方法实现的对调12345678910111213141516171819202122232425262728293031323334简单案例：将UIView的 `setBackgroundColor:` 方法 的实现 和 自定义的方法 `- (void)night:(UIColor *)color；` 的实现 进行对调。创建基于UIView的Category：UIView+Night.h·#import \"UIView+Night.h\"·#import &lt;objc/runtime.h&gt;@implementation UIView (Night)自定义的方法- (void)night:(UIColor *)color &#123; if ([color isEqual:[UIColor yellowColor]]) &#123; [self night:[UIColor blackColor]]; &#125; else &#123; 此处调用night方法不会出错，因为此处的night的实现已经更换 [self night:color]; &#125;&#125;+ (void)load &#123; 获取方法 Method a = class_getInstanceMethod([UIView class], @selector(setBackgroundColor:)); Method b = class_getInstanceMethod([UIView class], @selector(night:)); 将两个方法的实现进行对调 method_exchangeImplementations(a, b); &#125;@end 结果验证 12345在VC中，当执行self.view.backgroundColor = [UIColor yellowColor];时，视图的颜色应该是`黑色`的。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[]}]}