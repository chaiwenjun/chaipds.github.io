<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>百度一下jms的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="莫道君行早，更有早行人">
<meta property="og:type" content="website">
<meta property="og:title" content="百度一下jms的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="百度一下jms的博客">
<meta property="og:description" content="莫道君行早，更有早行人">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="百度一下jms的博客">
<meta name="twitter:description" content="莫道君行早，更有早行人">
  
    <link rel="alternative" href="/atom.xml" title="百度一下jms的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xoz39.com1.z0.glb.clouddn.com/BLOG_IMG_0412.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">百度一下jms</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zhangzhaopds" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">百度一下jms</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xoz39.com1.z0.glb.clouddn.com/BLOG_IMG_0412.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">百度一下jms</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zhangzhaopds" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Refresh-Swift" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/29/Refresh-Swift/" class="article-date">
  	<time datetime="2016-01-29T08:23:29.000Z" itemprop="datePublished">2016-01-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/29/Refresh-Swift/">Refresh-Swift</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Swift语言实现的数据刷新功能，类似于MJRefresh.(上拉加载，下拉刷新)</p>
</blockquote>
<p><a href="https://github.com/zhangzhaopds/Alamofire-Refresh.git" target="_blank" rel="external">本文DEMO</a></p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="http://7xoz39.com1.z0.glb.clouddn.com/BLOG_%E5%88%B7%E6%96%B0.png?imageView2/2/w/300" alt=""><img src="http://7xoz39.com1.z0.glb.clouddn.com/BLOG_%E5%8A%A0%E8%BD%BD.png?imageView2/2/w/300" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ActivityIndicator-Swift" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/ActivityIndicator-Swift/" class="article-date">
  	<time datetime="2016-01-28T06:14:58.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/ActivityIndicator-Swift/">ActivityIndicator-Swift</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://7xoz39.com1.z0.glb.clouddn.com/Blogactivity.png?imageView2/2/h/500" alt=""></p>
<blockquote>
<p>Swift实现简单的活动指示器。</p>
</blockquote>
<p><a href="https://github.com/zhangzhaopds/Indicator..git" target="_blank" rel="external">本文DEMO链接</a></p>
<h3 id="主要代码展示"><a href="#主要代码展示" class="headerlink" title="主要代码展示"></a>主要代码展示</h3><p><code>1.创建活动指示器单例</code></p>
<pre><code>class var shareIndicator: HTTPIndicator {
    struct Static {
        static var onceToken: dispatch_once_t = 0
        static var instance: HTTPIndicator?
    }
    dispatch_once(&amp;Static.onceToken, {() -&gt; Void in
        Static.instance = HTTPIndicator()
    })
    return Static.instance!
}
</code></pre><p><code>2.设置活动指示器界面的大小（全屏显示、部分显现）</code></p>
<pre><code>enum IndicatorSizeModel {
    case Landscape      // 全屏
    case FullScreen        // 非全屏
}

// 重写sizeModel的set方法
var sizeModel: IndicatorSizeModel = .Landscape {
    didSet {
        switch sizeModel {
        case .Landscape:
            self.frame = CGRectMake(0, 64, kScreenWidth, kScreenHeight - 64)
            maskWindow!.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
            indicatorImageView.transform = CGAffineTransformIdentity
            loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)

        case .FullScreen:
            self.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            maskWindow?.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight)
            indicatorImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2)
            loopImageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2)
        } 
    }
}
</code></pre><p><code>3.创建活动指示器图片，由两部分组成</code></p>
<pre><code>// 中间部分
lazy var indicatorImageView: UIImageView = {
    let imageView = UIImageView(frame: CGRectMake(0, 0, 60 * kScreenWidthFactor, 60 * kScreenWidthFactor))
    imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
    imageView.image = UIImage(named: &quot;Indicator&quot;)
    imageView.contentMode = UIViewContentMode.ScaleToFill
    return imageView
}()

// 外部转圈部分
lazy var loopImageView: UIImageView = {
   let imageView = UIImageView(frame: CGRectMake(0, 0, 80 * kScreenWidthFactor, 80 * kScreenWidthFactor))
    imageView.center = CGPointMake(kScreenWidth / 2, kScreenHeight / 2 - 32)
    imageView.image = UIImage(named: &quot;loopIndicator&quot;)
    imageView.contentMode = UIViewContentMode.ScaleToFill
    return imageView
}()
</code></pre><p><code>4.创建window对象，用来承载指示器</code></p>
<pre><code>lazy var maskWindow : UIWindow? = {
    let window = UIWindow(frame: CGRectMake(0, 0, kScreenWidth, kScreenHeight))
    window.windowLevel = UIWindowLevelNormal
    return window
}()
</code></pre><p><code>5.指示器的显现</code></p>
<pre><code>class func show() {
    shareIndicator.maskWindow?.makeKeyAndVisible()
    shareIndicator.maskWindow?.addSubview(shareIndicator)
    shareIndicator.beginAnimation()
}
</code></pre><p><code>6.指示器的取消</code></p>
<p>因为新建了window对象来承载指示器，所以，当取消指示器的时候，一定要将新建的window移除。</p>
<pre><code>class func dismiss() {
    shareIndicator.endAnimationWithCompletion { () -&gt; Void in
        shareIndicator.maskWindow?.resignKeyWindow()
        shareIndicator.removeFromSuperview()

        let originalWindow = UIApplication.sharedApplication().delegate?.window
        originalWindow!?.makeKeyAndVisible()

        shareIndicator.resetBounds()
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ZXingObjC二维码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/30/ZXingObjC二维码/" class="article-date">
  	<time datetime="2015-12-30T06:53:05.000Z" itemprop="datePublished">2015-12-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/30/ZXingObjC二维码/">ZXingObjC</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在做一个支付类的APP, 涉及到二维码的使用，上网查一些资料，发现网上的资料都N年之前了。也找到了一些大神的demo,但却是各种封装，一眼看不到重点，几经周折，才搞出来。本文是一个最简单的使用。</p>
</blockquote>
<p><a href="https://github.com/zhangzhaopds/-.git" target="_blank" rel="external">本文DEMO链接</a><br><a href="https://github.com/TheLevelUp/ZXingObjC" target="_blank" rel="external">ZXingObjC链接</a></p>
<h2 id="1-基本应用"><a href="#1-基本应用" class="headerlink" title="1.基本应用"></a>1.基本应用</h2><h3 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h3><h4 id="cocoaPods导入ZXingObjC"><a href="#cocoaPods导入ZXingObjC" class="headerlink" title="cocoaPods导入ZXingObjC"></a><code>cocoaPods导入ZXingObjC</code></h4><pre><code>pod &apos;ZXingObjC&apos;, &apos;~&gt; 3.1.0&apos;
</code></pre><h4 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a><code>导入头文件</code></h4><pre><code>#import &lt;ZXingObjC.h&gt;

@interface ViewController () &lt;ZXCaptureDelegate&gt; //协议

@property (nonatomic, strong) ZXCapture *capture; 
@property (nonatomic, assign) BOOL isScan; //标记扫描状态

@end    
</code></pre><h4 id="初始化摄像头"><a href="#初始化摄像头" class="headerlink" title="初始化摄像头"></a><code>初始化摄像头</code></h4><pre><code>- (void)creatCapture {

self.isScan = NO; 

self.capture = [[ZXCapture alloc] init];

self.capture.camera = self.capture.back; //后置摄像头

self.capture.focusMode = AVCaptureFocusModeAutoFocus; //自动对焦

self.capture.rotation = 90.0f;

self.capture.layer.frame = CGRectMake(50, 60, self.view.frame.size.width - 100, 150);

[self.view.layer addSublayer:self.capture.layer];

self.capture.delegate = self; //协议的签订，用于对扫描结果进行处理
}
</code></pre><h4 id="扫描结果的处理"><a href="#扫描结果的处理" class="headerlink" title="扫描结果的处理"></a><code>扫描结果的处理</code></h4><pre><code>- (void)captureResult:(ZXCapture *)capture result:(ZXResult *)result {
if (!result || self.isScan == YES ){
    return;
}
self.isScan = YES;
[self.capture stop];

//震动提示（可不加）
AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);

//result就是扫描获取的结果，处理text属性外，还有其他的属性，如条码的类型等。
NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%@&quot;, result.text]);
}
</code></pre><h3 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h3><h4 id="简单的几行代码"><a href="#简单的几行代码" class="headerlink" title="简单的几行代码"></a><code>简单的几行代码</code></h4><pre><code>ZXBitMatrix *rusult = [writer encode:@&quot;这里就是要用来生成二维码的文字&quot; format:kBarcodeFormatQRCode width:200 height:200 error:&amp;error];

CGImageRef image = [[ZXImage imageWithMatrix:rusult] cgimage];

// img就是生成的二维码图片
UIImage *img = [UIImage imageWithCGImage:image];
</code></pre><hr>
<h2 id="2-自定义扫描视图"><a href="#2-自定义扫描视图" class="headerlink" title="2.自定义扫描视图"></a>2.自定义扫描视图</h2><p>代码就不一一粘贴了，主要的几个部分看一些，具体看<a href="https://github.com/zhangzhaopds/-.git" target="_blank" rel="external">demo</a></p>
<h3 id="上下扫描的动画效果"><a href="#上下扫描的动画效果" class="headerlink" title="上下扫描的动画效果"></a>上下扫描的动画效果</h3><h4 id="初始化一个扫描线视图"><a href="#初始化一个扫描线视图" class="headerlink" title="初始化一个扫描线视图"></a><code>初始化一个扫描线视图</code></h4><pre><code>- (void)initQRLine {

self.qrLine  = [[UIImageView alloc] initWithFrame:CGRectMake(self.bounds.size.width / 2 - self.transparentArea.width / 2, self.bounds.size.height / 2 - self.transparentArea.height / 2, self.transparentArea.width, 2)];

//self.qrLine的照片让美工做个好看点的，demo中的是一个截屏图片
self.qrLine.image = [UIImage imageNamed:@&quot;22&quot;];

self.qrLine.contentMode = UIViewContentModeScaleAspectFill;

[self addSubview:self.qrLine];

self.qrLineY = self.qrLine.frame.origin.y;
</code></pre><p>}</p>
<h4 id="扫描线上下循环移动效果"><a href="#扫描线上下循环移动效果" class="headerlink" title="扫描线上下循环移动效果"></a><code>扫描线上下循环移动效果</code></h4><pre><code>添加一个计时器
 NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:kQrLineanimateDuration target:self selector:@selector(show) userInfo:nil repeats:YES];

 //实现计时器中的方法，使扫描线上下移动
 - (void)show {

[UIView animateWithDuration:kQrLineanimateDuration animations:^{

    CGRect rect = self.qrLine.frame;
    rect.origin.y = self.qrLineY;
    self.qrLine.frame = rect;

} completion:^(BOOL finished) {

    CGFloat maxBorder = self.frame.size.height / 2 + self.transparentArea.height / 2 - 4;
    if (self.qrLineY &gt; maxBorder) {

        self.qrLineY = self.frame.size.height / 2 - self.transparentArea.height /2;
    }
    self.qrLineY++;
}];
}
</code></pre><h3 id="扫描区域的四个角"><a href="#扫描区域的四个角" class="headerlink" title="扫描区域的四个角"></a>扫描区域的四个角</h3><pre><code>- (void)addCornerLineWithContext:(CGContextRef)ctx rect:(CGRect)rect{

//画四个边角
CGContextSetLineWidth(ctx, 2);
CGContextSetRGBStrokeColor(ctx, 83 /255.0, 239/255.0, 111/255.0, 1);//绿色

//左上角
CGPoint poinsTopLeftA[] = {
    CGPointMake(rect.origin.x + 0.7, rect.origin.y),
    CGPointMake(rect.origin.x + 0.7 , rect.origin.y + 15)
};

CGPoint poinsTopLeftB[] = {CGPointMake(rect.origin.x, rect.origin.y + 0.7),CGPointMake(rect.origin.x + 15, rect.origin.y + 0.7)};
[self addLine:poinsTopLeftA pointB:poinsTopLeftB ctx:ctx];

//左下角
CGPoint poinsBottomLeftA[] = {CGPointMake(rect.origin.x + 0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x + 0.7,rect.origin.y + rect.size.height)};
CGPoint poinsBottomLeftB[] = {CGPointMake(rect.origin.x , rect.origin.y + rect.size.height - 0.7) ,CGPointMake(rect.origin.x + 0.7 + 15, rect.origin.y + rect.size.height - 0.7)};
[self addLine:poinsBottomLeftA pointB:poinsBottomLeftB ctx:ctx];

//右上角
CGPoint poinsTopRightA[] = {CGPointMake(rect.origin.x + rect.size.width - 15, rect.origin.y + 0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + 0.7 )};
CGPoint poinsTopRightB[] = {CGPointMake(rect.origin.x + rect.size.width-0.7, rect.origin.y),CGPointMake(rect.origin.x + rect.size.width - 0.7, rect.origin.y + 15 + 0.7 )};
[self addLine:poinsTopRightA pointB:poinsTopRightB ctx:ctx];

CGPoint poinsBottomRightA[] = {CGPointMake(rect.origin.x + rect.size.width -0.7, rect.origin.y + rect.size.height - 15),CGPointMake(rect.origin.x - 0.7 + rect.size.width, rect.origin.y + rect.size.height )};
CGPoint poinsBottomRightB[] = {CGPointMake(rect.origin.x + rect.size.width - 15 , rect.origin.y + rect.size.height-0.7),CGPointMake(rect.origin.x + rect.size.width, rect.origin.y + rect.size.height - 0.7)};
[self addLine:poinsBottomRightA pointB:poinsBottomRightB ctx:ctx];
CGContextStrokePath(ctx);


- (void)addLine:(CGPoint[])pointA pointB:(CGPoint[])pointB ctx:(CGContextRef)ctx {
CGContextAddLines(ctx, pointA, 2);
CGContextAddLines(ctx, pointB, 2);
}
</code></pre><hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-UITextView" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/09/UITextView/" class="article-date">
  	<time datetime="2015-08-09T13:41:24.000Z" itemprop="datePublished">2015-08-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/09/UITextView/">UITextView</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>   UITextView的三种应用效果：<br>        1.链接地址在应用程序内跳转<br>        2.占位符（类似于UITextField的占位符效果）<br>        3.改变选中文本的属性</p>
</blockquote>
<h2 id="链接地址在应用程序内跳转"><a href="#链接地址在应用程序内跳转" class="headerlink" title="链接地址在应用程序内跳转"></a>链接地址在应用程序内跳转</h2><h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><p><a href="https://github.com/zhangzhaopds/UITextView.git" target="_blank" rel="external">DEMO</a></p>
<pre><code>Class: UITextView

/** UITextView的编辑状态, 默认YES. */
@property(nonatomic, getter=isEditable) BOOL editable

@property(nonatomic) UIDataDetectorTypes dataDetectorTypes

/** 字典内存储链接文本的属性. */
@property(nonatomic, copy) NSDictionary *linkTextAttributes

/** 询问代理人, 是否可以跳转到指定的链接地址. */
- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange
</code></pre><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>我们在UITextView里面点击链接地址时, 它是跳到浏览器里面的. 如果我们不想跳到浏览器, 想在自己的程序内部跳转显示, 该怎么做呢?</p>
<pre><code>思路
UITextView有一个代理方法是用来链接跳转动作是否执行的. 返回值是BOOL类型, 默认是YES. 
* 当我们返回NO时, 它就不会跳转了. 
* 在这个代理方法内, 我们执行其他的操作, 让链接地址的内容在程序内显示.
</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#import &quot;ViewController.h&quot;
#import &quot;WebViewController.h&quot;

/** 签订协议 */
@interface ViewController ()&lt;UITextViewDelegate&gt;
</code></pre><hr>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    [self layoutTextView];

    /** 这个属性是UIViewController的属性, 当有Navicontroller的时候, 会自动向下调整UIScrollView及其子类的坐标位置, 默认为YES, 开启状态. */
    /** 如果为YES, TextView里的内容会自动向下移动位置. 可以自己测试一下. */
    self.automaticallyAdjustsScrollViewInsets = NO;
}
</code></pre><hr>
<pre><code>- (void)layoutTextView {

/** 第一种链接界面: 地址链接. */

/** 创建UITextView的对象. 在这里我们并不需要textContainer, 设置成nil即可. */
UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(30, 100, 300, 150) textContainer:nil];

textView.text = @&quot;http://blog.csdn.net/sponge_cmz?viewmode=contents&quot;;
textView.font = [UIFont systemFontOfSize:20];
textView.layer.borderColor = [UIColor blackColor].CGColor;
textView.layer.borderWidth = 1;

/** 设置代理人, 我们要实现的效果, 需要用到代理方法. 在上面签订UITextViewDelegate协议. */
textView.delegate = self;

/** 链接地址能够跳转, textView的编辑状态必须为NO, 否则与普通文本无异. */
textView.editable = NO;

/** 设置自动检测类型为链接网址. */
textView.dataDetectorTypes = UIDataDetectorTypeLink;

/** 设置链接文字的属性. */
textView.linkTextAttributes = @{NSForegroundColorAttributeName: [UIColor orangeColor]};

[self.view addSubview:textView];

/** 第二种连接界面: 文字链接 */
UITextView *otherTextView = [[UITextView alloc] initWithFrame:CGRectMake(30, 350, 300, 150) textContainer:nil];

/** font属性是设置text的字体, 但是它对attributedText的字体不起作用. */
//    otherTextView.font = [UIFont systemFontOfSize:20];

otherTextView.layer.borderColor = [UIColor blackColor].CGColor;
otherTextView.layer.borderWidth = 1;
otherTextView.delegate = self;
otherTextView.editable = NO;

/** 详细内容请见博文说明中提到的另外一篇博客. */
NSAttributedString *linkAttribute = [[NSAttributedString alloc] initWithString:@&quot;百度&quot; attributes:@{NSLinkAttributeName: [NSURL URLWithString:@&quot;http://www.baidu.com&quot;], NSFontAttributeName:[UIFont systemFontOfSize:25]}];

otherTextView.attributedText = linkAttribute;

[self.view addSubview:otherTextView];

}
</code></pre><hr>
<pre><code>/** 当点击链接时, 是否要跳转到浏览器. 默认返回YES. 想要实现在应用程序内部跳转, 只需要返回NO即可. */

- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange {

/** 跳转到WebViewController的WebView上. */

WebViewController *webContro = [[WebViewController alloc] init];

UIWebView *web = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];

/** URL参数就是我们点击的链接地址. */
[web loadRequest:[NSURLRequest requestWithURL:URL]];

web.scalesPageToFit = YES;
[webContro.view addSubview:web];

[self.navigationController pushViewController:webContro animated:YES];

/** 返回NO, 不跳转到浏览器. */
return NO;
}
</code></pre><h2 id="占位符（类似于UITextField的占位符效果）"><a href="#占位符（类似于UITextField的占位符效果）" class="headerlink" title="占位符（类似于UITextField的占位符效果）"></a>占位符（类似于UITextField的占位符效果）</h2><h3 id="核心API-1"><a href="#核心API-1" class="headerlink" title="核心API"></a>核心API</h3><p><a href="https://github.com/zhangzhaopds/UITextView3.git" target="_blank" rel="external">DEMO</a></p>
<pre><code>Class: UITextView
/** 告诉代理人, 用户已经改变指定textView里面的text或者attributes. */
- (void)textViewDidChange:(UITextView *)textView
</code></pre><h3 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h3><p>我们在使用UITextView的时候发现, UITextView没有像UITextField一样的占位符. 如果我们想要在UITextView里面实现占位符的效果, 该怎么办呢?</p>
<pre><code>思路:
我们想要实现和UITextField一样的占位符效果, 那么我们就先看看UITextField是怎么实现的.

.通过观察UITextField的图层, 我们发现, 占位符在一个单独的UILabel上.
.我们让UITextField处于编辑状态, 再来看图层, 会发现在占位符label的上面又多了两层视图.
.我们输入文字之后再看图层, 会发现占位符的lable没有了.
.由此, 我们可以推测, 这个占位符label, 再输入之后, 就被隐藏了.
.我们再来看UITextView的图层, 会发现它也有两个图层, 一个是UITextView, 一个是UITextContainerView. (还有两个滑条, 是UIImageView, 但是和我们实现的效果无关.)
.那我们也可以仿照UITextField, 把一个label放到UITextContainerView的下面, 输入时就隐藏.
.注: UITextView和UITextField 我是使用StoryBoard创建的, 所以在代码中没有创建的代码.
</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>/** 签订协议. */
@interface ViewController ()&lt;UITextViewDelegate&gt;

@property (weak, nonatomic) IBOutlet UITextView *textView;
@property (nonatomic, strong) UILabel *label_Placeholder; /**&lt; 用来显示占位符的label. */
</code></pre><hr>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    _textView.layer.borderColor = [UIColor blackColor].CGColor;
    _textView.layer.borderWidth = 2;

    /** 签订代理人, 实现效果需要用到代理方法. */
    _textView.delegate = self;

    /** 创建占位符label. */
    self.label_Placeholder = [[UILabel alloc] initWithFrame:CGRectMake(5, 0, 200, 40)]; /**&lt; 坐标要根据实际情况做出调整. */

    /** 使用属性文本. 详情请查看博文说明中提到的另一篇博客. */
    _label_Placeholder.attributedText = [[NSAttributedString alloc] initWithString:@&quot;Hello World!&quot; attributes:@{NSFontAttributeName: _textView.font, NSForegroundColorAttributeName: [UIColor grayColor]}];

    /** 我们之前说过了, textView上有UITextContainerView 和 两个UIImageView 子视图, 我们把label_Placeholder放到UITextContainerView的下面, 也就是textView的第一个子视图. */
    [_textView insertSubview:_label_Placeholder atIndex:0];

    /** 可以打印textView的子视图看一下. */
    NSLog(@&quot;%@&quot;, [_textView subviews]);
}
</code></pre><hr>
<pre><code>/** 当textView里面的内容发生改变时, 调用这个代理方法. */
- (void)textViewDidChange:(UITextView *)textView{
/** 判断条件是多次尝试的结果. 大家按照自己的想法, 尝试着写判断条件, 会更加理解为什么这么写了! */
if (_textView.text.length != 0 &amp;&amp; _label_Placeholder.hidden == NO) {

    _label_Placeholder.hidden = YES;

} else if (_textView.text.length == 0) {

    _label_Placeholder.hidden = NO;
}
</code></pre><h2 id="改变选中文本的属性"><a href="#改变选中文本的属性" class="headerlink" title="改变选中文本的属性"></a>改变选中文本的属性</h2><h3 id="核心API-2"><a href="#核心API-2" class="headerlink" title="核心API"></a>核心API</h3><p><a href="https://github.com/zhangzhaopds/UITextView--.git" target="_blank" rel="external">DEMO链接</a></p>
<pre><code>Class : UITextViews

/** 用户输入新的文本属性时, 会被存储在这个字典属性里. */
@property(nonatomic, copy) NSDictionary *typingAttributes

/** */
@property(nonatomic, readonly, retain) NSTextStorage *textStorage

/** 被选中的范围. */
@property(nonatomic) NSRange selectedRange
</code></pre><h3 id="功能实现-2"><a href="#功能实现-2" class="headerlink" title="功能实现"></a>功能实现</h3><p>我们在看小说或文档时, 可以对一些重点内容进行标注, 例如, 加下划线, 改变颜色之类的. 那么UITextView里的内容, 我们是如何进行标注的呢?</p>
<pre><code>思路

首先获取到被选中的文本, 之后改变这段文本的属性设置.
</code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>@interface ViewController ()

@property (weak, nonatomic) IBOutlet UITextView *textView;

@property (nonatomic, strong) NSDictionary *oldAttributes; /** 用来接收textView文本的初始属性设置. */

@end
</code></pre><hr>
<pre><code>- (void)viewDidLoad {
[super viewDidLoad];

/** 我们在textView的文本还未做出任何改变的时候, 将原始属性设置保存起来, 便于以后恢复. */

/** 
 * 初始化oldAttributes.
 * typingAttributes : 在用户没有输入新的文本属性时, 里面会有一些默认的文本属性.
 */
self.oldAttributes = [NSDictionary dictionaryWithDictionary:[_textView typingAttributes]];

/** 打印看一下里面存储的内容. */
NSLog(@&quot;old: %@&quot;, _oldAttributes);

}
</code></pre><hr>
<pre><code>/**
 * textStorage : UITextView的属性, 是NSTextStorage类型.
 * NSTextStorage 继承于NSMutableAttributedString类, 所以可以使用父类的方法.
 * 
 * selectedRange : UITextView的属性, 是NSRange类型.
 * textView当前被选择的文本.
 */
</code></pre><hr>
<pre><code>/** 改变字体的笔画宽度. */
- (IBAction)wordWeight:(UIButton *)sender {

    [_textView.textStorage addAttribute:NSStrokeWidthAttributeName value:@5 range:_textView.selectedRange];

}
</code></pre><hr>
<pre><code>/** 给选中的文本添加黄色背景, 以及下划线. */
- (IBAction)backgroundColor:(UIButton *)sender {

/** 
 * 上面使用的是addAttribute: value: rang: 的方法. 它只能添加一个属性.
 * 如果我们要同时添加多个属性, 我们需要使用addAttributes: rang: 方法.
 * 这个方法的第一个参数是一个字典, 可以在字典中存储多个属性.
 */

[_textView.textStorage addAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange];

/** 
 * 要注意 addAttributes 和 setAttributes 的区别: 
 * addAttributes 是添加属性, 不会将之前的属性移除掉, 它们是共同存在的.
 * setAttributes 是设置属性, 会将之前的属性替换掉, 之前的属性将不会存在.
 */

//  [_textView.textStorage setAttributes:@{NSBackgroundColorAttributeName: [UIColor yellowColor], NSUnderlineStyleAttributeName: @2} range:_textView.selectedRange];
}
</code></pre><hr>
<pre><code>/** 恢复到原来的文本状态. */
- (IBAction)recoverAttribute:(UIButton *)sender {

/** 我们想要恢复之前的属性, 也就是说不再使用做出改变的属性, 所以在这里我使用的是setAttributes: rang: 方法.  */
[_textView.textStorage setAttributes:_oldAttributes range:_textView.selectedRange];

}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-NSAttributedString" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/20/NSAttributedString/" class="article-date">
  	<time datetime="2015-03-20T11:14:35.000Z" itemprop="datePublished">2015-03-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/20/NSAttributedString/"> NSAttributedString</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>NSAttributedString 可以非常方便的实现文字排版和图文混排功能. 共有21中效果(API), 本文将较详细的介绍21种的属性的使用</p>
</blockquote>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="文本API"><a href="#文本API" class="headerlink" title="文本API:"></a>文本API:</h4><pre><code>Character Attributes , NSAttributedString 共有21个属性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFontAttributeName               -&gt;设置字体属性，默认值：字体：Helvetica(Neue) 字号：12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSParagraphStyleAttributeName     -&gt;设置文本段落排版格式，取值为 NSParagraphStyle 对象(详情见下面的API说明)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSForegroundColorAttributeName    -&gt;设置字体颜色，取值为 UIColor对象，默认值为黑色</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSBackgroundColorAttributeName    -&gt;设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLigatureAttributeName           -&gt;设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSKernAttributeName               -&gt;设置字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStrikethroughStyleAttributeName -&gt;设置删除线，取值为 NSNumber 对象（整数）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStrikethroughColorAttributeName -&gt;设置删除线颜色，取值为 UIColor 对象，默认值为黑色</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUnderlineStyleAttributeName     -&gt;设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUnderlineColorAttributeName    -&gt;设置下划线颜色，取值为 UIColor 对象，默认值为黑色</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStrokeWidthAttributeName       -&gt;设置笔画宽度(粗细)，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStrokeColorAttributeName       -&gt;填充部分颜色，不是字体颜色，取值为 UIColor 对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSShadowAttributeName            -&gt;设置阴影属性，取值为 NSShadow 对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSTextEffectAttributeName        -&gt;设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSBaselineOffsetAttributeName    -&gt;设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObliquenessAttributeName       -&gt;设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSExpansionAttributeName         -&gt;设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSWritingDirectionAttributeName  -&gt;设置文字书写方向，从左向右书写或者从右向左书写</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSVerticalGlyphFormAttributeName -&gt;设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLinkAttributeName              -&gt;设置链接属性，点击后调用浏览器打开指定URL地址</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSAttachmentAttributeName        -&gt;设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排</span><br></pre></td></tr></table></figure>
<h4 id="段落API"><a href="#段落API" class="headerlink" title="段落API:"></a>段落API:</h4><pre><code>NSParagraphStyleAttributeName
</code></pre><p>值为NSParagraphStyle，设置段落属性，默认值为[NSParagraphStyle defaultParagraphStyle]返回的值。<br>NSMutableParagraphStyle与NSParagraphStyle包括一下属性</p>
<pre><code>alignment                -&gt;对齐方式
firstLineHeadIndent      -&gt;首行缩进
headIndent               -&gt;缩进
tailIndent               -&gt;尾部缩进
lineBreakMode            -&gt;断行方式
maximumLineHeight        -&gt;最大行高
minimumLineHeight        -&gt;最低行高
lineSpacing              -&gt;行距
paragraphSpacing         -&gt;段距
paragraphSpacingBefore   -&gt;段首空间
baseWritingDirection     -&gt;句子方向
lineHeightMultiple       -&gt;可变行高,乘因数。
hyphenationFactor        -&gt;连字符属性
</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 50, 320, 400)];

self.titleLabel.numberOfLines = 0;

self.titleLabel.layer.borderColor = [UIColor grayColor].CGColor;

self.titleLabel.layer.borderWidth = 0.5;
self.titleLabel.textAlignment = NSTextAlignmentLeft;
[self.view addSubview:self.titleLabel];

NSString *string = @&quot;An NSAttributedString object manages character strings and associated sets of attributes (for example, font and kerning) that apply to individual characters or ranges of characters in the string. An association of characters and their attributes is called an attributed string. &quot;;
这句话就是对这个类的一个最简明扼要的概括。
NSAttributedString管理一个字符串，以及与该字符串中的
单个字符或某些范围的字符串相关的属性。它有一个子类NSMutableAttributedString具体实现时,NSAttributedString
维护了一个NSString，用来保存最原始的字符串，另有一个NSDictionary用来保存各个子串/字符的属性。        
</code></pre><hr>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><pre><code>#pragma mark - NSMutableAttributedString 创建
三种初始化方法,NSMutableAttributedString没有初始化方法,使用父类初始化方法, 使用initWithString:, initWithString:attributes:, 或者 initWithAttributedString: 

NSAttributedString *attStri = [[NSAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:30]}];

NSMutableAttributedString *mAttStri = [[NSMutableAttributedString alloc] initWithString:string];
</code></pre><hr>
<h4 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h4><pre><code>#pragma mark ** 1. NSFontAttributeName 设置字体属性
/* 字体大小 及 字体类型 */
NSRange font_range = [string rangeOfString:@&quot;An&quot;];
[mAttStri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:font_range];
[mAttStri addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;Courier-BoldOblique&quot; size:17.0] range:NSMakeRange(10, 10)];
</code></pre><hr>
<h4 id="文本段落排版格式"><a href="#文本段落排版格式" class="headerlink" title="文本段落排版格式"></a>文本段落排版格式</h4><pre><code>#pragma mark ** 2. NSParagraphStyleAttributeName 设置文本段落排版格式
NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];
style.firstLineHeadIndent = 20;
style.lineSpacing = 10;
[mAttStri addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, mAttStri.length / 2)];
</code></pre><hr>
<h4 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h4><pre><code>#pragma mark ** 3. NSForegroundColorAttributeName 设置字体颜色
/* 值为UIColor，字体颜色，默认为黑色. */
[mAttStri addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, mAttStri.length)];
</code></pre><hr>
<h4 id="字体所在区域背景颜色"><a href="#字体所在区域背景颜色" class="headerlink" title="字体所在区域背景颜色"></a>字体所在区域背景颜色</h4><pre><code>#pragma mark ** 4. NSBackgroundColorAttributeName 设置字体所在区域背景颜色
/* 值为UIColor，字体背景色，默认透明. */
[mAttStri addAttribute:NSBackgroundColorAttributeName value:[UIColor grayColor] range:NSMakeRange(0, 20)];
</code></pre><hr>
<h4 id="连体属性"><a href="#连体属性" class="headerlink" title="连体属性"></a>连体属性</h4><pre><code>#pragma mark ** 5. NSLigatureAttributeName 设置连体属性
/* 取值为NSNumber 对象(整数). 0 表示没有连体字符, 1 表示使用默认的连体字符. 一般中文用不到，在英文中可能出现相邻字母连笔的情况 */
[mAttStri addAttribute:NSLigatureAttributeName value:@0 range:NSMakeRange(0, mAttStri.length)];
</code></pre><hr>
<h4 id="字符间距"><a href="#字符间距" class="headerlink" title="字符间距"></a>字符间距</h4><pre><code>#pragma mark ** 6. NSKernAttributeName 设置字符间距
/* 值为浮点数NSNumber，字距属性，默认值为0。*/
[mAttStri addAttribute:NSKernAttributeName value:@3 range:NSMakeRange(0, mAttStri.length)];
</code></pre><hr>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><pre><code>#pragma mark ** 7. NSStrikethroughStyleAttributeName 设置删除线
/* 值为整型NSNumber，可取值为
    enum {

    NSUnderlineStyleNone = 0×00,

    NSUnderlineStyleSingle = 0×01,

    }; 设置删除线。
*/
[mAttStri addAttribute:NSStrikethroughStyleAttributeName value:@3 range:NSMakeRange(3, 7)];
</code></pre><hr>
<h4 id="删除线颜色"><a href="#删除线颜色" class="headerlink" title="删除线颜色"></a>删除线颜色</h4><pre><code>#pragma mark ** 8. NSStrikethroughColorAttributeName 设置删除线颜色
/* 这个属性的值是一个UIColor对象. */
[mAttStri addAttribute:NSStrikethroughColorAttributeName value:[UIColor blueColor] range:NSMakeRange(3, 3)];
</code></pre><hr>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><pre><code>#pragma mark ** 9. NSUnderlineStyleAttributeName 设置下划线
/* 取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似 */
[mAttStri addAttribute:NSUnderlineStyleAttributeName value:@2 range:NSMakeRange(6, 5)];
</code></pre><hr>
<h4 id="下划线颜色"><a href="#下划线颜色" class="headerlink" title="下划线颜色"></a>下划线颜色</h4><pre><code>#pragma mark ** 10. NSUnderlineColorAttributeName 设置下划线颜色
/* 这个属性的值是一个UIColor对象.默认值为nil. */
[mAttStri addAttribute:NSUnderlineColorAttributeName value:[UIColor blackColor] range:NSMakeRange(6, 5)];
</code></pre><hr>
<h4 id="笔画粗细"><a href="#笔画粗细" class="headerlink" title="笔画粗细"></a>笔画粗细</h4><pre><code>#pragma mark ** 11. NSStrokeWidthAttributeName 设置笔画宽度(粗细)
/* 值为浮点数NSNumber。设置笔画的粗细。负值填充效果，正值中空效果. */
[mAttStri addAttribute:NSStrokeWidthAttributeName value:@10 range:NSMakeRange(50, 30)];
</code></pre><hr>
<h4 id="填充部分颜色-不是字体颜色"><a href="#填充部分颜色-不是字体颜色" class="headerlink" title="填充部分颜色(不是字体颜色)"></a>填充部分颜色(不是字体颜色)</h4><pre><code>#pragma mark ** 12. NSStrokeColorAttributeName 填充部分颜色，
/* 不是字体颜色，取值为 UIColor 对象 默认值为nil，设置的属性同ForegroundColor。*/
[mAttStri addAttribute:NSStrokeColorAttributeName value:[UIColor orangeColor] range:NSMakeRange(50, 20)];
</code></pre><hr>
<h4 id="阴影属性"><a href="#阴影属性" class="headerlink" title="阴影属性"></a>阴影属性</h4><pre><code>#pragma mark ** 13. NSShadowAttributeName 设置阴影属性

/* 值为NSShadow，设置笔画的阴影，默认值为nil。*/
NSShadow *shadow = [[NSShadow alloc]init];
shadow.shadowOffset = CGSizeMake(10, 10);
shadow.shadowColor = [UIColor greenColor];
[mAttStri addAttribute:NSShadowAttributeName value:shadow range:NSMakeRange(20, 10)];
</code></pre><hr>
<h4 id="文本特效"><a href="#文本特效" class="headerlink" title="文本特效"></a>文本特效</h4><pre><code>#pragma mark ** 14. NSTextEffectAttributeName 设置文本特殊效果
/* 这个属性的值是一个NSString对象。使用此属性指定的文字效果，如NSTextEffectLetterpressStyle。此属性的默认值为nil，表示没有文本效应。*/
[mAttStri addAttribute:NSTextEffectAttributeName value:NSTextEffectLetterpressStyle range:NSMakeRange(80, 10)];
</code></pre><hr>
<h4 id="基线偏移值"><a href="#基线偏移值" class="headerlink" title="基线偏移值"></a>基线偏移值</h4><pre><code>#pragma mark ** 15. NSBaselineOffsetAttributeName 设置基线偏移值
/* 此属性的值是包含一个浮点值的NSNumber对象,表示的字符从基线偏移的NSNumber对象，默认值是0。正值上偏，负值下偏 */
[mAttStri addAttribute:NSBaselineOffsetAttributeName value:@5 range:NSMakeRange(112, 10)];
</code></pre><hr>
<h4 id="字形-左倾-右倾"><a href="#字形-左倾-右倾" class="headerlink" title="字形(左倾 右倾)"></a>字形(左倾 右倾)</h4><pre><code>#pragma mark ** 16. NSObliquenessAttributeName 设置字形倾斜度取值为 NSNumber （float）,正值右倾，负值左倾
/* 此属性的值是包含一个浮点值的NSNumber对象。默认值为0，表示没有倾斜, 正值右倾，负值左倾。 */
[mAttStri addAttribute:NSObliquenessAttributeName value:@0.8 range:NSMakeRange(135, 15)];
</code></pre><hr>
<h4 id="文本横向-拉伸-压缩"><a href="#文本横向-拉伸-压缩" class="headerlink" title="文本横向 拉伸 压缩"></a>文本横向 拉伸 压缩</h4><pre><code>#pragma mark ** 17. NSExpansionAttributeName 设置文本横向拉伸属性
/* 取值为 NSNumber(float), 正值横向拉伸文本, 负值横向压缩文本 */
NSRange range =  [string rangeOfString:@&quot;An association of&quot;];
[mAttStri addAttribute:NSExpansionAttributeName value:@1.0 range:range];
</code></pre><hr>
<h4 id="文字书写方向"><a href="#文字书写方向" class="headerlink" title="文字书写方向"></a>文字书写方向</h4><pre><code>#pragma mark ** 18. NSWritingDirectionAttributeName 设置文字书写方向
/** 
 * 取值为包含NSNumber对象的数组. 从左向右书写或者从右向左书写.
 *
 * The values of the NSNumber objects should be 0, 1, 2, or 3, for LRE, RLE, LRO, or RLO respectively, and combinations of NSWritingDirectionLeftToRight and NSWritingDirectionRightToLeft with NSTextWritingDirectionEmbedding or NSTextWritingDirectionOverride, as shown in Values of NSWritingDirectionAttributeName and equivalent markup.
 */
NSRange rang2 = [string rangeOfString:@&quot;characters and their&quot;];
[mAttStri addAttribute:NSWritingDirectionAttributeName value:@[@3] range:rang2];
</code></pre><hr>
<h4 id="文字排版方向-水平、垂直"><a href="#文字排版方向-水平、垂直" class="headerlink" title="文字排版方向(水平、垂直)"></a>文字排版方向(水平、垂直)</h4><pre><code>#pragma mark ** 19. NSVerticalGlyphFormAttributeName 设置文字排版方向
/**
 * 值为整型NSNumber，0为水平排版的字，1为垂直排版的字。注意,在iOS中, 总是以横向排版
 *
 * In iOS, horizontal text is always used and specifying a different value is undefined.
 */
[mAttStri addAttribute:NSVerticalGlyphFormAttributeName value:@1 range:NSMakeRange(1, 10)];
</code></pre><hr>
<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><pre><code>#pragma mark ** 20. NSLinkAttributeName 设置链接属性
/**
 * 此属性的值是NSURL对象（首选）或一个NSString对象。此属性的默认值为nil，表示没有链接。
 * UILabel无法使用该属性, 可以使用UITextView 控件.
 */
UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 450, 320, 60)];
[self.view addSubview:textView];
textView.backgroundColor  = [UIColor lightGrayColor];

NSString *strLink = @&quot;百度链接&quot;;
NSAttributedString *attStr  = [[NSAttributedString alloc] initWithString:strLink attributes:@{NSLinkAttributeName: [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]}];

textView.editable = NO;

/* 签订协议, 指定代理人之后. 但点击链接时, 会回调协议方法 (- textView:shouldInteractWithURL:inRange:) */
textView.delegate = self;

textView.attributedText = attStr;
</code></pre><hr>
<h4 id="文本附件"><a href="#文本附件" class="headerlink" title="文本附件"></a>文本附件</h4><pre><code>#pragma mark ** 21. NSAttachmentAttributeName 设置文本附件
/* 这个属性的值是一个NSTextAttachment对象。此属性的默认值为nil，表示无附件。*/

/**
 * 关于NSTextAttachment类的简单说明
 *
 * NSTextAttachment 类有一个指定的初始化方法(- initWithData:ofType:), 需要指定附件文档的数据和附件文件的类型. 如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值. 因此, 也可以通过这个特性实现图文混排.
 * 下面就以附件为image对象来说明NSAttachmentAttributeName的使用.
 */

UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(20, 550, 320, 60)];
label.backgroundColor = [UIColor yellowColor];
[self.view addSubview:label];

/* 下面实现在百度两个汉字之间插入一个照片 */
NSString *stiAtt = @&quot;百度&quot;;

NSTextAttachment *attach = [[NSTextAttachment alloc] initWithData:nil ofType:nil];
attach.bounds = CGRectMake(0, 0, 50, 50);
attach.image = [UIImage imageNamed:@&quot;baidu.jpg&quot;];

NSAttributedString *strAtt = [NSAttributedString attributedStringWithAttachment:attach];

NSMutableAttributedString *strMatt = [[NSMutableAttributedString alloc] initWithString:stiAtt];

[strMatt insertAttributedString:strAtt atIndex:1];

label.attributedText = strMatt;

self.titleLabel.attributedText = mAttStri;
[self.titleLabel sizeToFit];
}
</code></pre><hr>
<h4 id="UITextView协议"><a href="#UITextView协议" class="headerlink" title="UITextView协议"></a>UITextView协议</h4><pre><code>#pragma mark - textView delegate 
-(BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange {
NSLog(@&quot;%s&quot;, __func__);
NSLog(@&quot;url: %@&quot;, URL);
return YES;
}
</code></pre><hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-runtime的那些巧用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/06/runtime的那些巧用/" class="article-date">
  	<time datetime="2015-03-06T13:53:22.000Z" itemprop="datePublished">2015-03-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/runtime的那些巧用/">Runtime</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-获取类的属性列表"><a href="#1-获取类的属性列表" class="headerlink" title="1.获取类的属性列表"></a>1.获取类的属性列表</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a><code>API</code></h3><pre><code>`class_copyPropertyList(Class cls, unsigned int *outCount)`
</code></pre><h3 id="在复杂对象存储中的简单应用-归档和反归档"><a href="#在复杂对象存储中的简单应用-归档和反归档" class="headerlink" title="在复杂对象存储中的简单应用-归档和反归档"></a><code>在复杂对象存储中的简单应用-归档和反归档</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">归档</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    </span><br><span class="line">    unsigned int num = 0;</span><br><span class="line">   </span><br><span class="line">    获取属性列表</span><br><span class="line">    objc_property_t *propertys = class_copyPropertyList([Person class], &amp;num);</span><br><span class="line">    </span><br><span class="line">    遍历Person类的属性列表，逐一归档</span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        objc_property_t property = propertys[i];</span><br><span class="line">        </span><br><span class="line">        const char *name = property_getName(property);</span><br><span class="line">        </span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        </span><br><span class="line">        归档</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">反归档</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    if (self) &#123;</span><br><span class="line">        unsigned int num = 0;</span><br><span class="line">        </span><br><span class="line">        objc_property_t *propertys = class_copyPropertyList([Person class], &amp;num);</span><br><span class="line">        </span><br><span class="line">        遍历Person类的属性列表，逐一反归档</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            objc_property_t property = propertys[i];</span><br><span class="line">            </span><br><span class="line">            const char *name = property_getName(property);</span><br><span class="line">            </span><br><span class="line">            NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">            </span><br><span class="line">            // 反归档</span><br><span class="line">            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-为类添加方法"><a href="#2-为类添加方法" class="headerlink" title="2.为类添加方法"></a>2.为类添加方法</h2><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a><code>API</code></h3><pre><code>`class_addMethod(Class cls, SEL name, IMP imp, const char *types)`
</code></pre><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a><code>简单应用</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">`为Person类添加一个Method3的方法，此方法能打印出“Hello”`</span><br><span class="line"></span><br><span class="line">下面的方法的是 `- void sayHello;` 方法的实现函数：</span><br><span class="line">void sayHello(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    为Person类添加method3方法</span><br><span class="line">    class_addMethod([Person class], @selector(method3), (IMP)sayHello, &quot;v&quot;);</span><br><span class="line">    </span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    </span><br><span class="line">    获取Person类的方法列表</span><br><span class="line">    Method * mem = class_copyMethodList([Person class], &amp;count);</span><br><span class="line">    </span><br><span class="line">    通过遍历，查看Person类的所有方法</span><br><span class="line">    for ( int  i=0;i&lt;count;i++)&#123;</span><br><span class="line">    </span><br><span class="line">        SEL name = method_getName(mem[i]);</span><br><span class="line">        </span><br><span class="line">        NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%d: %@&quot; , i, method);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    </span><br><span class="line">    实现method3方法</span><br><span class="line">    [person performSelector:@selector(method3)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line">2015-12-06 22:57:30.391 Runtime[42093:505478] 0: method3</span><br><span class="line">`这条信息说明method3方法已经添加到了Person类里面`</span><br><span class="line"></span><br><span class="line">2015-12-06 22:57:30.393 Runtime[42093:505478] Hello</span><br><span class="line">`Hello的打印,说明method3方法实现了方法 `- void sayHello;` 的实现`</span><br></pre></td></tr></table></figure>
<p><code>types参数</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">如要添加一个这样的方法：-(int)say:(NSString *)str;</span><br><span class="line"></span><br><span class="line">相应的实现函数就应该是这样：</span><br><span class="line">int say(id self, SEL _cmd, NSString *str) </span><br><span class="line">&#123; </span><br><span class="line">    NSLog(@&quot;%@&quot;, str); </span><br><span class="line">    return 100;//随便返回个值 </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">class_addMethod这句就应该这么写：</span><br><span class="line"></span><br><span class="line">class_addMethod([EmptyClass class], @selector(say:), (IMP)say, &quot;i@:@&quot;);</span><br><span class="line"></span><br><span class="line">其中types参数为&quot;i@:@“，按顺序分别表示：</span><br><span class="line"></span><br><span class="line">i ：返回值类型int，若是v则表示void</span><br><span class="line"></span><br><span class="line">@ ：参数id(self)</span><br><span class="line"></span><br><span class="line">: ：SEL(_cmd)</span><br><span class="line"></span><br><span class="line">@ ：id(str)</span><br></pre></td></tr></table></figure>
<h2 id="3-方法调剂"><a href="#3-方法调剂" class="headerlink" title="3.方法调剂"></a>3.方法调剂</h2><h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a><code>API</code></h3><pre><code>`method_exchangeImplementations(Method m1, Method m2)`
</code></pre><h3 id="方法实现的对调"><a href="#方法实现的对调" class="headerlink" title="方法实现的对调"></a><code>方法实现的对调</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">简单案例：将UIView的 `setBackgroundColor:` 方法 的实现 和 自定义的方法 `- (void)night:(UIColor *)color；` 的实现 进行对调。</span><br><span class="line"></span><br><span class="line">创建基于UIView的Category：UIView+Night.h</span><br><span class="line"></span><br><span class="line">·#import &quot;UIView+Night.h&quot;</span><br><span class="line">·#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIView (Night)</span><br><span class="line"></span><br><span class="line">自定义的方法</span><br><span class="line">- (void)night:(UIColor *)color &#123;</span><br><span class="line">    if ([color isEqual:[UIColor yellowColor]]) &#123;</span><br><span class="line">    	</span><br><span class="line">        [self night:[UIColor blackColor]];</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	</span><br><span class="line">    	此处调用night方法不会出错，因为此处的night的实现已经更换</span><br><span class="line">        [self night:color];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">	</span><br><span class="line">	获取方法</span><br><span class="line">    Method a = class_getInstanceMethod([UIView class], @selector(setBackgroundColor:));</span><br><span class="line">    </span><br><span class="line">    Method b = class_getInstanceMethod([UIView class], @selector(night:));</span><br><span class="line">    </span><br><span class="line">    将两个方法的实现进行对调</span><br><span class="line">    method_exchangeImplementations(a, b);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>结果验证</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在VC中，当执行</span><br><span class="line"></span><br><span class="line">self.view.backgroundColor = [UIColor yellowColor];</span><br><span class="line"></span><br><span class="line">时，视图的颜色应该是`黑色`的。</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 百度一下jms
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>